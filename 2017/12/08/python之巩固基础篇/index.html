<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.2" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hello, Nana" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.2" />






<meta name="description" content="第1章 Python入门导学 1-1 导学 (11:33) python2处于维护期 了解语法是编程的先决条件，精通语法是编好程的必要条件 Life is simple, I use python. 如何交换两个变量？ x, y = y, x Python之禅 1-2 Python的特性 (12:34) Life is short i use python 面向对象 是一种思想 面向对象 面向过程">
<meta property="og:type" content="article">
<meta property="og:title" content="python之巩固基础篇">
<meta property="og:url" content="http://yoursite.com/2017/12/08/python之巩固基础篇/index.html">
<meta property="og:site_name" content="Nana&#39;s Blog">
<meta property="og:description" content="第1章 Python入门导学 1-1 导学 (11:33) python2处于维护期 了解语法是编程的先决条件，精通语法是编好程的必要条件 Life is simple, I use python. 如何交换两个变量？ x, y = y, x Python之禅 1-2 Python的特性 (12:34) Life is short i use python 面向对象 是一种思想 面向对象 面向过程">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-12-17T15:14:51.634Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="python之巩固基础篇">
<meta name="twitter:description" content="第1章 Python入门导学 1-1 导学 (11:33) python2处于维护期 了解语法是编程的先决条件，精通语法是编好程的必要条件 Life is simple, I use python. 如何交换两个变量？ x, y = y, x Python之禅 1-2 Python的特性 (12:34) Life is short i use python 面向对象 是一种思想 面向对象 面向过程">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.2',
    sidebar: {"position":"top","display":"post","offset":12,"offset_float":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/12/08/python之巩固基础篇/"/>





  <title>python之巩固基础篇 | Nana's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-top page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Nana's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">Today is the first day of the rest of your life.</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/12/08/python之巩固基础篇/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Nana Xie">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Nana's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">python之巩固基础篇</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-08T22:40:48+08:00">
                2017-12-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/12/08/python之巩固基础篇/" class="leancloud_visitors" data-flag-title="python之巩固基础篇">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>第1章 Python入门导学</p>
<p>1-1 导学 (11:33)</p>
<p>python2处于维护期</p>
<p>了解语法是编程的先决条件，精通语法是编好程的必要条件</p>
<p>Life is simple, I use python.</p>
<p>如何交换两个变量？ x, y = y, x</p>
<p>Python之禅</p>
<p>1-2 Python的特性 (12:34)</p>
<p>Life is short i use python</p>
<p>面向对象 是一种思想</p>
<p>面向对象 面向过程</p>
<p>1-3 我为什么喜欢Python (09:28)</p>
<p>python 动态脚本 又有面向对象的特性</p>
<p>1-4 Python的缺点 (08:25)</p>
<p>慢 </p>
<p>运行效率和开发效率，鱼与熊掌不可兼得</p>
<p>1-5 一个经典误区 (04:19)</p>
<p>编程是为了解决问题</p>
<p>web只是编程的一个应用方向</p>
<p>1-6 python能做些什么？ (05:44)</p>
<p>python主流功能</p>
<p>遇到问题，拿起python,编写工具</p>
<p>1-7 课程内容与特点 (08:32)</p>
<p>基础知识不够扎实</p>
<p>python高性能与优化</p>
<p>数据结构是扎实的编程功底的基础</p>
<p>数据结构和语言无关</p>
<p>1-8 Python的前景 (05:28)</p>
<p>如果人的一生只能选择一门语言？</p>
<p>1-9 课程维护与提问 (01:45)</p>
<p>慕课手记<br>知乎专栏：小楼昨夜又秋风</p>
<p>第2章 Python环境安装</p>
<p>2-1 下载Python安装包 (03:22)</p>
<p>python3.5以上版本不支持windows XP</p>
<p>2-2 安装Python (02:31)</p>
<p>Add python3.x to PATH</p>
<p>查阅python官方文档</p>
<p>2-3 IDLE与第一段Python代码 (02:55)</p>
<p>IDLE options - config IDLE</p>
<p>python 代码末尾不需要分号</p>
<p>python靠缩进来控制代码格式</p>
<p>第3章 理解什么是写代码与Python的基本类型</p>
<p>3-1 什么是代码，什么是写代码 (04:22)</p>
<p>代码是现实世界事物在计算机世界的映射</p>
<p>写代码是将现实世界中的事物用计算机语言来描述</p>
<p>计算机语言：基本数据类型 逻辑思维 构成</p>
<p>3-2 数字：整形与浮点型 (07:21)</p>
<p>Number:数字   整数 小数      整数int（其他语言short int long,python简化只有int这种数据类型，） 浮点数float(其他语言还分单精度float和双精度double，精度越高，数值越准确) python只有一种类型 因为python支持的就是双精度</p>
<blockquote>
<blockquote>
<blockquote>
<p>type(1)</p>
<p><class 'int'=""><br>type(-1)</class></p>
<p><class 'int'=""><br>type(1.1)</class></p>
<p><class 'float'=""><br>type(-1.111111111111111111111111111111111111111)</class></p>
<class 'float'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>混合计算</p>
<blockquote>
<blockquote>
<blockquote>
<p>type(1+0.1)</p>
<p><class 'float'=""><br>type(1+1)</class></p>
<p><class 'int'=""><br>type(1.1+0.9)</class></p>
<p><class 'float'=""><br>type(1+1.0)</class></p>
<p><class 'float'=""><br>type(1*1)</class></p>
<p><class 'int'=""><br>type(1*1.0)</class></p>
<class 'float'="">


</class></blockquote>
</blockquote>
</blockquote>
<p>注意！！！！！</p>
<blockquote>
<blockquote>
<blockquote>
<p>type(2/2)</p>
<p><class 'float'=""><br>type(2//2)</class></p>
<class 'int'="">

<p>type(2.0//2)</p>
<class 'float'="">

<p>type(2.0//2.0)</p>
<class 'float'="">


<p>2/2<br>1.0<br>2//2<br>1<br>2.0//2.0<br>1.0</p>
</class></class></class></blockquote>
</blockquote>
</blockquote>
<p>1//2？</p>
<blockquote>
<blockquote>
<blockquote>
<p>1//2<br>0</p>
</blockquote>
</blockquote>
</blockquote>
<p>/ 除法  //整除</p>
<p>python2的情况可能不一样，试下</p>
<p>python3 只有int python2 还有long</p>
<p>3-3 10、2、8、16进制 (08:32)</p>
<p>满N进一</p>
<p>0 1 2 3 4 5 6 7 8 9 10 满10进一<br>0 1 10 满2进一<br>二进制的10和十进制的10不是同一个概念</p>
<p>0 1 2 3 4 5 6 7 10</p>
<p>0 1 2 3 4 5 6 7 8 9 A B C D E F 10</p>
<p>还有其他进制 60秒=1分</p>
<p>3-4 - 各进制的表示与转换 (07:35)</p>
<p>不同进制里，python如何区分数字10</p>
<p>python表示二进制：<br>0b<br>0b10 二进制的数字10</p>
<p>二进制转换成10进制</p>
<blockquote>
<blockquote>
<blockquote>
<p>0b10<br>2<br>0b11<br>3</p>
</blockquote>
</blockquote>
</blockquote>
<p>python表示八进制：<br>0o<br>0o10 八进制的10</p>
<blockquote>
<blockquote>
<blockquote>
<p>0o10<br>8<br>0o11<br>9</p>
</blockquote>
</blockquote>
</blockquote>
<p>python表示十六进制：<br>0x<br>0x10 十六进制的10</p>
<blockquote>
<blockquote>
<blockquote>
<p>0x10<br>16<br>0x1F<br>31</p>
</blockquote>
</blockquote>
</blockquote>
<p>IDLE默认转换成十进制</p>
<p>其他进制转化二进制：<br>bin()</p>
<blockquote>
<blockquote>
<blockquote>
<p>bin(10)<br>‘0b1010’<br>bin(0o7)<br>‘0b111’<br>bin(0xE)<br>‘0b1110’</p>
</blockquote>
</blockquote>
</blockquote>
<p>其他进制转化十进制：<br>int()</p>
<blockquote>
<blockquote>
<blockquote>
<p>int(0b111)<br>7<br>int(0o77)<br>63</p>
</blockquote>
</blockquote>
</blockquote>
<p>其他进制转化十六进制：<br>hex()</p>
<blockquote>
<blockquote>
<blockquote>
<p>hex(888)<br>‘0x378’<br>hex(0o777)<br>‘0x1ff’</p>
</blockquote>
</blockquote>
</blockquote>
<p>其他进制转化成八进制:<br>oct()</p>
<blockquote>
<blockquote>
<blockquote>
<p>oct(0b111)<br>‘0o7’<br>oct(0x777)<br>‘0o3567’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3-5 数字：布尔类型与复数 (08:24)</p>
<p>还包括bool 布尔类型：表示真 假</p>
<p>还有complex 复数</p>
<p>注意 T和F是大写的 ！！！</p>
<blockquote>
<blockquote>
<blockquote>
<p>True<br>True<br>False<br>False<br>true<br>Traceback (most recent call last):<br>  File “<pyshell#22>“, line 1, in <module><br>    true<br>NameError: name ‘true’ is not defined<br>false<br>Traceback (most recent call last):<br>  File “<pyshell#23>“, line 1, in <module><br>    false<br>NameError: name ‘false’ is not defined</module></pyshell#23></module></pyshell#22></p>
<p>和其他语言不一样</p>
<p>type(True)</p>
<p><class 'bool'=""><br>type(False)</class></p>
<class 'bool'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>为什么布尔类型会归到数字这个分类下面？</p>
<p>转换十进制：</p>
<blockquote>
<blockquote>
<blockquote>
<p>int(True)<br>1<br>int(False)<br>0</p>
</blockquote>
</blockquote>
</blockquote>
<p>转换成布尔类型：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bool(1)<br>True<br>bool(0)<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p>一正一反论证了布尔类型在python是属于数字类型的</p>
<p>是不是只有数字1表示True,0表示false?</p>
<p>只要是非0的数字都表示的是布尔真，只有0表示布尔假</p>
<blockquote>
<blockquote>
<blockquote>
<p>bool(2)<br>True<br>bool(2.2)<br>True<br>bool(-1.1)<br>True<br>bool(0)<br>False<br>bool(0b01)<br>True<br>bool(0b0)<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p>并不是只有数字才能表示布尔类型，或者和布尔类型做转换<br>字符串：</p>
<blockquote>
<blockquote>
<blockquote>
<p>bool(‘abc’)<br>True<br>bool(‘’)<br>False<br>列表：<br>bool([1,2,3])<br>True<br>bool([])<br>False<br>集合：<br>bool({1,2,3})<br>True<br>bool({})<br>False<br>重要！！！<br>数字0和一系列空值都会被认为是布尔假 False<br>非空 True  空值 False</p>
</blockquote>
</blockquote>
</blockquote>
<p>python特殊类型：None</p>
<blockquote>
<blockquote>
<blockquote>
<p>bool(None)<br>False</p>
</blockquote>
</blockquote>
</blockquote>
<p>python如何表示复数？<br>j</p>
<blockquote>
<blockquote>
<blockquote>
<p>36j<br>36j</p>
</blockquote>
</blockquote>
</blockquote>
<p>3-6 字符串：单引号与双引号 (09:08)<br>学习编程：抓大放小</p>
<p>曾经沧海难为水，除却巫山不是云。<br>取次花丛懒回顾，半缘修道半缘君。<br>               ——-唐 元稹</p>
<p>str 字符串</p>
<p>字符串的操作都是必不可少的，非常重要的</p>
<p>python如何表示字符串？<br>单引号 双引号 三引号</p>
<p>1 和 ‘1’ 是同样一个东西吗？</p>
<blockquote>
<blockquote>
<blockquote>
<p>type(1)</p>
<p><class 'int'=""><br>type(‘1’)</class></p>
<p><class 'str'=""><br>很多bug是这个问题引起的</class></p>
</blockquote>
</blockquote>
</blockquote>
<p>中文引号不能表示字符串</p>
<p>python所有的符号都不能是中文的，必须是英文的</p>
<p>为什么除了单引号还要有双引号？</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘let’s go’<br>SyntaxError: invalid syntax<br>“let’s go”<br>“let’s go”</p>
</blockquote>
</blockquote>
</blockquote>
<p>引号表示字符串的时候需要成对出现   里面的引号是文字本事呢的内容</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘let\’s go’<br>“let’s go”<br>\转义字符</p>
</blockquote>
</blockquote>
</blockquote>
<p>“let’s go”  更推荐这种表示方法</p>
<p>3-7 多行字符串 (10:32)<br>python建议 每行宽度最大是79</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘’’hello nana<br>hello nana<br>hello nana<br>‘’’<br>‘hello nana\nhello nana\nhello nana\n’<br>“””hello<br>hello<br>hello<br>“””<br>‘hello\nhello\nhello\n’</p>
</blockquote>
</blockquote>
</blockquote>
<p>三个单引号 三个双引号 都可以<br>效果是一样的</p>
<p>\n 表示回车  敲击回车的动作</p>
<p>tab虽然看不到，但是也是一个字符的存在</p>
<p>反向思维：</p>
<blockquote>
<blockquote>
<blockquote>
<p>‘hello nana\nhello nana\nhello nana\n’<br>‘hello nana\nhello nana\nhello nana\n’<br>不会，会原样显示出来，不会换行</p>
<p>print(‘hello nana\nhello nana\nhello nana\n’)<br>hello nana<br>hello nana<br>hello nana</p>
<p>这样就是换行的</p>
</blockquote>
</blockquote>
</blockquote>
<p>IDLE和print函数的显示特点<br>print函数的显示特点要牢记<br>有些面试会问道IDLE的特性<br>单引号 双引号 也有换行的特性， 不只三引号</p>
<p>常见的理解上的误区：<br>三个引号不一定要换行</p>
<blockquote>
<blockquote>
<blockquote>
<p>“””hello world<br>hello nana”””<br>‘hello world\nhello nana’<br>“””<br>hello world<br>hello nana”””<br>‘\nhello world\nhello nana’</p>
<p>“””<br>hello world<br>hello nana<br>“””<br>‘\nhello world\nhello nana\n’</p>
<p>‘hello<br>SyntaxError: EOL while scanning string literal<br>‘hello\<br>world’<br>‘helloworld’<br>加个反斜杠就不会报错<br>这也是字符串换行的方式 单引号和双引号换行的方式</p>
</blockquote>
</blockquote>
</blockquote>
<p>基本常识牢记，写代码才能写的快</p>
<p>好记性不如烂笔头</p>
<p>3-8 转义字符 (04:24)</p>
<p>特殊的字符 </p>
<p>无法“看见”的字符<br>与语言本身语法有冲突的字符  如单引号 作为普通字符和python语法是有冲突的</p>
<p>\n 换行<br>\’ 单引号<br>\t 横向制表符</p>
<p>注意！！！</p>
<p>\n  换行<br>\r 回车</p>
<p>是不一样的 不是同一个概念</p>
<p>????????</p>
<p>思考：<br>print(‘hello \n world’)  要求\n 也被输出出来</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(‘hello \n world’)<br>hello<br> world</p>
</blockquote>
</blockquote>
</blockquote>
<p>我的尝试：</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(‘hello \n world’)<br>hello \n world<br>print(r’hello \n world’)<br>hello \n world</p>
</blockquote>
</blockquote>
</blockquote>
<p>3-9 原始字符串 (05:44)</p>
<p>输出文件夹的路径；</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(‘c:\northwind\northwest’)<br>c:<br>orthwind<br>orthwest<br>print(‘c:\northwind\northwest’)<br>c:\northwind\northwest<br>print(r’c:\northwind\northwest’)<br>c:\northwind\northwest</p>
</blockquote>
</blockquote>
</blockquote>
<p>加上r，字符串就不是一个普通字符串了，而是一个原始字符串  原始字符串 所见即所得</p>
<blockquote>
<blockquote>
<blockquote>
<p>print(r’let’s go’)</p>
</blockquote>
</blockquote>
</blockquote>
<p>SyntaxError: invalid syntax</p>
<blockquote>
<blockquote>
<blockquote>
<p>为什么？<br>不是一个字符串，更加不可能是一个原始字符串</p>
</blockquote>
</blockquote>
</blockquote>
<p>要么记笔记 要么多写代码</p>
<p>3-10 字符串运算 一 (07:24)</p>
<p>字符串的操作在编程中是用的非常非常多的</p>
<p>字符串合并</p>
<p>字符串只保留一部分</p>
<p>字符串的运算：</p>
<p>字符串拼接：用的非常多</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello” + “world”<br>‘helloworld’</p>
</blockquote>
</blockquote>
</blockquote>
<p>字符串的乘法：</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello”*3<br>‘hellohellohello’</p>
</blockquote>
</blockquote>
</blockquote>
<p>字符串乘以字符串会报错：</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello” <em> “world”<br>Traceback (most recent call last):<br>  File “<pyshell#46>“, line 1, in <module><br>    “hello” </module></pyshell#46></em> “world”<br>TypeError: can’t multiply sequence by non-int of type ‘str’</p>
</blockquote>
</blockquote>
</blockquote>
<p>获取字符串单个字符：</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello world”[0]<br>‘h’<br>“hello world”[1]<br>‘e’<br>“hello world”[3]<br>‘l’<br>“hello world”[4]<br>‘o’</p>
</blockquote>
</blockquote>
</blockquote>
<p>下标操作符<br>注意！！！下标的序号是从0开始的</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello world”[-1]<br>‘d’<br>“hello world”[-3]<br>‘r’</p>
</blockquote>
</blockquote>
</blockquote>
<p>正数<br>负数 从末尾往前数n次得到的字符</p>
<p>思考：获取“hello world” w 字符  两种方式</p>
<p>我的：</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello world”[6]<br>‘w’<br>“hello world”[-5]<br>‘w’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3-11 字符串运算 二 (04:48)</p>
<p>截取一组字符：<br>起点 终点</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello world”[0:4]<br>‘hell’<br>“hello world”[0:5]<br>‘hello’</p>
</blockquote>
</blockquote>
</blockquote>
<p>最后要截取的字符的下一位</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello world”[0:-1]<br>‘hello worl</p>
</blockquote>
</blockquote>
</blockquote>
<p>负数 表示步长的概念 长度的概念</p>
<p>思考：<br>”hello world”截取world  两种方式</p>
<p>我的尝试：</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello world”[6: 11]<br>‘world’<br>“hello world”[6: -1]<br>‘worl’<br>“hello world”[6: 0]<br>‘’<br>“hello world”[6:]<br>‘world’<br>“hello world”[-5:]<br>‘world’</p>
<p>“hello world”[6: 11]<br>‘world’</p>
<p>“hello world”[6:]<br>‘world’</p>
<p>“hello world”[6: 11]<br>‘world’</p>
</blockquote>
</blockquote>
</blockquote>
<p>3-12 字符串运算 三 (08:37)</p>
<p>老师：</p>
<blockquote>
<blockquote>
<blockquote>
<p>“hello world”[6: 20]<br>‘world’<br>保持好奇心</p>
<p>“hello world”[6: 0]<br>‘’<br>“hello world”[6: -0]<br>‘’<br>得到的都是空</p>
<p>“hello python java ruby”[:-4]<br>‘hello python java ‘<br>“hello python java ruby”[0:-4]<br>‘hello python java ‘</p>
<p>“hello python java ruby”[-4:]<br>‘ruby’</p>
</blockquote>
</blockquote>
</blockquote>
<p>原始字符串<br>r R 都可以</p>
<blockquote>
<blockquote>
<blockquote>
<p>r’c:\windows\nana’<br>‘c:\windows\nana’<br>R’c:\windows\nana’<br>‘c:\windows\nana’</p>
</blockquote>
</blockquote>
</blockquote>
<p>为什么变成两条横杆了？？？</p>
<p>笔记 整理思路的过程</p>
<p>第4章 Python中表示“组”的概念与定义</p>
<p>4-1 列表的定义 (06:47)</p>
<p>python如何表示组的概念？</p>
<p>表示组的方法有很多种</p>
<p>python如何定义列表：<br>[1,2,3,4,5,6] 中间逗号分隔</p>
<blockquote>
<blockquote>
<blockquote>
<p>type([1,2,3,4,5,6])</p>
<class 'list'="">


</class></blockquote>
</blockquote>
</blockquote>
<p>内部类型是可以混合的：<br>[‘hello’, ‘world’, 1, 9, True, False]</p>
<blockquote>
<blockquote>
<blockquote>
<p>type([‘hello’, ‘world’, 1, 9, True, False])</p>
<class 'list'="">

<p>type([[1,2],[3,4],[5,6]])</p>
<p><class 'list'=""><br>二维数组  python中叫嵌套列表</class></p>
</class></blockquote>
</blockquote>
</blockquote>
<p>4-2 列表的基本操作 (07:06)</p>
<p>访问列表某个元素<br>[1,2,3,4]</p>
<blockquote>
<blockquote>
<blockquote>
<p>[1,2,3,4][0]<br>1</p>
<p>[1,2,3,4][0:2]<br>[1, 2]</p>
<p>[1,2,3,4][-1:]<br>[4]</p>
</blockquote>
</blockquote>
</blockquote>
<p>注意！！！！！！！<br>单一下标，得到的是数组<br>冒号 得到的是一个列表 哪怕列表只有一个元素<br>细节问题 容易引起代码的Bug</p>
<p>提高写代码效率，基本功必须扎实</p>
<p>列表的截取，同字符串的截取</p>
<p>列表追加元素：<br>列表合并：</p>
<blockquote>
<blockquote>
<blockquote>
<p>[1,2,3,4] + [1,2,3,4]<br>[1, 2, 3, 4, 1, 2, 3, 4]</p>
</blockquote>
</blockquote>
</blockquote>
<p>乘法：</p>
<blockquote>
<blockquote>
<blockquote>
<p>[1,2,3,4]<em>3<br>[1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]<br>[1,2,3,4]</em>[1,2,3,4]<br>Traceback (most recent call last):<br>  File “<pyshell#99>“, line 1, in <module><br>    [1,2,3,4]*[1,2,3,4]<br>TypeError: can’t multiply sequence by non-int of type ‘list’</module></pyshell#99></p>
</blockquote>
</blockquote>
</blockquote>
<p>列表的减法：</p>
<blockquote>
<blockquote>
<blockquote>
<p>[1,2,3,4]-[1]<br>Traceback (most recent call last):<br>  File “<pyshell#0>“, line 1, in <module><br>    [1,2,3,4]-[1]<br>TypeError: unsupported operand type(s) for -: ‘list’ and ‘list’<br>没有这样的操作</module></pyshell#0></p>
</blockquote>
</blockquote>
</blockquote>
<p>编程是实践性非常强的工作</p>
<p>经常试一试</p>
<p>思考：世界杯分组情况</p>
<p>4-3 元组 (10:22)<br>有趣的问题，L=[‘’] 字符长度为什么也是1<br>空字符串也是一个元素</p>
<p>元组的访问：<br>和列表 字符串是一样的</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1,2,3,4)[0]<br>1</p>
<p>(1,2,3,4)[0:2]<br>(1, 2)</p>
</blockquote>
</blockquote>
</blockquote>
<p>相加：</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1,2,3,4) + (1,2,3,4)<br>(1, 2, 3, 4, 1, 2, 3, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<p>相乘：</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1,2,3,4) * 3<br>(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4)</p>
</blockquote>
</blockquote>
</blockquote>
<p>为什么python要区别列表和元组？</p>
<p>int str list tuple</p>
<blockquote>
<blockquote>
<blockquote>
<p>type((1,2,3))</p>
<p><class 'tuple'=""><br>type(1)</class></p>
<p><class 'int'=""><br>type([1,2,3])</class></p>
<p><class 'list'=""><br>type([‘hello’])</class></p>
<class 'list'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>class就是面向对象的类</p>
<p>奇怪的现象：</p>
<blockquote>
<blockquote>
<blockquote>
<p>type((1))</p>
<p><class 'int'=""><br>type((‘hello’))</class></p>
<class 'str'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>为什么不是显示tuple?</p>
<p>因为（）即可以表示元组，也是数学计算的基本符号，数学运算符</p>
<p>python硬性规定：（1）表示数学运算符，type((1))等同于type(1)</p>
<p>如何定义只有一个元素的元组？</p>
<blockquote>
<blockquote>
<blockquote>
<p>(1)<br>1<br>(1,)<br>(1,)<br>type((1,))</p>
<class 'tuple'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>如何表示一个元素都没有的空的元组：</p>
<blockquote>
<blockquote>
<blockquote>
<p>()<br>()<br>type(())</p>
<class 'tuple'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>发散：</p>
<blockquote>
<blockquote>
<blockquote>
<p>type([1])</p>
<class 'list'="">




</class></blockquote>
</blockquote>
</blockquote>
<p>4-4 序列总结 (17:17)</p>
<p>int float bool str list tuple</p>
<p>str list tuple 很多相似之处  —-都是序列</p>
<p>序列都有哪些共有的操作？</p>
<ol>
<li>[n] 中括号和序号获取元素  —-序列每个元素都将被分配一个序号， 都有顺序，也有序号<br>序号的概念</li>
<li>切片：<br>切片还有一种有趣的用法：<blockquote>
<blockquote>
<blockquote>
<p>“hello world”[0:8:2]<br>‘hlow’</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>序列可以加和乘</li>
<li>判断序列是否包含某个元素？<br>in 运算符<blockquote>
<blockquote>
<blockquote>
<p>3 in [1,2,3,4,5]<br>True<br>10 in [1,2,3,4,5]<br>False</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<p>不在：</p>
<blockquote>
<blockquote>
<blockquote>
<p>3 not in [1,2,3,4,5]<br>False<br>10 not in [1,2,3,4,5]<br>True</p>
<ol>
<li>统计序列元素<br>len([1,2,3,4,5])<br>5</li>
</ol>
<p>len(“hello world”)<br>11<br>注意空格</p>
</blockquote>
</blockquote>
</blockquote>
<ol>
<li>求最大<blockquote>
<blockquote>
<blockquote>
<p>max([1,2,3,4,5])<br>5</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<p>7.求最小</p>
<blockquote>
<blockquote>
<blockquote>
<p>min([1,2,3,4,5])<br>1</p>
<p>max(“hello world”)<br>‘w’<br>min(“hello world”)<br>‘ ‘<br>min(“helloworld”)<br>‘d’<br>涉及字符编码，ascii,<br>ord() return the unicode code point for a one-character string<br>ord(‘w’)<br>119<br>ord(‘ ‘)<br>32<br>ord(‘d’)<br>100</p>
</blockquote>
</blockquote>
</blockquote>
<p>还有一种无序的集合类型</p>
<p>4-5 set 集合 (12:19)</p>
<p>集合 set</p>
<p>集合非常重要的特性： 无序</p>
<p>序列是有序的，但是集合最大的特点是无序的</p>
<p>集合定义：</p>
<blockquote>
<blockquote>
<blockquote>
<p>type({1, 1, 2, 3, 4, 5})</p>
<class 'set'="">

<p>{1, 1, 2, 3, 4, 5}[0]<br>Traceback (most recent call last):<br>  File “<pyshell#43>“, line 1, in <module><br>    {1, 1, 2, 3, 4, 5}[0]<br>TypeError: ‘set’ object does not support indexing<br>集合是无序的，没有下标索引</module></pyshell#43></p>
<p>{1, 1, 2, 3, 4, 5}[0:2]<br>Traceback (most recent call last):<br>  File “<pyshell#44>“, line 1, in <module><br>    {1, 1, 2, 3, 4, 5}[0:2]<br>TypeError: ‘set’ object is not subscriptable<br>更不支持切片操作</module></pyshell#44></p>
</class></blockquote>
</blockquote>
</blockquote>
<p>集合的第二个特点：不重复</p>
<blockquote>
<blockquote>
<blockquote>
<p>{1, 1, 2, 2, 3, 3, 4, 4, 5, 5}<br>{1, 2, 3, 4, 5}<br>所有重复元素都被剔除掉</p>
</blockquote>
</blockquote>
</blockquote>
<p>集合支持的操作：</p>
<ol>
<li><p>长度判断：<br>len()</p>
<blockquote>
<blockquote>
<blockquote>
<p>len({1,2,3})<br>3<br>len({1,1,2,2,3,3})<br>3</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li><p>判断集合是否包含某个元素</p>
<blockquote>
<blockquote>
<blockquote>
<p>1 in {1,1,2,2,3,3}<br>True<br>1 not in {1,1,2,2,3,3}<br>False<br>8 in {1,1,2,2,3,3}<br>False<br>8 not in {1,1,2,2,3,3}<br>True</p>
</blockquote>
</blockquote>
</blockquote>
</li>
</ol>
<p>集合的优势在哪里？<br>{1，2，3，4，5，6} {3，4}<br>如何将第一个集合里面的第二个集合的相关元素给剔除掉？</p>
<blockquote>
<blockquote>
<blockquote>
<p>{1,2,3,4,5,6} - {3, 4}<br>{1, 2, 5, 6}<br>不是减号，而是求两个集合的差值</p>
</blockquote>
</blockquote>
</blockquote>
<p>{1，2，3，4，5，6} {3，4}<br>找两个集合所共有的元素？</p>
<blockquote>
<blockquote>
<blockquote>
<p>{1,2,3,4,5,6} &amp; {3, 4}<br>{3, 4}<br>交集-数学概念</p>
</blockquote>
</blockquote>
</blockquote>
<p>{1，2，3，4，5，6} {3，4，7} 合并集合 不能出现重复元素</p>
<blockquote>
<blockquote>
<blockquote>
<p>{1,2,3,4,5,6} | {3, 4, 7}<br>{1, 2, 3, 4, 5, 6, 7}<br>合集 并集</p>
</blockquote>
</blockquote>
</blockquote>
<ul>
<li>&amp; |  集合的特色</li>
</ul>
<p>如何定义一个空的集合？</p>
<blockquote>
<blockquote>
<blockquote>
<p>type({})</p>
<p><class 'dict'=""><br>set()<br>set()<br>type(set())</class></p>
<class 'set'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>set() 这才是定义空的集合的方法</p>
<blockquote>
<blockquote>
<blockquote>
<p>len(set())<br>0</p>
</blockquote>
</blockquote>
</blockquote>
<p>4-6 dict 字典 (14:51)</p>
<p>字典 dict</p>
<p>key value</p>
<p>通过key关键字，找到value值</p>
<p>一个字典是可以由很多个key和value值来组成的，所以字典也是一个集合类型<br>但是字典不是序列，更像是一个set,字典也是无序的</p>
<p>定义字典：<br>{}<br>{key1:value1,key2:value2…}</p>
<p>字典和集合最大的区别：<br>每个元素定义的方式不同，集合只有一个value值没有key，字典除了value值还有key值，key和value之间用冒号来分隔开</p>
<blockquote>
<blockquote>
<blockquote>
<p>type({1:1, 2:2, 3:3})</p>
<class 'dict'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>有意义的字典，什么情况下适合用字典？</p>
<p>字母和技能之间的关系：<br>{‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}</p>
<blockquote>
<blockquote>
<blockquote>
<p>type({‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’})</p>
<class 'dict'="">

<p>{‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}[0]<br>Traceback (most recent call last):<br>  File “<pyshell#64>“, line 1, in <module><br>    {‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}[0]<br>KeyError: 0</module></pyshell#64></p>
</class></blockquote>
</blockquote>
</blockquote>
<p>下标序号访问是不可以的<br>因为字典也是无序的</p>
<p>字典访问方式：<br>通过key 得到/访问 value</p>
<blockquote>
<blockquote>
<blockquote>
<p>{‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}[‘Q’]<br>‘降龙十八掌’</p>
</blockquote>
</blockquote>
</blockquote>
<p>字典存在相同的key</p>
<blockquote>
<blockquote>
<blockquote>
<p>{‘Q’:’降龙十八掌’, ‘Q’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}[‘Q’]<br>‘吸星大法’<br>{‘Q’:’降龙十八掌’, ‘Q’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}<br>{‘Q’: ‘吸星大法’, ‘E’: ‘蹬鼻子上眼’, ‘R’: ‘轻功’}<br>第一个Q已经不在字典里了</p>
</blockquote>
</blockquote>
</blockquote>
<p>字典的特点：字典里是不能有重复的key</p>
<p>字典的key和value只能是字符串？<br>1和’1‘是相同的key吗？</p>
<blockquote>
<blockquote>
<blockquote>
<p>{‘1’:’降龙十八掌’, 1:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}<br>{‘1’: ‘降龙十八掌’, 1: ‘吸星大法’, ‘E’: ‘蹬鼻子上眼’, ‘R’: ‘轻功’}</p>
</blockquote>
</blockquote>
</blockquote>
<p>字典的键不一定非得是字符串，还可以是数字<br>数字的1和字符串的1会被识别为两个不同的key</p>
<p>value数据类型：<br>可以取python里面任意的一种数据类型，包括但不限于str int float list set dict(甚至可以是dict)</p>
<blockquote>
<blockquote>
<blockquote>
<p>type({‘1’:’降龙十八掌’, 1:’吸星大法’, ‘E’:{1:1}, ‘R’:’轻功’})</p>
<class 'dict'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>字典的value在python中几乎没有任何限制</p>
<p>key数据类型：<br>但是key不能是任意的类型<br>key必须遵循的原则：key必须是不可变的类型  int str</p>
<blockquote>
<blockquote>
<blockquote>
<p>{[1,2]:’降龙十八掌’, 1:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}<br>Traceback (most recent call last):<br>  File “<pyshell#71>“, line 1, in <module><br>    {[1,2]:’降龙十八掌’, 1:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}<br>TypeError: unhashable type: ‘list’<br>{(1,2):’降龙十八掌’, 1:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}<br>{(1, 2): ‘降龙十八掌’, 1: ‘吸星大法’, ‘E’: ‘蹬鼻子上眼’, ‘R’: ‘轻功’}</module></pyshell#71></p>
<p>列表不行 元组可以</p>
</blockquote>
</blockquote>
</blockquote>
<p>思考：空的字典如何定义？<br>我的：</p>
<blockquote>
<blockquote>
<blockquote>
<p>{}<br>{}<br>type({})</p>
<class 'dict'="">

</class></blockquote>
</blockquote>
</blockquote>
<p>bingo</p>
<p>4-7 思维导图总结基本数据类型 (05:06)</p>
<p>字符串和元组是不可变的类型 但是列表是可变的</p>
<p>平时多看看这篇</p>
<p>第5章 变量与运算符</p>
<p>5-1 什么是变量 (09:49)</p>
<p>5-2 变量的命名规则 (11:01)<br>5-3 值类型与引用类型 (15:40)<br>5-4 列表的可变与元组的不可变 (09:28)<br>5-5 运算符号 (07:51)<br>5-6 赋值运算符 (07:40)<br>5-7 比较运算符 (05:58)<br>5-8 不只是数字才能做比较运算_ (08:39)<br>5-9 逻辑运算符 (19:28)<br>5-10 成员运算符 (06:54)<br>5-11 身份运算符 (06:54)<br>5-12 如何判断变量的值、身份与类型 (10:31)<br>5-13 位运算符 (07:44)</p>
<p>第6章 分支、循环、条件与枚举</p>
<p>6-1 什么是表达式 (07:28)<br>6-2 表达式的优先级 (12:38)<br>6-3 表达式优先级练习 (06:44)<br>6-4 在文本文件中编写Python代码 (09:33)<br>6-5 熟悉VSCode开发环境与Python插件安装 (16:37)<br>6-6 流程控制语句之条件控制一 (15:01)<br>6-7 流程控制语句之条件控制 二 (07:24)<br>6-8 常量与Pylint的规范 (17:44)<br>6-9 流程控制语句之条件控制 三 snippet、嵌套分支、代码块的概念 (18:11)<br>6-10 流程控制语句之条件控制 四 elif的优点 (10:54)<br>6-11 思考题解答与改变定势思维 (05:56)</p>
<p>第7章 包、模块、函数与变量作用域</p>
<p>7-1 while循环与使用场景 (09:46)<br>7-2 for与for-else循环 (12:55)<br>7-3 for 与 range (09:32)<br>7-4 新篇章导言 (09:00)<br>7-5 Python工程的组织结构：包、模块儿、类 (07:01)<br>7-6 Python包与模块的名字 (05:17)<br>7-7 import导入模块 (11:05)<br>7-8 from import 导入变量 (08:11)<br>7-9 <strong>init</strong>.py 的用法 (20:34)<br>7-10 包与模块的几个常见错误_ (11:33)<br>7-11 模块内置变量 (15:08)<br>7-12 入口文件和普通模块内置变量的区别 (14:01)<br>7-13 <strong>name</strong>的经典应用 (13:29)<br>7-14 相对导入和绝对导入 一 (18:49)<br>7-15 相对导入和绝对导入 二 (07:37)</p>
<p>第8章 Python函数</p>
<p>8-1 认识函数 (12:07)<br>8-2 函数的定义及运行特点 (16:25)<br>8-3 如何让函数返回多个结果 (12:41)<br>8-4 序列解包与链式赋值 (06:05)<br>8-5 必须参数与关键字参数 (09:26)<br>8-6 默认参数 (17:22)<br>8-7 可变参数 (15:33)<br>8-8 关键字可变参数 (14:00)<br>8-9 变量作用域 (14:06)<br>8-10 作用域链 (04:58)<br>8-11 global关键字 (07:07)<br>8-12 划算还是不划算 (15:27)</p>
<p>第9章 高级部分：面向对象</p>
<p>9-1 类的定义 (17:10)</p>
<p>如何构建一个类：</p>
<p>面向对象两个核心：类 对象</p>
<p>什么是类 什么是对象 他们之间的关系</p>
<p>python使用class关键字来定义一个类</p>
<p>类命名规则和变量是不一样的：<br>1.变量最好小写，类建议第一个字母是要大写；<br>2.变量，两个单词之间使用下划线来进行连接；类，两个单词的首字母都使用大写，如StudentHomework,而不是通过下划线来连接。<br>3.类括号里传的参数和函数里的括号的参数是不一样的</p>
<p>冒号后开始类的类体的编写</p>
<p>类的内部首先可以定义变量</p>
<p>类的内部可以做哪些事情？</p>
<ol>
<li><p>定义若干个变量；<br>class Student():<br> name = ‘’<br> age = 0</p>
</li>
<li><p>定义函数<br>class Student():<br> name = ‘’<br> age = 0</p>
<p> def print_file():</p>
<pre><code>pass
</code></pre></li>
</ol>
<p>类定义完后，如何使用这样一个类？<br>如何调用类里面的函数？<br>要使用类，必须把类实例化<br>实例化的方式，用一个变量来接受实例化的结果</p>
<p>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def print_file():
    pass
</code></pre><p>student = Student()<br>(其他语言需要使用new关键字来实例化一个类)<br>python直接使用类名加括号来完成实例化的过程</p>
<p>student = Student()<br>student.print_file()<br>就可以调用类下面的方法</p>
<p>方法而不是函数</p>
<p>函数和方法有什么区别呢？</p>
<p>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def print_file():
    print(&apos;name:&apos; + name)
    print(&apos;age:&apos; + str(age))
</code></pre><p>student = Student()<br>student.print_file()</p>
<p>python xx.py</p>
<p>Traceback (most recent call last):<br>  File “student.py”, line 14, in <module><br>    student.print_file()<br>TypeError: print_file() takes 0 positional arguments but 1 was given</module></p>
<p>报错了<br>不需要传入参数但是却又一个参数传入了</p>
<p>类里编写函数和普通函数是有区别的，必须在参数列表强制传入一个固定的参数self</p>
<p>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def print_file(self):
    print(&apos;name:&apos; + name)
    print(&apos;age:&apos; + str(age))
</code></pre><p>student = Student()<br>student.print_file()</p>
<p>报错：<br>Traceback (most recent call last):<br>  File “student.py”, line 14, in <module><br>    student.print_file()<br>  File “student.py”, line 10, in print_file<br>    print(‘name:’ + name)<br>NameError: name ‘name’ is not defined<br>之前函数内部直接引用全局变量是没有问题的</module></p>
<p>如何正确引入类下面定义的变量？<br>需要使用self关键字<br>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def print_file(self):
    print(&apos;name:&apos; + self.name)
    print(&apos;age:&apos; + str(self.age))
</code></pre><p>student = Student()<br>student.print_file()</p>
<p>name:<br>age:0</p>
<p>此时没有问题，正确的打印出了name和age</p>
<p>总结：</p>
<p>使用类把变量和函数封装起来了<br>类没有什么神奇的，类的最基本的概念就是封装一系列的变量和函数<br>类的最基本的作用就是封装代码</p>
<p>类最基本的作用： 封装</p>
<p>不同的变量会被封装在不同的类里面</p>
<p>类下面的函数就是方法，一定要接受一个self的参数<br>其次，类下的方法使用类下定义的变量，需要通过self.这个操作符来引用的，直接使用变量是会报错的</p>
<p>初学python 初学编程 容易犯的错：<br>函数的调用放在类里面去执行<br>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def print_file(self):
    print(&apos;name:&apos; + self.name)
    print(&apos;age:&apos; + str(self.age))

print_file()
</code></pre><p>报错：<br>Traceback (most recent call last):<br>  File “student.py”, line 6, in <module><br>    class Student():<br>  File “student.py”, line 14, in Student<br>    print_file()<br>TypeError: print_file() missing 1 required positional argument: ‘self’</module></p>
<p>类的最基本的原则：<br>类只负责去定义或者刻画一些东西 描述一些东西，定义一些行为，但是他不会去负责执行代码</p>
<p>运行或调用类，要放在类的外部</p>
<p>类最基本的作用就是封装，如果在类内部调用函数的话，就和模块没什么区别了</p>
<p>类的实例化和类的方法调用写在和类同一个模块下面<br>做项目的时候，不推荐在一个模块下面，又定义类，又去完成类的实例化和类的方法调用<br>建议：定义类的模块只写类的定义；类的实例化和类方法的调用放到另一个模块里</p>
<p>9-2 浅谈函数与方法的区别 (05:38)</p>
<p>如何在另一个模块使用类？<br>from student import Student</p>
<p>student = Student()<br>student.print_file()</p>
<p>如果不这样做，会让你的代码的结构变得很松散</p>
<p>方法和函数的区别？<br>现在，方法和函数没有绝对的区别<br>很多时候在模糊方法和函数的区别</p>
<p>C C++  函数<br>Java C# 方法</p>
<p>方法 设计层面上的一个称谓<br>方法更多是面向对象里面的一个概念<br>而面向对象最重要的是：面向对象更加关注的是一个设计  设计代码的结构 设计你的封装 </p>
<p>函数：程序运行、过程式的一种称谓<br>面向过程的一个概念  没有所谓的设计层面的意义在里面</p>
<p>类里面的函数 称为方法</p>
<p>如果只是把函数定义在模块里面，不要称作方法，还是成为函数</p>
<p>类下面定义的变量</p>
<p>模块里面定义的变量，称为变量<br>类下面定义的变量，python更多的是称为数据成员<br>数据成员在于体现类的封装性<br>每个变量都可以认为是一个数据，这样的数据用来描述类的特征</p>
<p>没有必要特别区分函数和方法 变量和数据成员</p>
<p>9-3 类与对象。 (10:21)</p>
<p>类和对象到底是什么，他们之间的关系？</p>
<p>student = Student()<br>类和对象通过实例化关联起来的</p>
<p>什么是类？</p>
<p>类是显示世界或思维世界中的实体在计算机中的反映。<br>它将数据以及这些数据上的操作封装在一起</p>
<p>数据是类用来刻画某些事物的一些基本特性</p>
<p>除了数据是不够的，还要有一些行为</p>
<p>数据成员刻画特征，方法描述行为</p>
<p>类： 行为与特征</p>
<p>类的设计是一种艺术</p>
<p>print_file强行和student关联在一起并不合适</p>
<p>把握行为的主体是什么的原则</p>
<p>行为没有找对主体，是很多同学在设计面向对象的时候，最容易忽略的一个问题</p>
<p>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><h1 id="class-Printer"><a href="#class-Printer" class="headerlink" title="class Printer():"></a>class Printer():</h1><p>#</p>
<h1 id="def-print-file-self"><a href="#def-print-file-self" class="headerlink" title="def print_file(self):"></a>def print_file(self):</h1><h1 id="print-‘name-’-self-name"><a href="#print-‘name-’-self-name" class="headerlink" title="print(‘name:’ + self.name)"></a>print(‘name:’ + self.name)</h1><h1 id="print-‘age-’-str-self-age"><a href="#print-‘age-’-str-self-age" class="headerlink" title="print(‘age:’ + str(self.age))"></a>print(‘age:’ + str(self.age))</h1><p>类是一个抽象的概念<br>类只是一类事物的总称，它并不具体</p>
<p>如何表示一个具体的学生？<br>对象表示具体的概念</p>
<p>类实例化之后就变成一个具体的对象</p>
<p>实例化的时候，需要向类里面传递类的一些特征和具体值，然后才能得到一个具体的对象<br>如果没有具体的数据，就不是一个对象。因为不具体，还是非常抽象</p>
<p>类是模版，通过模版可以做成各种各样的对象<br>对象具有共同的特性</p>
<p>类可以通过传入各种各样的特征的具体值来产生各种各样不同的对象</p>
<p>9-4 构造函数 (18:45)</p>
<p>实例化 实例化的意义</p>
<p>什么叫不同的对象？ 特征不相同</p>
<p>如何让类的模版生成不同的对象呢？<br>就是实例话要做的事情</p>
<p>student1 = Student()<br>student2 = Student()<br>student3 = Student()<br>这三个对象是一样的<br>因为他们的name和age是相同的<br>特征是相同的</p>
<p>不过不代表他们在计算机就是同一个对象</p>
<p>id()函数 查看他们的内存地址</p>
<p>print(id(student1))<br>print(id(student2))<br>print(id(student3))</p>
<p>2387536817288<br>2387537798816<br>2387537679864</p>
<p>三个对象的内存地址是完全不相同的</p>
<p>实例化过程中如何让对象不相同？</p>
<p>处理函数的过程会定义形参，然后传递不同的实参到函数内部，由此让函数返回不同的结果</p>
<p>实例化，也需要向类传递一系列的参数，让类生成的对象变得不相同</p>
<p>类的内部定义一个特殊的函数：<br>    def <strong>init</strong>(self):<br>        pass</p>
<p>这个特殊的函数，叫构造函数<br>构造函数的概念不是python所独有的，也是很多变成语言通用的概念</p>
<p>构造函数 构造方法</p>
<p>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def __init__(self):
    print(&apos;student&apos;)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student()<br>student1.<strong>init</strong>()</p>
<p>student<br>student</p>
<p>奇怪的现象，连续打印了两个student<br>但是我们只调用了一次构造函数</p>
<ol>
<li>构造函数的调用是自动进行的，实例化的时候python会自动调用构造函数；不需要显式调用；</li>
<li>能不能主动显式调用<strong>init</strong>()？ 可以，但是实际变成很少去主动显式调用<strong>init</strong>()。因为实例化的过程，构造函数已经调用过一次了，没必要再显式调用<strong>init</strong>()</li>
</ol>
<p>student1 = Student()<br>a = student1.<strong>init</strong>()<br>print(a)<br>print(type(a))</p>
<p>student<br>student<br>None</p>
<class 'nonetype'="">

<p>返回结果是一个空，<br>    def <strong>init</strong>(self):<br>        print(‘student’)<br>构造函数没有return任何值，相当于return None</p>
<pre><code>def __init__(self):
    print(&apos;student&apos;)
    return None


def __init__(self):
    print(&apos;student&apos;)
    return None
</code></pre><p>不会报错，但是</p>
<pre><code>def __init__(self):
    print(&apos;student&apos;)
    return &apos;hey&apos;
</code></pre><p>Traceback (most recent call last):<br>  File “student.py”, line 17, in <module><br>    student1 = Student()<br>TypeError: <strong>init</strong>() should return None, not ‘str’</module></p>
<p>不能返回字符串</p>
<p>init和普通函数的区别：<br>构造函数不能强行返回除了None之外的类型的值，python要求对于构造函数，只能返回None</p>
<p>养成探索和思考的精神和思维</p>
<p>不要用构造函数来返回东西，用普通函数</p>
<p>构造函数的作用；<br>模版生成不同的对象</p>
<p>通过在构造函数这个特殊函数内增加参数来<br>然后实例化的时候传入参数的值来让对象变得不同</p>
<p>注意实例化的时候传入的参数必须和构造函数的参数一致，不传的话会报错：<br>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    print(&apos;student&apos;)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student()</p>
<p>Traceback (most recent call last):<br>  File “student.py”, line 16, in <module><br>    student1 = Student()<br>TypeError: <strong>init</strong>() missing 2 required positional arguments: ‘name’ and ‘age’</module></p>
<p>要求必须传入参数<br>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    print(&apos;student&apos;)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)</p>
<p>student</p>
<p>student1 = Student(‘nana’, 18) 这种写法等同于直接点用构造函数</p>
<p>函数内部处理传入的参数</p>
<p>在构造函数的内部，我们通常做的最多的一件事情就是初始化类的特征值，初始化对象的特征</p>
<pre><code>name = &apos;&apos;
age = 0
</code></pre><p>没有意义的初始值</p>
<p>构造函数里把特征值付给初始值，改变变量的初始值<br>从而形成对象的特征</p>
<p>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    name = name
    age = age
    print(&apos;student&apos;)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(student1.name)</p>
<p>student1.name 访问对象的变量或者方法都是通过.点号来操作的</p>
<p>php例外： student1-&gt;name</p>
<p>终端结果：<br>student</p>
<p>什么都没有打印出来<br>说明构造函数里的赋值，并没有改变name变量的取值</p>
<p>9-5 区别模块变量与类中的变量 (04:59)</p>
<p>回顾 模块的全局变量 局部变量</p>
<p>c = 50</p>
<p>def add(x, y):<br>    c = x + y<br>    print(c)</p>
<h1 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h1><p>add(1,2)<br>print(c)</p>
<p>打印结果 3 50<br>3 打印局部变量<br>50 打印全局变量</p>
<p>如果函数定义了一个和全局变量同名的变量的话，python里的局部变量并不会覆盖全局变量  注意！！！</p>
<p>局部变量的作用与仅仅局限在函数的内部</p>
<p>全局变量的值不会因为局部变量的值而更改</p>
<p>但是类中的变量和模块的变量是不能等同于的<br>类的机制和模块中的全局变量和局部变量的机制是不一样的</p>
<p>打出空值的真正原因：<br>类变量 实例变量</p>
<p>类变量和模块变量的相关行为分别对待</p>
<p>9-6 类变量与实例变量 (13:39)</p>
<p>什么是类变量 实例变量 及 他们的作用<br>类变量是和类相关联的 实例变量是和对象相关联的</p>
<p>student1 = Student(‘nana’, 18)<br>student2 = Student(‘helen’, 19)<br>这两个对象是不一样的<br>不一样在特征值</p>
<p>待 只写代码</p>
<pre><code>self.name = name
self.age = age
</code></pre><p>来保存不同的特征值<br>定义了两个实例变量<br>只和对象相关，和类没有关系<br>。。。。。。</p>
<p>self不能称做是关键字</p>
<p>关键字是固定不变的，但是self是可以变的，比如改成this</p>
<p>类变量和实例变量在语法特性上的不同<br>class Student():<br>    name = ‘hehe’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    # print(&apos;student&apos;)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>student2 = Student(‘helen’, 19)<br>print(student1.name)<br>print(student2.name)<br>print(Student.name)</p>
<p>nana<br>helen<br>hehe</p>
<p>对象的name和类的name不是一个东西</p>
<p>类变量的定义有没有意义？</p>
<pre><code>sum = 0
name = &apos;&apos;
age = 0
</code></pre><p>做对比<br>类变量和具体的对象无关</p>
<p>9-7 类与对象的变量查找顺序 (12:51)</p>
<p>类变量和实例变量的特性</p>
<p>动态语言最大的缺点就是坑挺多</p>
<p>class Student():<br>    name = ‘’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    name = name
    age = age

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(student1.name)</p>
<p>打印出来是空字符串</p>
<p>class Student():<br>    name = ‘xixi’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    name = name
    age = age

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(student1.name)<br>打印出来的是 xixi</p>
<p>为什么想打印的是实例变量，最终打印出来的却是类变量？<br>打印类变量的正确方法：Student.name</p>
<p>对象隐藏的变量<strong>dict</strong> python内置的变量</p>
<p>class Student():<br>    name = ‘xixi’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    name = name
    age = age

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(student1.<strong>dict</strong>)</p>
<p>打印：{}<br>空的字典</p>
<p><strong>dict</strong>是个字典，保存着当前对象所有的相关变量</p>
<p>class Student():<br>    name = ‘xixi’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(student1.<strong>dict</strong>)</p>
<p>打印：{‘name’: ‘nana’, ‘age’: 18}</p>
<p>python寻找相关变量的机制：<br>实例变量找不到 会去类变量里面找<br>如果在类里面没有找到，会去父类里寻找</p>
<p>还可以打印类的<strong>dict</strong></p>
<p>class Student():<br>    name = ‘xixi’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(student1.<strong>dict</strong>)<br>print(Student.<strong>dict</strong>)</p>
<p>{‘name’: ‘nana’, ‘age’: 18}<br>{‘<strong>module</strong>‘: ‘<strong>main</strong>‘, ‘sum’: 0, ‘name’: ‘xixi’, ‘age’: 0, ‘<strong>init</strong>‘: <function student.__init__="" at="" 0x00000206f21b07b8="">, ‘do_homework’: <function student.do_homework="" at="" 0x00000206f2439ea0="">, ‘<strong>dict</strong>‘: <a ttribute="" '__dict__'="" of="" 'student'="" objects="">, ‘<strong>weakref</strong>‘: <attribute '__weakref__'="" of="" 'student'="" objects="">, ‘<strong>doc</strong>‘: None}</attribute></a></function></function></p>
<p>sum这样的统计数字是和类绑定在一起的</p>
<p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>思考；<br>class Student():<br>    name = ‘xixi’<br>    age = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    print(age)
    print(name)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)</p>
<p>问：print(age)<br>print(name) 打印的是什么</p>
<p>我：猜想的是类变量 实际终端输出的是<br>18<br>nana<br>实例变量的值<br>？？？？？？</p>
<p>方法里不一定是构造函数里，能不能访问类的变量？</p>
<p>9-8 self与实例方法 (08:01)</p>
<p>实例方法 参数第一个必须是self</p>
<p>类下面的实例方法，默认会有一个python所规定的参数，和我们自定义的参数是不同的</p>
<p>定义实例方法需要传入self，但是调用实例方法的时候，不需要传入self. self是python为我们默认传入的，我们自己不需要为self参数来赋值</p>
<p>self的两个特点：<br>定义实例方法的时候，self必须出现<br>调用实例方法的时候，不需要对self传参</p>
<p>self这个概念在其他编程语言里面也是有的<br>其他语言不需要显式的指定这样的一个参数，python特殊，强制要求必须显式指定<br>很多其他语言是使用this来代替python里面的self</p>
<p>只不过python要求：<br>1.必须显式定义<br>2.不叫this，叫self</p>
<p>self可以不叫self,可以改成任意喜欢的名字</p>
<p>class Student():<br>    sum = 0<br>    name = ‘xixi’<br>    age = 0</p>
<pre><code>def __init__(this, name, age):
    this.name = name
    this.age = age

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(student1.<strong>dict</strong>)</p>
<p>输出：{‘name’: ‘nana’, ‘age’: 18}</p>
<p>总结：通过this一样可以指定这样的一个对象的实例变量，但是python建议使用self这样的实例变量</p>
<p>显胜于隐</p>
<p>self就是当前调用某一个方法的对象</p>
<p>student1.do_homework()<br>此时do_homework()的self指的就是student1</p>
<p>student2.do_homework()<br>self指的就是student2</p>
<p>self只和对象有关，和类没有关系<br>谁调用了这个方法，self就指代的就是谁</p>
<p>self代表的是实例，而不是类<br>self.name = name 就是对这样的一个实例变量在赋值</p>
<p>实例变量  和对象 也就是类生成的实例相关联的变量</p>
<p>实例方法   和对象 也就是类生成的实例相关联的方法，也就是实例可以调用的方法<br>最大特点：第一个参数需要传入self</p>
<p>self可以改成别的，所以self不是关键字</p>
<p>9-9 在实例方法中访问实例变量与类变量 (16:00)</p>
<p>思维导图 理清楚思路和结构</p>
<p>Python类：<br>变量：类变量 实例变量<br>方法：实例方法 后面类方法，静态方法<br>构造函数</p>
<p>这节实践 需要认真听</p>
<p>方法代表类的行为，而变量代表刻画类的特征</p>
<p>方法和变量的关系：<br>方法需要对变量做一系列的运算或者逻辑上的操作，最终改变变量的状态，这是方法最本质的意义<br>方法也可以完全不操作变量 少数</p>
<p>方法操作变量，方法如何访问变量？</p>
<p>实例方法操作实例变量，因为它们都是和对象相关联的<br>self.实例变量 给实例变量赋值 或读取实例变量</p>
<p>实例方法内部可以访问类变量吗？</p>
<p>1.构造方法可以看作特殊的实例方法，调用方式和实例方法不一样，调用构造函数是通过类后面的括号的方式来调用。调用普通的实例方法是通过对象.实例方法的方式如student1.do_homework()的方式来调用的<br>2.它们的意义不一样，实例方法主要用来描述类的行为，构造函数主要用来初始化类的各种特征的</p>
<p>不加self也可以访问实例变量<br>print(self.name)<br>print(name)</p>
<p>但是最好用self.name，经典错误如下：</p>
<p>self.name 和 name 是不等价的</p>
<h1 id="self-name-与-name"><a href="#self-name-与-name" class="headerlink" title="self.name 与 name"></a>self.name 与 name</h1><p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    print(self.name)
    print(name)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)</p>
<p>输出：<br>nana<br>nana</p>
<p>产生了假象</p>
<p>构造函数的形参改为name1</p>
<h1 id="self-name-与-name-1"><a href="#self-name-与-name-1" class="headerlink" title="self.name 与 name"></a>self.name 与 name</h1><p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    print(self.name)
    print(name)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)</p>
<p>输出：<br>此时报错了<br>nana<br>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 99, in <module><br>    student1 = Student(‘nana’, 18)<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 94, in <strong>init</strong><br>    print(name)<br>NameError: name ‘name’ is not defined</module></p>
<p>self.name 读取了对象的实例变量，并且打印出来了<br>name 并不是读取了对象的实例变量，它读取的是形参name</p>
<p>另一个误解：<br><strong>dict</strong>的查找机制</p>
<pre><code>print(self.name)
print(self.__dict__)
</code></pre><p>nana<br>{‘name’: ‘nana’, ‘age’: 18}<br>确实有name的变量存在<br>但是打印print(name) 依然会出错<br>要强调的误区：<br>实例方法内部，想通过一个name去进行<strong>dict</strong>的查找是不可以的，这种查找机制仅仅在通过在类的对象的外部调用的时候是可以的</p>
<p>实例方法如何访问类变量：</p>
<h1 id="实例方法如何访问类变量"><a href="#实例方法如何访问类变量" class="headerlink" title="实例方法如何访问类变量"></a>实例方法如何访问类变量</h1><p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    print(sum)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)</p>
<p>输出；<built-in function="" sum=""><br>把python内置函数sum给打印出来了</built-in></p>
<p>class Student():<br>    sum1 = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    print(sum1)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>sum改成sum1,输出：<br>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 116, in <module><br>    student1 = Student(‘nana’, 18)<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 111, in <strong>init</strong><br>    print(sum1)<br>NameError: name ‘sum1’ is not defined</module></p>
<p>如何在类的外部访问类变量呢？<br>print(Studeng.name) 类名.类变量来访问类变量<br>外部可以这样使用，内部也可以这样使用</p>
<p>class Student():<br>    sum1 = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    print(Student.sum1)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(Student.sum1)</p>
<p>print(Student.sum1)，输出：<br>0<br>0</p>
<p>实例方法访问类变量的第二种方式：<br>class Student():<br>    sum1 = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    # print(Student.sum1)
    print(self.__class__.sum1)

def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)</p>
<p>输出：0</p>
<p>9-10 类方法 (15:40)</p>
<p>为什么会有类方法以及类方法的作用：</p>
<p>如何在方法里操作sum?</p>
<p>self.<strong>class</strong>.sum，这是数字，别忘了str(self.<strong>class</strong>.sum)<br>每当实例化一个对象，sum的基数就会增加1</p>
<p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    # print(Student.sum1)
    self.__class__.sum += 1
    print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum))


def do_homework(self):
    print(&apos;homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>student2 = Student(‘betty’, 17)<br>student3 = Student(‘jessica’, 16)</p>
<p>当前班级学生总数为：1<br>当前班级学生总数为：2<br>当前班级学生总数为：3</p>
<p>类变量和实例变量的区别？ 类变量的作用<br>类变量的正确使用场景是什么</p>
<p>可以放在别的方法，但是要调用那个方法才能生效</p>
<p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    # print(Student.sum1)
    # self.__class__.sum += 1
    # print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum))


def do_homework(self):
    print(&apos;homework&apos;)
    self.__class__.sum += 1
    print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum))
</code></pre><p>student1 = Student(‘nana’, 18)<br>student1.do_homework()<br>student2 = Student(‘betty’, 17)<br>student2.do_homework()<br>student3 = Student(‘jessica’, 16)<br>student3.do_homework()</p>
<p>输出：<br>homework<br>当前班级学生总数为：1<br>homework<br>当前班级学生总数为：2<br>homework<br>当前班级学生总数为：3</p>
<p>类方法专门用来操作类变量的<br>类方法如何定义：</p>
<pre><code>def plus_sum(cls):
    pass
</code></pre><p>这个就是类方法吗？不是的</p>
<pre><code>@classmethod
def plus_sum(cls):
    pass
</code></pre><p>cls就是class的简写，@classmethod是装饰器</p>
<p>类方法的作用是用来操作和类相关的一些变量<br>    @classmethod<br>    def plus_sum(cls):<br>        cls.sum += 1<br>        print(cls.sum)<br>完成了最简单的类方法</p>
<p>类方法如何调用：<br>类方法只和类相关，和对象没什么关系<br>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    # self.__class__.sum += 1
    # print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum))


def do_homework(self):
    print(&apos;homework&apos;)

@classmethod
def plus_sum(cls):
    cls.sum += 1
    print(cls.sum)
</code></pre><p>student1 = Student(‘nana’, 18)<br>Student.plus_sum()<br>student2 = Student(‘nana’, 18)<br>Student.plus_sum()<br>student3 = Student(‘jessica’, 16)<br>Student.plus_sum()</p>
<p>输出：<br>1<br>2<br>3<br>cls可以叫别的名字吗？<br>可以，实例方法可以更改，类方法也可以更改</p>
<pre><code>@classmethod
def plus_sum(self):
    self.sum += 1
    print(self.sum)
</code></pre><p>输出：<br>1<br>2<br>3<br>是一样的</p>
<p>是不是实例方法和self cls没有关系</p>
<p>类方法和实例方法的区别：<br>类与对象的区别<br>实例方法关联的是对象这样一个事物<br>而类方法关联的是类本身</p>
<p>可以在实例方法操作类变量，还要类方法做什么？</p>
<p>self与cls的区别<br>self代表student1 student2 student3等对象<br>cls代表Student这个类</p>
<p>重要！！！<br>可以用对象来调用类方法吗？<br>可以</p>
<p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    self.__class__.sum += 1
    print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum))

def do_homework(self):
    print(&apos;homework&apos;)

@classmethod
def plus_sum(self):
    self.sum += 1
    print(self.sum)
</code></pre><p>student1 = Student(‘nana’, 18)<br>student1.plus_sum()</p>
<p>输出：<br>当前班级学生总数为：1<br>2</p>
<p>但是最好不要。逻辑上说不通</p>
<p>9-11 静态方法 (09:08)</p>
<p>python静态方法应该如何调用？</p>
<pre><code>@staticmethod
def add(x,y):
    pass
</code></pre><p>静态方法和实例方法 类方法有什么不同？</p>
<ol>
<li>最大不同：不需要强制传入self或者cls; 就是一个普通的方法；</li>
<li>一个函数要成为静态方法需要加@staticmethod装饰器</li>
</ol>
<p>如何调用静态方法？<br>对象和类都可以调用静态方法</p>
<p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name1, age):
    self.name = name1
    self.age = age
    self.__class__.sum += 1
    print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum))

def do_homework(self):
    print(&apos;homework&apos;)

@classmethod
def plus_sum(self):
    self.sum += 1
    print(self.sum)

@staticmethod
def add(x, y):
    print(&apos;This is a static method&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>student1.add(1, 2)<br>Student.add(1, 2)</p>
<p>输出：<br>当前班级学生总数为：1<br>This is a static method<br>This is a static method</p>
<p>静态方法内部可以访问类变量吗？<br>可以</p>
<pre><code>@staticmethod
def add(x, y):
    print(Student.sum)
    print(&apos;This is a static method&apos;)
</code></pre><p>输出：<br>1<br>This is a static method<br>1<br>This is a static method</p>
<p>为什么不是1和2？？？</p>
<p>类方法和静态方法可以访问实例变量吗？<br>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    self.__class__.sum += 1
    # print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum))

def do_homework(self):
    print(&apos;homework&apos;)

@classmethod
def plus_sum(self):
    print(self.name)

@staticmethod
def add(x, y):
    print(self.name)
</code></pre><p>student1 = Student(‘nana’, 18)<br>student1.add(1, 2)<br>Student.add(1, 2)<br>student1.plus_sum()<br>Student.plus_sum()</p>
<p>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 216, in <module><br>    student1.add(1, 2)<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 213, in add<br>    print(self.name)<br>NameError: name ‘self’ is not defined<br>会报错</module></p>
<p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    self.__class__.sum += 1
    # print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum))

def do_homework(self):
    print(&apos;homework&apos;)

@classmethod
def plus_sum(self):
    print(name)

@staticmethod
def add(x, y):
    print(name)
</code></pre><p>student1 = Student(‘nana’, 18)<br>student1.add(1, 2)<br>Student.add(1, 2)<br>student1.plus_sum()<br>Student.plus_sum()</p>
<p>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 216, in <module><br>    student1.add(1, 2)<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 213, in add<br>    print(name)<br>NameError: name ‘name’ is not defined<br>还是会报错</module></p>
<p>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 218, in <module><br>    student1.plus_sum()<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 209, in plus_sum<br>    print(self.name)<br>AttributeError: type object ‘Student’ has no attribute ‘name’<br>报错</module></p>
<p>静态方法作用：<br>能用静态方法的地方，都可以用静态方法来代替<br>类方法更方便，而且静态方法还需要写类的全称才能访问类变量<br>建议静态方法不要经常使用，而且静态方法和面向对象的关联性非常弱</p>
<p>当一个函数和类和对象没有什么关联的时候，可以使用静态方法</p>
<p>Python的静态方法和其他语言的静态方法是不太一样的<br>C#的静态方法更像python里的类方法</p>
<p>思维导图总结</p>
<p>9-12 成员可见性：公开和私有 (23:12)</p>
<p>并非python所独有，绝大多数面向对象的语言都有</p>
<p>成员： 变量和方法</p>
<p>类是有内外之分的</p>
<p>类的外部 类的内部：</p>
<p>student1 = Student(‘nana’, 18)<br>student1.do_homework()<br>类的外部调用和访问类的方法</p>
<pre><code>def do_homework(self):
    self.do_english_homework()
    print(&apos;homework&apos;)

def do_english_homework(self):
    print(&apos;do english homework&apos;)
</code></pre><p>在类的内部调用</p>
<p>不仅方法有内外调用的区别，类变量和实例变量也有内外调用的区别。</p>
<p>类的最基本作用：封装代码</p>
<p>类的不安全</p>
<p>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name, age, score):
    self.name = name
    self.age = age
    self.score = score
    self.__class__.sum += 1

def do_homework(self):
    self.do_english_homework()
    print(&apos;homework&apos;)

def do_english_homework(self):
    print(&apos;do english homework&apos;)

@classmethod
def plus_sum(self):
    pass

@staticmethod
def add(x, y):
    pass
</code></pre><p>student1 = Student(‘nana’, 18)</p>
<h1 id="student1-add-1-2"><a href="#student1-add-1-2" class="headerlink" title="student1.add(1, 2)"></a>student1.add(1, 2)</h1><h1 id="Student-add-1-2"><a href="#Student-add-1-2" class="headerlink" title="Student.add(1, 2)"></a>Student.add(1, 2)</h1><p>student1.plus_sum()<br>Student.plus_sum()<br>student1.score = -1</p>
<p>student1.score = -1<br>造成类的内部数据的不安全<br>只应该由类的内部的方法来操作类内部的变量<br>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    self.score = 0
    self.__class__.sum += 1

def marking(self, score):
    self.score = score
    print(self.name + &apos;同学本次开始分数为:&apos; + str(self.score))

def do_homework(self):
    self.do_english_homework()
    print(&apos;homework&apos;)

def do_english_homework(self):
    print(&apos;do english homework&apos;)

@classmethod
def plus_sum(self):
    pass

@staticmethod
def add(x, y):
    pass
</code></pre><p>student1 = Student(‘nana’, 18)<br>student1.marking(90)</p>
<p>输出：<br>nana同学本次开始分数为:90</p>
<p>student1.marking(-1)<br>student1.score = -1</p>
<p>通过方法的话，可以判断的<br>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    self.score = 0
    self.__class__.sum += 1

def marking(self, score):
    if score &lt; 0:
        # score = 0
            return &apos;不能够给别人打负分&apos;
    self.score = score
    print(self.name + &apos;同学本次开始分数为:&apos; + str(self.score))

def do_homework(self):
    self.do_english_homework()
    print(&apos;homework&apos;)

def do_english_homework(self):
    print(&apos;do english homework&apos;)

@classmethod
def plus_sum(self):
    pass

@staticmethod
def add(x, y):
    pass
</code></pre><p>student1 = Student(‘nana’, 18)<br>result = student1.marking(-1)</p>
<h1 id="student1-score-1"><a href="#student1-score-1" class="headerlink" title="student1.score = -1"></a>student1.score = -1</h1><p>print(result)</p>
<p>输出：不能够给别人打负分</p>
<p>编程提倡的规范：<br>一个类下面的数据变量是类非常重要的特征数据<br>如果要修改类的特征值，不应该直接通过访问变量的方式来改变变量的状态，<br>正确：所有对于类变量的更改都应该通过方法来完成，几乎所有语言都是这样来提倡的</p>
<p>在类的外部依然可以对类的变量进行赋值，解决？<br>涉及成员的可见性问题</p>
<p>student1.score = -1<br>成员可见性是公开的 public  类的外部可以直接访问 赋值或者读取</p>
<p>私有 private  类的外部无法直接访问 赋值或者读取</p>
<p>如何变成私有的？</p>
<p>其他语言，成员的可见性是非常明显的标记</p>
<p>python如何决定成员的可见性？</p>
<p>如果变量或者方法开头没有双下划线，都会认为变量或者方法是公开的</p>
<p>变量或者方法开头加了双下划线，就会认为变量或者方法是私有的</p>
<pre><code>def __marking(self, score):
    if score &lt; 0:
        # score = 0
            return &apos;不能够给别人打负分&apos;
    self.score = score
    print(self.name + &apos;同学本次开始分数为:&apos; + str(self.score))
</code></pre><p>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 255, in <module><br>    result = student1.<strong>marking(-1)<br>AttributeError: ‘Student’ object has no attribute ‘</strong>marking’<br>因为它已经变成了私有方法</module></p>
<p>为什么构造函数的前面有双下划线，我们依然可以在外部调用？<br>构造函数属于python特有的函数，确实是可以从外部访问的<br><strong>init</strong>前面有双下划线，后面也有双下划线。这样的命名方式，python不会认为是私有的</p>
<pre><code>def __marking__(self, score):
    if score &lt; 0:
        # score = 0
            return &apos;不能够给别人打负分&apos;
    self.score = score
    print(self.name + &apos;同学本次开始分数为:&apos; + str(self.score))
</code></pre><p>输出：不能够给别人打负分</p>
<p>如果想让变量或者方法变成私有的，只需在前面加双下划线，不要在后面也加双下划线</p>
<p><strong>init</strong>  这种命名风格是python内置变量的命名庚哥</p>
<p>score加双下划线：<br>class Student():<br>    sum = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    self.__score = 0
    self.__class__.sum += 1

def __marking__(self, score):
    if score &lt; 0:
        # score = 0
            return &apos;不能够给别人打负分&apos;
    self.__score = score
    print(self.name + &apos;同学本次开始分数为:&apos; + str(self.__score))

def do_homework(self):
    self.do_english_homework()
    print(&apos;homework&apos;)

def do_english_homework(self):
    print(&apos;do english homework&apos;)

@classmethod
def plus_sum(self):
    pass

@staticmethod
def add(x, y):
    pass
</code></pre><p>student1 = Student(‘nana’, 18)<br>result = student1.<strong>marking</strong>(-1)<br>student1.__score = -1<br>print(result)</p>
<p>输出：不能够给别人打负分</p>
<p>并没有报错，为什么__score没有报错？</p>
<p>9-13 没有什么是不能访问 (09:21)</p>
<p>student1.<strong>score = -1<br>print(student1.</strong>score)<br>输出：<br>不能够给别人打负分<br>-1</p>
<p>赋值和读取都成功了</p>
<p>student1.__score = -1，实际上是给student1新添加了一个实例变量<br>python是可以通过.的方式来新添加一个新的实例变量</p>
<p>student1 = Student(‘nana’, 18)<br>student2 = Student(‘nana’, 18)</p>
<p>student1.<strong>score = -1<br>print(student1.</strong>score)</p>
<p>print(student2.__score)</p>
<p>输出：<br>-1<br>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 266, in <module><br>    print(student2.<strong>score)<br>AttributeError: ‘Student’ object has no attribute ‘</strong>score’</module></p>
<p>student1.<strong>score = -1  并不是类里面定义的</strong>score</p>
<p>python动态语言的特性</p>
<p>student1.<strong>score = -1<br>print(student1.</strong>dict<strong>)<br>输出：<br>{‘name’: ‘nana’, ‘age’: 18, ‘_Student</strong>score’: 0, ‘__score’: -1}<br>打印dict的内置变量</p>
<p>‘_Student<strong>score’就是我们原来定义的私有变量<br>双下划线</strong>score<br>python存储私有变量的时候会做一个更改</p>
<p>‘__score’是我们在外面动态添加的</p>
<p>为什么python访问私有变量或者方法的时候会报错呢？<br>‘_Student__score’  因为python已经把私有变量或者方法的名字给改了</p>
<p>print(student2.<strong>dict</strong>)</p>
<p>{‘name’: ‘nana’, ‘age’: 18, ‘_Student<strong>score’: 0}<br>没有’</strong>score’</p>
<p>python对私有变量的保护机制</p>
<p>所以不能通过动态的方式来访问私有变量，否则还是能访问到</p>
<p>严格意义上来将，python是没有私有变量的<br>print(student2._Student<strong>score)<br>输出；0<br>可以通过这种方式来访问私有变量：_Student</strong>score<br>间接读取私有变量</p>
<p>9-14 继承. (24:55)</p>
<p>面向对象三大特性：继承性 封装性 多态性<br>最难讲清楚 变化最多的反而是封装性<br>继承性 多态性 实实在在的语法问题</p>
<p>封装性抽象程度非常高</p>
<p>继承性作用：<br>类由两大块组成：类的特征和类的行为</p>
<p>1.避免我们定义重复的方法和重复的变量；</p>
<p>学生本质是一个人 学生和人构成继承关系</p>
<p>Python虽然可以在一个模块写多个类，但是建议一个模块只写一个类</p>
<p>一个文件定义一个类，结构上也是比较清晰的</p>
<p>from people import People<br>class Student(People):<br>    sum = 0</p>
<pre><code>def __init__(self, name, age):
    self.name = name
    self.age = age
    self.__score = 0
    self.__class__.sum += 1

def do_homework(self):
    print(&apos;english homework&apos;)
</code></pre><p>类括号里的空格是用来填写类的父类的</p>
<p>People是Student的父类<br>而Student是People的子类</p>
<p>什么是有意义的继承？</p>
<p>from human import Human<br>class Student(Human):</p>
<pre><code># sum = 0

# def __init__(self, name, age):
#     self.name = name
#     self.age = age
#     self.__score = 0
#     self.__class__.sum += 1

def do_homework(self):
    print(&apos;english homework&apos;)
</code></pre><p>student1 = Student()<br>print(student1.sum)<br>print(Student.sum)<br>print(student1.name)<br>print(student1.age)</p>
<p>输出；<br>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 286, in <module><br>    student1 = Student()<br>TypeError: <strong>init</strong>() missing 2 required positional arguments: ‘name’ and ‘age’<br>构造函数的继承性</module></p>
<p>print(Student.sum)<br>输出：0</p>
<p>TypeError: <strong>init</strong>() missing 2 required positional arguments: ‘name’ and ‘age’<br>实例化类的时候还是需要传入name和age</p>
<p>父类需要传入name和age，所以实例化子类的时候也需要传入name和age</p>
<p>from human import Human<br>class Student(Human):</p>
<pre><code># sum = 0

# def __init__(self, name, age):
#     self.name = name
#     self.age = age
#     self.__score = 0
#     self.__class__.sum += 1

def do_homework(self):
    print(&apos;english homework&apos;)
</code></pre><p>student1 = Student(‘nana’, 18)<br>print(student1.sum)<br>print(Student.sum)<br>print(student1.name)<br>print(student1.age)</p>
<p>0<br>0<br>nana<br>18</p>
<p>类变量和实例变量同样可以被子类继承</p>
<p>student1.get_name()<br>输出：nana</p>
<p>子类也能继承父类的方法</p>
<p>python可以多继承  一个子类可以继承多个父类</p>
<p>一个子类只能有一个父类 单继承</p>
<p>单继承可以让整个的继承链条变得清晰</p>
<p>子类需要有自己的特征变量</p>
<p>子类调用父类的构造函数；<br>class Student(Human):</p>
<pre><code># sum = 0

def __init__(self, school, name, age):
    self.school = school
    Human.__init__(name, age)
</code></pre><p>显式调用父类的构造函数</p>
<p>from human import Human<br>class Student(Human):</p>
<pre><code># sum = 0

def __init__(self, school, name, age):
    self.school = school
    Human.__init__(name, age)
    # self.__score = 0
    # self.__class__.sum += 1

def do_homework(self):
    print(&apos;english homework&apos;)
</code></pre><p>student1 = Student(‘牛逼小学’,’nana’, 18)</p>
<h1 id="print-student1-sum"><a href="#print-student1-sum" class="headerlink" title="print(student1.sum)"></a>print(student1.sum)</h1><h1 id="print-Student-sum"><a href="#print-Student-sum" class="headerlink" title="print(Student.sum)"></a>print(Student.sum)</h1><p>print(student1.school)<br>print(student1.name)<br>print(student1.age)</p>
<p>输出：<br>Traceback (most recent call last):<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 286, in <module><br>    student1 = Student(‘牛逼小学’,’nana’, 18)<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 278, in <strong>init</strong><br>    Human.<strong>init</strong>(name, age)<br>TypeError: <strong>init</strong>() missing 1 required positional argument: ‘age’</module></p>
<pre><code>Human.__init__(self,name, age)
</code></pre><p>输出：<br>牛逼小学<br>nana<br>18</p>
<p>为什么要传self?</p>
<p>9-15 子类方法调用父类方法：super关键字 (15:17)</p>
<p>Human.<strong>init</strong>(self,name, age)<br>类去调用实例方法是说不通的<br>但是python不限制你强行这么做</p>
<p>对象调用实例方法不需要传入self</p>
<p>Student.do_homework()<br>输出：<br>  File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 292, in <module><br>    Student.do_homework()<br>TypeError: do_homework() missing 1 required positional argument: ‘self’</module></p>
<p>Student.do_homework(student1)<br>输出：english homework</p>
<p>Student.do_homework(student1)<br>但是这种方式可笑 并且多此一举</p>
<p>Student.do_homework(‘’)<br>没有报错</p>
<p>通过类来调用，self变成普通参数了</p>
<p>更改类的代码的行为，是非常不可取的</p>
<p>编程 开闭原则  扩展代码是开放的，但是更改本身代码是关闭的</p>
<p>第二种调用构造函数的方式：</p>
<p>class Student(Human):</p>
<pre><code># sum = 0

def __init__(self, school, name, age):
    self.school = school
    # Human.__init__(self,name, age)
    super(Student, self).__init__(name,age)
</code></pre><p>输出：<br>牛逼小学<br>nana<br>18</p>
<p>super关键字并不是只能用在构造函数里面</p>
<p>class Human():<br>    sum = 0<br>    def <strong>init</strong>(self, name, age):<br>        self.name = name<br>        self.age = age</p>
<pre><code>def get_name(self):
    print(self.name)

def do_homework(self):
    print(&apos;This ia a parent method&apos;)
</code></pre><p>from human import Human<br>class Student(Human):</p>
<pre><code># sum = 0

def __init__(self, school, name, age):
    self.school = school
    # Human.__init__(self,name, age)
    super(Student, self).__init__(name,age)
    # self.__score = 0
    # self.__class__.sum += 1

def do_homework(self):
    print(&apos;english homework&apos;)
</code></pre><p>student1 = Student(‘牛逼小学’,’nana’, 18)<br>student1.do_homework()</p>
<p>输出： english homework</p>
<p>子类和父类出现同名方法，python不会报错，会优先调用子类方法</p>
<pre><code>def do_homework(self):
    super(Student, self).do_homework()
    print(&apos;english homework&apos;)
</code></pre><p>输出：<br>This ia a parent method<br>english homework</p>
<p>super也可以用于普通的实例方法</p>
<p>第10章 正则表达式与JSON</p>
<p>10-1 初识正则表达式 (13:24)<br>10-2 元字符与普通字符 (09:10)<br>10-3 字符集 (07:31)<br>10-4 概括字符集 (10:33)<br>10-5 数量词 (05:43)<br>10-6 贪婪与非贪婪 (05:09)<br>10-7 匹配0次1次或者无限多次 (10:45)<br>10-8 边界匹配符 (07:59)<br>10-9 组 (03:36)<br>10-10 匹配模式参数 (06:46)<br>10-11 re.sub正则替换 (16:02)<br>10-12 把函数作为参数传递 (07:52)<br>10-13 search与match函数 (09:02)<br>10-14 group分组 (12:55)<br>10-15 一些关于学习正则的建议 (04:36)<br>10-16 理解JSON (10:28)<br>10-17 反序列化 (16:28)<br>10-18 序列化 (10:51)<br>10-19 小谈JSON、JSON对象与JSON字符串 (09:29)</p>
<p>第11章 Python的高级语法与用法</p>
<p>11-1 枚举其实是一个类 (08:54)<br>11-2 枚举和普通类相比有什么优势 (08:48)<br>11-3 枚举类型、枚举名称与枚举值 (05:11)<br>11-4 枚举的比较运算 (04:33)<br>11-5 枚举注意事项 (05:18)<br>11-6 枚举转换 (05:59)<br>11-7 枚举小结 (09:09)<br>11-8 进阶内容开场白 (06:00)<br>11-9 一切皆对象 (12:45)<br>11-10 什么是闭包 (15:41)<br>11-11 一个事例看看闭包 (04:24)<br>11-12 闭包的经典误区 (08:08)<br>11-13 出个题,用闭包解决! (04:29)<br>11-14 我先用非闭包解决一下 (09:21)<br>11-15 再用闭包解决一下_ (09:55)<br>11-16 小谈函数式编程 (08:10)</p>
<p>第12章 函数式编程： 匿名函数、高阶函数、装饰器</p>
<p>12-1 lambda表达式。 (10:12)<br>12-2 三元表达式 (06:30)<br>12-3 map (07:30)<br>12-4 map与lambda (06:41)<br>12-5 reduce (14:19)<br>12-6 filter (06:15)<br>12-7 命令式编程vs函数式编程 (06:47)<br>12-8 装饰器 一 (13:04)<br>12-9 装饰器 二 (08:43)<br>12-10 装饰器 三 (08:46)<br>12-11 装饰器 四 (07:38)<br>12-12 装饰器 五 (07:35)<br>12-13 装饰器 六 (08:43)</p>
<p>第13章 实战：原生爬虫</p>
<p>13-1 分析抓取目的确定抓取页面 (07:30)<br>13-2 整理爬虫常规思路 (09:38)<br>13-3 VSCode中调试代码 (11:57)<br>13-4 HTML结构分析基本原则二条 (08:23)<br>13-5 数据提取层级分析及原则三 (13:07)<br>13-6 正则分析HTML (15:12)<br>13-7 正则分析获取名字和人数 (06:05)<br>13-8 数据精炼 (06:53)<br>13-9 sorted 排序 (12:11)<br>13-10 案例总结 (19:10)</p>
<p>第14章 Pythonic与Python杂记</p>
<p>14-1 导言 (05:30)<br>14-2 用字典映射代替switch case语句 (13:57)<br>14-3 列表推导式 (09:36)<br>14-4 字典如何编写列表推导式 (05:19)<br>14-5 None (08:53)<br>14-6 对象存在并不一定是True (05:56)<br>14-7 <strong>len</strong>与<strong>bool</strong>内置方法 (10:16)<br>14-8 装饰器的副作用 (08:27)</p>
</class>
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/12/01/为元组元素命名提高程序可读性/" rel="next" title="为元组元素命名提高程序可读性">
                <i class="fa fa-chevron-left"></i> 为元组元素命名提高程序可读性
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/12/24/给print点颜色看看/" rel="prev" title="给print点颜色看看">
                给print点颜色看看 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Nana Xie" />
          <p class="site-author-name" itemprop="name">Nana Xie</p>
           
              <p class="site-description motion-element" itemprop="description">Stay Hungry Stay Foolish</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
            
              <a href="/archives/">
            
                <span class="site-state-item-count">29</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">13</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">23</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/NanaCode" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                    
                      GitHub
                    
                </a>
              </span>
            
          
        </div>

        
        

        
        


        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#class-Printer"><span class="nav-text">class Printer():</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#def-print-file-self"><span class="nav-text">def print_file(self):</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#print-‘name-’-self-name"><span class="nav-text">print(‘name:’ + self.name)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#print-‘age-’-str-self-age"><span class="nav-text">print(‘age:’ + str(self.age))</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#变量的作用域"><span class="nav-text">变量的作用域</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#self-name-与-name"><span class="nav-text">self.name 与 name</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#self-name-与-name-1"><span class="nav-text">self.name 与 name</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#实例方法如何访问类变量"><span class="nav-text">实例方法如何访问类变量</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#student1-add-1-2"><span class="nav-text">student1.add(1, 2)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Student-add-1-2"><span class="nav-text">Student.add(1, 2)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#student1-score-1"><span class="nav-text">student1.score = -1</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#print-student1-sum"><span class="nav-text">print(student1.sum)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#print-Student-sum"><span class="nav-text">print(Student.sum)</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nana Xie</span>

  
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.2"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.2"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.2"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.2"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.2"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.2"></script>



  


  




	





  





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("NKj4cIziN7Jv2VdApl3RrMIF-gzGzoHsz", "3me0jhp47YDrT8nzgYGhztxo");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

  

</body>
</html>
