<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[机器学习之入门笔记]]></title>
    <url>%2F2018%2F01%2F06%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1.1机器学习：让机器去学习传统算法：让机器去执行 最早机器学习应用：垃圾邮件分辨 图像识别二分类问题 分辨猫和狗 不是猫就是狗 黑盒子算法 白盒子算法 人脸识别 数字识别 MINST数据集 邮政车库 交通摄像头 人类怎么学习 人类学习过程 典型 经验学习过程 机器学习类似人类学习 学习得到执行任务的算法-模型 训练模型 资料越来越多，计算机执行效率-算力越来越高 信用卡发放判断风险 google搜索 部分关键字 浏览商品，感兴趣商品 音乐推荐 图书 文章等 语音识别 人脸识别 金融预测 医疗诊断 市场分析 无人驾驶安全领域医疗领域金融领域 市场领域自然语言处理-智能翻译各种专有领域：矿产勘查 宇宙探索 药物研发。。。 1.2机器学习算法人工智能 机器学习 深度学习 神经网络 深度学习的基础 调库 算法原理学习算法底层编写scikit-learn 1.3技术栈python3框架：scikit-learnnumpy matplotlib… anaconda 高等数学 求导 scikit-learn 内置数据集MINST数据集 真实世界的数据进行预处理过程 不包括神经网络和深度学习 关注监督学习 2.1 机器学习世界的数据鸢尾花数据Iris flower data set 数据整体叫数据集（data set)表格中每一行数据称为一个样本(sample)除了最后一列表达样本的种类，每一列表达样本的一个特征(feature) X：数据整体特征 矩阵第i个样本行写作X ?第i个样本第j个特征值X ? 最后一列特殊 机器学习真正要学习的内容 最后一列，称为标记（label) y 小写，因为它是一个向量X 矩阵 y 向量 y向量：第i个样本的标记写作y? 每一行 特征向量 X ? 向量 行向量 n个特征 1xn列向量 nx1 通常表示为列向量 有点听不懂了。。。 特征空间 feature space 分类任务本质就是在特征空间切分 鸢尾花 四个特征 四维空间 高维空间同理 低维空间推广到高维空间 特征可以很抽象 图像，每一个像素点都是特征 MINST 手写数据集 2828的图像有2828=784个特征 灰度图像 彩色图像 2.2 机器学习的基本任务分类任务 回归任务 分类任务：二分类 判断邮件是垃圾邮件 不是垃圾邮件； 银行判断发放给客户信用卡有风险 没有风险； 医院判断病患良性肿瘤 恶性肿瘤；股票交易 判断某支股票 涨 跌 多分类： 手写数字识别图像识别判断发放给客户信用卡风险评级自动玩2048的人工智能 判断上移 左移 右移 下移下围棋无人车领域 控制方向盘 油门 刹车 一些算法只支持完成二分类的任务但是多分类的任务可以转换成二分类的任务有一些算法天然可以完成多分类任务 多标签分类 房产数据回归任务：结果是一个连续数字的值，而非一个类别？？？ 预测房屋价格市场分析预测学生成绩预测股票价格 有些算法只能解决回归问题有些只能解决分类问题有些都能 一些情况下，回归任务可以简化成分类任务 模型可以理解成函数 f(x) x样本资料f(x)结果是类别-分类问题 结果是数值-回归问题 监督学习主要处理分类问题和回归问题 2.3机器学习算法分类:监督学习 非监督学习 半监督学习 增强学习 监督学习: 给机器的训练数据拥有“标记”或者“答案”给机器的数据 既有X又有y 既有数据特征 又有数据标记 监督学习k近邻 线性回归和多项式回归 逻辑回归 SVM 决策树和随机森林 非监督学习算法 辅助监督学习算法非监督学习：给机器的训练数据没有任何“标记”或者“答案”对没有“标记”的数据进行分类-聚类分析对数据进行降维处理：特征提取：信用卡的信用评级和人的胖瘦 无关？特征压缩：PCA 尽量少的损失信息的情况下，将高维的特征向量压缩成低维的特征向量 降维处理的意义：方便可视化 人类不能理解四维以上的信息 异常检测 找到样本的一般化的特征 半监督学习：一部分数据有“标记”或者“答案”，另一部分数据没有更常见：各种原因产生的标记缺失 通常先使用无监督学习手段对数据进行处理，是数据变成监督学习的模式。之后使用监督学习手段做模型的训练和预测 增强学习：根据周围环境的情况，采取行动，根据采取行动的结果，学习行为方式。行动 反馈 循环阿尔法狗就是增强学习的应用无人驾驶 机器人监督学习和半监督学习是基础 2.4机器学习的其他分类在线学习和批量学习（离线学习）参数学习和非参数学习 批量学习 离线学习 Batch Learning在线学习 Online Learning 批量学习 离线学习 Batch Learning新的样例不再作为训练集 优点：简单问题：如何适应环境变化？解决方案：定时重新批量学习缺点：每次重新批量学习，运算量巨大；在某些环境变化非常快的情况下，甚至不可能的，如股票数据； 在线学习：优点：及时反映新的环境变化问题：新的数据带来不好的变化解决方案：需要加强对数据进行监控其他：也适用于数据量巨大，完全无法批量学习的环境。 在线学习，很大程度上也是对批量学习的一个改进 参数学习：Parametric Learning非参数学习：Nonparametric Learning 参数学习：Parametric Learning一旦学到了参数，就不再需要原有的数据集最基础的线性回归的方法 统计学 统计模型 非参数学习： 不对模型进行过多假设非参数学习不代表没有参数区别在于不对整个问题进行建模，不把整个问题认为是学习参数 2.5不确定的世界的相关问题 数据记算法？ 数据确实非常重要 数据驱动 高度依赖数据本身质量收集更多数据 提高数据质量 提高数据的代表性 研究数据更重要的特征=特征工程 AlphaGo Zero Starting from scratch 算法为王？ 如何选择机器学习算法？ 奥卡姆的剃刀 简单的就是好的机器学习领域，到底什么叫“简单”？机器学习处理的是不确定的世界的真实的问题 没有免费的午餐定理可以严格的数据推导出：任意两个算法，他们的期望性能是相同的！概率论，期望-平均值 具体到某个特定问题，有些算法可能更好特定的某个特定领域的问题 但没有一种算法，绝对比另一种算法好 脱离具体的问题，谈哪个算法好是没有意义的 在面对一个具体问题的时候，尝试使用多种算法进行对比试验，是必要的。 面对不确定的世界，怎么看待使用机器学习进行预测的结果？ 机器伦理学 2.6环境搭建 anacondapython3.6 python2.7-2020年不再更新维护Anaconda-navigator dai 3.1Jupyter基础待]]></content>
  </entry>
  <entry>
    <title><![CDATA[给print点颜色看看]]></title>
    <url>%2F2017%2F12%2F24%2F%E7%BB%99print%E7%82%B9%E9%A2%9C%E8%89%B2%E7%9C%8B%E7%9C%8B%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[python之巩固基础篇]]></title>
    <url>%2F2017%2F12%2F08%2Fpython%E4%B9%8B%E5%B7%A9%E5%9B%BA%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[第1章 Python入门导学 1-1 导学 (11:33) python2处于维护期 了解语法是编程的先决条件，精通语法是编好程的必要条件 Life is simple, I use python. 如何交换两个变量？ x, y = y, x Python之禅 1-2 Python的特性 (12:34) Life is short i use python 面向对象 是一种思想 面向对象 面向过程 1-3 我为什么喜欢Python (09:28) python 动态脚本 又有面向对象的特性 1-4 Python的缺点 (08:25) 慢 运行效率和开发效率，鱼与熊掌不可兼得 1-5 一个经典误区 (04:19) 编程是为了解决问题 web只是编程的一个应用方向 1-6 python能做些什么？ (05:44) python主流功能 遇到问题，拿起python,编写工具 1-7 课程内容与特点 (08:32) 基础知识不够扎实 python高性能与优化 数据结构是扎实的编程功底的基础 数据结构和语言无关 1-8 Python的前景 (05:28) 如果人的一生只能选择一门语言？ 1-9 课程维护与提问 (01:45) 慕课手记知乎专栏：小楼昨夜又秋风 第2章 Python环境安装 2-1 下载Python安装包 (03:22) python3.5以上版本不支持windows XP 2-2 安装Python (02:31) Add python3.x to PATH 查阅python官方文档 2-3 IDLE与第一段Python代码 (02:55) IDLE options - config IDLE python 代码末尾不需要分号 python靠缩进来控制代码格式 第3章 理解什么是写代码与Python的基本类型 3-1 什么是代码，什么是写代码 (04:22) 代码是现实世界事物在计算机世界的映射 写代码是将现实世界中的事物用计算机语言来描述 计算机语言：基本数据类型 逻辑思维 构成 3-2 数字：整形与浮点型 (07:21) Number:数字 整数 小数 整数int（其他语言short int long,python简化只有int这种数据类型，） 浮点数float(其他语言还分单精度float和双精度double，精度越高，数值越准确) python只有一种类型 因为python支持的就是双精度 type(1) type(-1) type(1.1) type(-1.111111111111111111111111111111111111111) 混合计算 type(1+0.1) type(1+1) type(1.1+0.9) type(1+1.0) type(1*1) type(1*1.0) 注意！！！！！ type(2/2) type(2//2) type(2.0//2) type(2.0//2.0) 2/21.02//212.0//2.01.0 1//2？ 1//20 / 除法 //整除 python2的情况可能不一样，试下 python3 只有int python2 还有long 3-3 10、2、8、16进制 (08:32) 满N进一 0 1 2 3 4 5 6 7 8 9 10 满10进一0 1 10 满2进一二进制的10和十进制的10不是同一个概念 0 1 2 3 4 5 6 7 10 0 1 2 3 4 5 6 7 8 9 A B C D E F 10 还有其他进制 60秒=1分 3-4 - 各进制的表示与转换 (07:35) 不同进制里，python如何区分数字10 python表示二进制：0b0b10 二进制的数字10 二进制转换成10进制 0b1020b113 python表示八进制：0o0o10 八进制的10 0o1080o119 python表示十六进制：0x0x10 十六进制的10 0x10160x1F31 IDLE默认转换成十进制 其他进制转化二进制：bin() bin(10)‘0b1010’bin(0o7)‘0b111’bin(0xE)‘0b1110’ 其他进制转化十进制：int() int(0b111)7int(0o77)63 其他进制转化十六进制：hex() hex(888)‘0x378’hex(0o777)‘0x1ff’ 其他进制转化成八进制:oct() oct(0b111)‘0o7’oct(0x777)‘0o3567’ 3-5 数字：布尔类型与复数 (08:24) 还包括bool 布尔类型：表示真 假 还有complex 复数 注意 T和F是大写的 ！！！ TrueTrueFalseFalsetrueTraceback (most recent call last): File ““, line 1, in trueNameError: name ‘true’ is not definedfalseTraceback (most recent call last): File ““, line 1, in falseNameError: name ‘false’ is not defined 和其他语言不一样 type(True) type(False) 为什么布尔类型会归到数字这个分类下面？ 转换十进制： int(True)1int(False)0 转换成布尔类型： bool(1)Truebool(0)False 一正一反论证了布尔类型在python是属于数字类型的 是不是只有数字1表示True,0表示false? 只要是非0的数字都表示的是布尔真，只有0表示布尔假 bool(2)Truebool(2.2)Truebool(-1.1)Truebool(0)Falsebool(0b01)Truebool(0b0)False 并不是只有数字才能表示布尔类型，或者和布尔类型做转换字符串： bool(‘abc’)Truebool(‘’)False列表：bool([1,2,3])Truebool([])False集合：bool({1,2,3})Truebool({})False重要！！！数字0和一系列空值都会被认为是布尔假 False非空 True 空值 False python特殊类型：None bool(None)False python如何表示复数？j 36j36j 3-6 字符串：单引号与双引号 (09:08)学习编程：抓大放小 曾经沧海难为水，除却巫山不是云。取次花丛懒回顾，半缘修道半缘君。 ——-唐 元稹 str 字符串 字符串的操作都是必不可少的，非常重要的 python如何表示字符串？单引号 双引号 三引号 1 和 ‘1’ 是同样一个东西吗？ type(1) type(‘1’) 很多bug是这个问题引起的 中文引号不能表示字符串 python所有的符号都不能是中文的，必须是英文的 为什么除了单引号还要有双引号？ ‘let’s go’SyntaxError: invalid syntax“let’s go”“let’s go” 引号表示字符串的时候需要成对出现 里面的引号是文字本事呢的内容 ‘let\’s go’“let’s go”\转义字符 “let’s go” 更推荐这种表示方法 3-7 多行字符串 (10:32)python建议 每行宽度最大是79 ‘’’hello nanahello nanahello nana‘’’‘hello nana\nhello nana\nhello nana\n’“””hellohellohello“””‘hello\nhello\nhello\n’ 三个单引号 三个双引号 都可以效果是一样的 \n 表示回车 敲击回车的动作 tab虽然看不到，但是也是一个字符的存在 反向思维： ‘hello nana\nhello nana\nhello nana\n’‘hello nana\nhello nana\nhello nana\n’不会，会原样显示出来，不会换行 print(‘hello nana\nhello nana\nhello nana\n’)hello nanahello nanahello nana 这样就是换行的 IDLE和print函数的显示特点print函数的显示特点要牢记有些面试会问道IDLE的特性单引号 双引号 也有换行的特性， 不只三引号 常见的理解上的误区：三个引号不一定要换行 “””hello worldhello nana”””‘hello world\nhello nana’“””hello worldhello nana”””‘\nhello world\nhello nana’ “””hello worldhello nana“””‘\nhello world\nhello nana\n’ ‘helloSyntaxError: EOL while scanning string literal‘hello\world’‘helloworld’加个反斜杠就不会报错这也是字符串换行的方式 单引号和双引号换行的方式 基本常识牢记，写代码才能写的快 好记性不如烂笔头 3-8 转义字符 (04:24) 特殊的字符 无法“看见”的字符与语言本身语法有冲突的字符 如单引号 作为普通字符和python语法是有冲突的 \n 换行\’ 单引号\t 横向制表符 注意！！！ \n 换行\r 回车 是不一样的 不是同一个概念 ???????? 思考：print(‘hello \n world’) 要求\n 也被输出出来 print(‘hello \n world’)hello world 我的尝试： print(‘hello \n world’)hello \n worldprint(r’hello \n world’)hello \n world 3-9 原始字符串 (05:44) 输出文件夹的路径； print(‘c:\northwind\northwest’)c:orthwindorthwestprint(‘c:\northwind\northwest’)c:\northwind\northwestprint(r’c:\northwind\northwest’)c:\northwind\northwest 加上r，字符串就不是一个普通字符串了，而是一个原始字符串 原始字符串 所见即所得 print(r’let’s go’) SyntaxError: invalid syntax 为什么？不是一个字符串，更加不可能是一个原始字符串 要么记笔记 要么多写代码 3-10 字符串运算 一 (07:24) 字符串的操作在编程中是用的非常非常多的 字符串合并 字符串只保留一部分 字符串的运算： 字符串拼接：用的非常多 “hello” + “world”‘helloworld’ 字符串的乘法： “hello”*3‘hellohellohello’ 字符串乘以字符串会报错： “hello” “world”Traceback (most recent call last): File ““, line 1, in “hello” “world”TypeError: can’t multiply sequence by non-int of type ‘str’ 获取字符串单个字符： “hello world”[0]‘h’“hello world”[1]‘e’“hello world”[3]‘l’“hello world”[4]‘o’ 下标操作符注意！！！下标的序号是从0开始的 “hello world”[-1]‘d’“hello world”[-3]‘r’ 正数负数 从末尾往前数n次得到的字符 思考：获取“hello world” w 字符 两种方式 我的： “hello world”[6]‘w’“hello world”[-5]‘w’ 3-11 字符串运算 二 (04:48) 截取一组字符：起点 终点 “hello world”[0:4]‘hell’“hello world”[0:5]‘hello’ 最后要截取的字符的下一位 “hello world”[0:-1]‘hello worl 负数 表示步长的概念 长度的概念 思考：”hello world”截取world 两种方式 我的尝试： “hello world”[6: 11]‘world’“hello world”[6: -1]‘worl’“hello world”[6: 0]‘’“hello world”[6:]‘world’“hello world”[-5:]‘world’ “hello world”[6: 11]‘world’ “hello world”[6:]‘world’ “hello world”[6: 11]‘world’ 3-12 字符串运算 三 (08:37) 老师： “hello world”[6: 20]‘world’保持好奇心 “hello world”[6: 0]‘’“hello world”[6: -0]‘’得到的都是空 “hello python java ruby”[:-4]‘hello python java ‘“hello python java ruby”[0:-4]‘hello python java ‘ “hello python java ruby”[-4:]‘ruby’ 原始字符串r R 都可以 r’c:\windows\nana’‘c:\windows\nana’R’c:\windows\nana’‘c:\windows\nana’ 为什么变成两条横杆了？？？ 笔记 整理思路的过程 第4章 Python中表示“组”的概念与定义 4-1 列表的定义 (06:47) python如何表示组的概念？ 表示组的方法有很多种 python如何定义列表：[1,2,3,4,5,6] 中间逗号分隔 type([1,2,3,4,5,6]) 内部类型是可以混合的：[‘hello’, ‘world’, 1, 9, True, False] type([‘hello’, ‘world’, 1, 9, True, False]) type([[1,2],[3,4],[5,6]]) 二维数组 python中叫嵌套列表 4-2 列表的基本操作 (07:06) 访问列表某个元素[1,2,3,4] [1,2,3,4][0]1 [1,2,3,4][0:2][1, 2] [1,2,3,4][-1:][4] 注意！！！！！！！单一下标，得到的是数组冒号 得到的是一个列表 哪怕列表只有一个元素细节问题 容易引起代码的Bug 提高写代码效率，基本功必须扎实 列表的截取，同字符串的截取 列表追加元素：列表合并： [1,2,3,4] + [1,2,3,4][1, 2, 3, 4, 1, 2, 3, 4] 乘法： [1,2,3,4]3[1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4][1,2,3,4][1,2,3,4]Traceback (most recent call last): File ““, line 1, in [1,2,3,4]*[1,2,3,4]TypeError: can’t multiply sequence by non-int of type ‘list’ 列表的减法： [1,2,3,4]-[1]Traceback (most recent call last): File ““, line 1, in [1,2,3,4]-[1]TypeError: unsupported operand type(s) for -: ‘list’ and ‘list’没有这样的操作 编程是实践性非常强的工作 经常试一试 思考：世界杯分组情况 4-3 元组 (10:22)有趣的问题，L=[‘’] 字符长度为什么也是1空字符串也是一个元素 元组的访问：和列表 字符串是一样的 (1,2,3,4)[0]1 (1,2,3,4)[0:2](1, 2) 相加： (1,2,3,4) + (1,2,3,4)(1, 2, 3, 4, 1, 2, 3, 4) 相乘： (1,2,3,4) * 3(1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4) 为什么python要区别列表和元组？ int str list tuple type((1,2,3)) type(1) type([1,2,3]) type([‘hello’]) class就是面向对象的类 奇怪的现象： type((1)) type((‘hello’)) 为什么不是显示tuple? 因为（）即可以表示元组，也是数学计算的基本符号，数学运算符 python硬性规定：（1）表示数学运算符，type((1))等同于type(1) 如何定义只有一个元素的元组？ (1)1(1,)(1,)type((1,)) 如何表示一个元素都没有的空的元组： ()()type(()) 发散： type([1]) 4-4 序列总结 (17:17) int float bool str list tuple str list tuple 很多相似之处 —-都是序列 序列都有哪些共有的操作？ [n] 中括号和序号获取元素 —-序列每个元素都将被分配一个序号， 都有顺序，也有序号序号的概念 切片：切片还有一种有趣的用法： “hello world”[0:8:2]‘hlow’ 序列可以加和乘 判断序列是否包含某个元素？in 运算符 3 in [1,2,3,4,5]True10 in [1,2,3,4,5]False 不在： 3 not in [1,2,3,4,5]False10 not in [1,2,3,4,5]True 统计序列元素len([1,2,3,4,5])5 len(“hello world”)11注意空格 求最大 max([1,2,3,4,5])5 7.求最小 min([1,2,3,4,5])1 max(“hello world”)‘w’min(“hello world”)‘ ‘min(“helloworld”)‘d’涉及字符编码，ascii,ord() return the unicode code point for a one-character stringord(‘w’)119ord(‘ ‘)32ord(‘d’)100 还有一种无序的集合类型 4-5 set 集合 (12:19) 集合 set 集合非常重要的特性： 无序 序列是有序的，但是集合最大的特点是无序的 集合定义： type({1, 1, 2, 3, 4, 5}) {1, 1, 2, 3, 4, 5}[0]Traceback (most recent call last): File ““, line 1, in {1, 1, 2, 3, 4, 5}[0]TypeError: ‘set’ object does not support indexing集合是无序的，没有下标索引 {1, 1, 2, 3, 4, 5}[0:2]Traceback (most recent call last): File ““, line 1, in {1, 1, 2, 3, 4, 5}[0:2]TypeError: ‘set’ object is not subscriptable更不支持切片操作 集合的第二个特点：不重复 {1, 1, 2, 2, 3, 3, 4, 4, 5, 5}{1, 2, 3, 4, 5}所有重复元素都被剔除掉 集合支持的操作： 长度判断：len() len({1,2,3})3len({1,1,2,2,3,3})3 判断集合是否包含某个元素 1 in {1,1,2,2,3,3}True1 not in {1,1,2,2,3,3}False8 in {1,1,2,2,3,3}False8 not in {1,1,2,2,3,3}True 集合的优势在哪里？{1，2，3，4，5，6} {3，4}如何将第一个集合里面的第二个集合的相关元素给剔除掉？ {1,2,3,4,5,6} - {3, 4}{1, 2, 5, 6}不是减号，而是求两个集合的差值 {1，2，3，4，5，6} {3，4}找两个集合所共有的元素？ {1,2,3,4,5,6} &amp; {3, 4}{3, 4}交集-数学概念 {1，2，3，4，5，6} {3，4，7} 合并集合 不能出现重复元素 {1,2,3,4,5,6} | {3, 4, 7}{1, 2, 3, 4, 5, 6, 7}合集 并集 &amp; | 集合的特色 如何定义一个空的集合？ type({}) set()set()type(set()) set() 这才是定义空的集合的方法 len(set())0 4-6 dict 字典 (14:51) 字典 dict key value 通过key关键字，找到value值 一个字典是可以由很多个key和value值来组成的，所以字典也是一个集合类型但是字典不是序列，更像是一个set,字典也是无序的 定义字典：{}{key1:value1,key2:value2…} 字典和集合最大的区别：每个元素定义的方式不同，集合只有一个value值没有key，字典除了value值还有key值，key和value之间用冒号来分隔开 type({1:1, 2:2, 3:3}) 有意义的字典，什么情况下适合用字典？ 字母和技能之间的关系：{‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’} type({‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}) {‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}[0]Traceback (most recent call last): File ““, line 1, in {‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}[0]KeyError: 0 下标序号访问是不可以的因为字典也是无序的 字典访问方式：通过key 得到/访问 value {‘Q’:’降龙十八掌’, ‘W’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}[‘Q’]‘降龙十八掌’ 字典存在相同的key {‘Q’:’降龙十八掌’, ‘Q’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}[‘Q’]‘吸星大法’{‘Q’:’降龙十八掌’, ‘Q’:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}{‘Q’: ‘吸星大法’, ‘E’: ‘蹬鼻子上眼’, ‘R’: ‘轻功’}第一个Q已经不在字典里了 字典的特点：字典里是不能有重复的key 字典的key和value只能是字符串？1和’1‘是相同的key吗？ {‘1’:’降龙十八掌’, 1:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}{‘1’: ‘降龙十八掌’, 1: ‘吸星大法’, ‘E’: ‘蹬鼻子上眼’, ‘R’: ‘轻功’} 字典的键不一定非得是字符串，还可以是数字数字的1和字符串的1会被识别为两个不同的key value数据类型：可以取python里面任意的一种数据类型，包括但不限于str int float list set dict(甚至可以是dict) type({‘1’:’降龙十八掌’, 1:’吸星大法’, ‘E’:{1:1}, ‘R’:’轻功’}) 字典的value在python中几乎没有任何限制 key数据类型：但是key不能是任意的类型key必须遵循的原则：key必须是不可变的类型 int str {[1,2]:’降龙十八掌’, 1:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}Traceback (most recent call last): File ““, line 1, in {[1,2]:’降龙十八掌’, 1:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}TypeError: unhashable type: ‘list’{(1,2):’降龙十八掌’, 1:’吸星大法’, ‘E’:’蹬鼻子上眼’, ‘R’:’轻功’}{(1, 2): ‘降龙十八掌’, 1: ‘吸星大法’, ‘E’: ‘蹬鼻子上眼’, ‘R’: ‘轻功’} 列表不行 元组可以 思考：空的字典如何定义？我的： {}{}type({}) bingo 4-7 思维导图总结基本数据类型 (05:06) 字符串和元组是不可变的类型 但是列表是可变的 平时多看看这篇 第5章 变量与运算符 5-1 什么是变量 (09:49) 5-2 变量的命名规则 (11:01)5-3 值类型与引用类型 (15:40)5-4 列表的可变与元组的不可变 (09:28)5-5 运算符号 (07:51)5-6 赋值运算符 (07:40)5-7 比较运算符 (05:58)5-8 不只是数字才能做比较运算_ (08:39)5-9 逻辑运算符 (19:28)5-10 成员运算符 (06:54)5-11 身份运算符 (06:54)5-12 如何判断变量的值、身份与类型 (10:31)5-13 位运算符 (07:44) 第6章 分支、循环、条件与枚举 6-1 什么是表达式 (07:28)6-2 表达式的优先级 (12:38)6-3 表达式优先级练习 (06:44)6-4 在文本文件中编写Python代码 (09:33)6-5 熟悉VSCode开发环境与Python插件安装 (16:37)6-6 流程控制语句之条件控制一 (15:01)6-7 流程控制语句之条件控制 二 (07:24)6-8 常量与Pylint的规范 (17:44)6-9 流程控制语句之条件控制 三 snippet、嵌套分支、代码块的概念 (18:11)6-10 流程控制语句之条件控制 四 elif的优点 (10:54)6-11 思考题解答与改变定势思维 (05:56) 第7章 包、模块、函数与变量作用域 7-1 while循环与使用场景 (09:46)7-2 for与for-else循环 (12:55)7-3 for 与 range (09:32)7-4 新篇章导言 (09:00)7-5 Python工程的组织结构：包、模块儿、类 (07:01)7-6 Python包与模块的名字 (05:17)7-7 import导入模块 (11:05)7-8 from import 导入变量 (08:11)7-9 init.py 的用法 (20:34)7-10 包与模块的几个常见错误_ (11:33)7-11 模块内置变量 (15:08)7-12 入口文件和普通模块内置变量的区别 (14:01)7-13 name的经典应用 (13:29)7-14 相对导入和绝对导入 一 (18:49)7-15 相对导入和绝对导入 二 (07:37) 第8章 Python函数 8-1 认识函数 (12:07)8-2 函数的定义及运行特点 (16:25)8-3 如何让函数返回多个结果 (12:41)8-4 序列解包与链式赋值 (06:05)8-5 必须参数与关键字参数 (09:26)8-6 默认参数 (17:22)8-7 可变参数 (15:33)8-8 关键字可变参数 (14:00)8-9 变量作用域 (14:06)8-10 作用域链 (04:58)8-11 global关键字 (07:07)8-12 划算还是不划算 (15:27) 第9章 高级部分：面向对象 9-1 类的定义 (17:10) 如何构建一个类： 面向对象两个核心：类 对象 什么是类 什么是对象 他们之间的关系 python使用class关键字来定义一个类 类命名规则和变量是不一样的：1.变量最好小写，类建议第一个字母是要大写；2.变量，两个单词之间使用下划线来进行连接；类，两个单词的首字母都使用大写，如StudentHomework,而不是通过下划线来连接。3.类括号里传的参数和函数里的括号的参数是不一样的 冒号后开始类的类体的编写 类的内部首先可以定义变量 类的内部可以做哪些事情？ 定义若干个变量；class Student(): name = ‘’ age = 0 定义函数class Student(): name = ‘’ age = 0 def print_file(): pass 类定义完后，如何使用这样一个类？如何调用类里面的函数？要使用类，必须把类实例化实例化的方式，用一个变量来接受实例化的结果 class Student(): name = ‘’ age = 0 def print_file(): pass student = Student()(其他语言需要使用new关键字来实例化一个类)python直接使用类名加括号来完成实例化的过程 student = Student()student.print_file()就可以调用类下面的方法 方法而不是函数 函数和方法有什么区别呢？ class Student(): name = ‘’ age = 0 def print_file(): print(&apos;name:&apos; + name) print(&apos;age:&apos; + str(age)) student = Student()student.print_file() python xx.py Traceback (most recent call last): File “student.py”, line 14, in student.print_file()TypeError: print_file() takes 0 positional arguments but 1 was given 报错了不需要传入参数但是却又一个参数传入了 类里编写函数和普通函数是有区别的，必须在参数列表强制传入一个固定的参数self class Student(): name = ‘’ age = 0 def print_file(self): print(&apos;name:&apos; + name) print(&apos;age:&apos; + str(age)) student = Student()student.print_file() 报错：Traceback (most recent call last): File “student.py”, line 14, in student.print_file() File “student.py”, line 10, in print_file print(‘name:’ + name)NameError: name ‘name’ is not defined之前函数内部直接引用全局变量是没有问题的 如何正确引入类下面定义的变量？需要使用self关键字class Student(): name = ‘’ age = 0 def print_file(self): print(&apos;name:&apos; + self.name) print(&apos;age:&apos; + str(self.age)) student = Student()student.print_file() name:age:0 此时没有问题，正确的打印出了name和age 总结： 使用类把变量和函数封装起来了类没有什么神奇的，类的最基本的概念就是封装一系列的变量和函数类的最基本的作用就是封装代码 类最基本的作用： 封装 不同的变量会被封装在不同的类里面 类下面的函数就是方法，一定要接受一个self的参数其次，类下的方法使用类下定义的变量，需要通过self.这个操作符来引用的，直接使用变量是会报错的 初学python 初学编程 容易犯的错：函数的调用放在类里面去执行class Student(): name = ‘’ age = 0 def print_file(self): print(&apos;name:&apos; + self.name) print(&apos;age:&apos; + str(self.age)) print_file() 报错：Traceback (most recent call last): File “student.py”, line 6, in class Student(): File “student.py”, line 14, in Student print_file()TypeError: print_file() missing 1 required positional argument: ‘self’ 类的最基本的原则：类只负责去定义或者刻画一些东西 描述一些东西，定义一些行为，但是他不会去负责执行代码 运行或调用类，要放在类的外部 类最基本的作用就是封装，如果在类内部调用函数的话，就和模块没什么区别了 类的实例化和类的方法调用写在和类同一个模块下面做项目的时候，不推荐在一个模块下面，又定义类，又去完成类的实例化和类的方法调用建议：定义类的模块只写类的定义；类的实例化和类方法的调用放到另一个模块里 9-2 浅谈函数与方法的区别 (05:38) 如何在另一个模块使用类？from student import Student student = Student()student.print_file() 如果不这样做，会让你的代码的结构变得很松散 方法和函数的区别？现在，方法和函数没有绝对的区别很多时候在模糊方法和函数的区别 C C++ 函数Java C# 方法 方法 设计层面上的一个称谓方法更多是面向对象里面的一个概念而面向对象最重要的是：面向对象更加关注的是一个设计 设计代码的结构 设计你的封装 函数：程序运行、过程式的一种称谓面向过程的一个概念 没有所谓的设计层面的意义在里面 类里面的函数 称为方法 如果只是把函数定义在模块里面，不要称作方法，还是成为函数 类下面定义的变量 模块里面定义的变量，称为变量类下面定义的变量，python更多的是称为数据成员数据成员在于体现类的封装性每个变量都可以认为是一个数据，这样的数据用来描述类的特征 没有必要特别区分函数和方法 变量和数据成员 9-3 类与对象。 (10:21) 类和对象到底是什么，他们之间的关系？ student = Student()类和对象通过实例化关联起来的 什么是类？ 类是显示世界或思维世界中的实体在计算机中的反映。它将数据以及这些数据上的操作封装在一起 数据是类用来刻画某些事物的一些基本特性 除了数据是不够的，还要有一些行为 数据成员刻画特征，方法描述行为 类： 行为与特征 类的设计是一种艺术 print_file强行和student关联在一起并不合适 把握行为的主体是什么的原则 行为没有找对主体，是很多同学在设计面向对象的时候，最容易忽略的一个问题 class Student(): name = ‘’ age = 0 def do_homework(self): print(&apos;homework&apos;) class Printer():# def print_file(self):print(‘name:’ + self.name)print(‘age:’ + str(self.age))类是一个抽象的概念类只是一类事物的总称，它并不具体 如何表示一个具体的学生？对象表示具体的概念 类实例化之后就变成一个具体的对象 实例化的时候，需要向类里面传递类的一些特征和具体值，然后才能得到一个具体的对象如果没有具体的数据，就不是一个对象。因为不具体，还是非常抽象 类是模版，通过模版可以做成各种各样的对象对象具有共同的特性 类可以通过传入各种各样的特征的具体值来产生各种各样不同的对象 9-4 构造函数 (18:45) 实例化 实例化的意义 什么叫不同的对象？ 特征不相同 如何让类的模版生成不同的对象呢？就是实例话要做的事情 student1 = Student()student2 = Student()student3 = Student()这三个对象是一样的因为他们的name和age是相同的特征是相同的 不过不代表他们在计算机就是同一个对象 id()函数 查看他们的内存地址 print(id(student1))print(id(student2))print(id(student3)) 238753681728823875377988162387537679864 三个对象的内存地址是完全不相同的 实例化过程中如何让对象不相同？ 处理函数的过程会定义形参，然后传递不同的实参到函数内部，由此让函数返回不同的结果 实例化，也需要向类传递一系列的参数，让类生成的对象变得不相同 类的内部定义一个特殊的函数： def init(self): pass 这个特殊的函数，叫构造函数构造函数的概念不是python所独有的，也是很多变成语言通用的概念 构造函数 构造方法 class Student(): name = ‘’ age = 0 def __init__(self): print(&apos;student&apos;) def do_homework(self): print(&apos;homework&apos;) student1 = Student()student1.init() studentstudent 奇怪的现象，连续打印了两个student但是我们只调用了一次构造函数 构造函数的调用是自动进行的，实例化的时候python会自动调用构造函数；不需要显式调用； 能不能主动显式调用init()？ 可以，但是实际变成很少去主动显式调用init()。因为实例化的过程，构造函数已经调用过一次了，没必要再显式调用init() student1 = Student()a = student1.init()print(a)print(type(a)) studentstudentNone 返回结果是一个空， def init(self): print(‘student’)构造函数没有return任何值，相当于return None def __init__(self): print(&apos;student&apos;) return None def __init__(self): print(&apos;student&apos;) return None 不会报错，但是 def __init__(self): print(&apos;student&apos;) return &apos;hey&apos; Traceback (most recent call last): File “student.py”, line 17, in student1 = Student()TypeError: init() should return None, not ‘str’ 不能返回字符串 init和普通函数的区别：构造函数不能强行返回除了None之外的类型的值，python要求对于构造函数，只能返回None 养成探索和思考的精神和思维 不要用构造函数来返回东西，用普通函数 构造函数的作用；模版生成不同的对象 通过在构造函数这个特殊函数内增加参数来然后实例化的时候传入参数的值来让对象变得不同 注意实例化的时候传入的参数必须和构造函数的参数一致，不传的话会报错：class Student(): name = ‘’ age = 0 def __init__(self, name, age): print(&apos;student&apos;) def do_homework(self): print(&apos;homework&apos;) student1 = Student() Traceback (most recent call last): File “student.py”, line 16, in student1 = Student()TypeError: init() missing 2 required positional arguments: ‘name’ and ‘age’ 要求必须传入参数class Student(): name = ‘’ age = 0 def __init__(self, name, age): print(&apos;student&apos;) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18) student student1 = Student(‘nana’, 18) 这种写法等同于直接点用构造函数 函数内部处理传入的参数 在构造函数的内部，我们通常做的最多的一件事情就是初始化类的特征值，初始化对象的特征 name = &apos;&apos; age = 0 没有意义的初始值 构造函数里把特征值付给初始值，改变变量的初始值从而形成对象的特征 class Student(): name = ‘’ age = 0 def __init__(self, name, age): name = name age = age print(&apos;student&apos;) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)print(student1.name) student1.name 访问对象的变量或者方法都是通过.点号来操作的 php例外： student1-&gt;name 终端结果：student 什么都没有打印出来说明构造函数里的赋值，并没有改变name变量的取值 9-5 区别模块变量与类中的变量 (04:59) 回顾 模块的全局变量 局部变量 c = 50 def add(x, y): c = x + y print(c) 变量的作用域add(1,2)print(c) 打印结果 3 503 打印局部变量50 打印全局变量 如果函数定义了一个和全局变量同名的变量的话，python里的局部变量并不会覆盖全局变量 注意！！！ 局部变量的作用与仅仅局限在函数的内部 全局变量的值不会因为局部变量的值而更改 但是类中的变量和模块的变量是不能等同于的类的机制和模块中的全局变量和局部变量的机制是不一样的 打出空值的真正原因：类变量 实例变量 类变量和模块变量的相关行为分别对待 9-6 类变量与实例变量 (13:39) 什么是类变量 实例变量 及 他们的作用类变量是和类相关联的 实例变量是和对象相关联的 student1 = Student(‘nana’, 18)student2 = Student(‘helen’, 19)这两个对象是不一样的不一样在特征值 待 只写代码 self.name = name self.age = age 来保存不同的特征值定义了两个实例变量只和对象相关，和类没有关系。。。。。。 self不能称做是关键字 关键字是固定不变的，但是self是可以变的，比如改成this 类变量和实例变量在语法特性上的不同class Student(): name = ‘hehe’ age = 0 def __init__(self, name, age): self.name = name self.age = age # print(&apos;student&apos;) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)student2 = Student(‘helen’, 19)print(student1.name)print(student2.name)print(Student.name) nanahelenhehe 对象的name和类的name不是一个东西 类变量的定义有没有意义？ sum = 0 name = &apos;&apos; age = 0 做对比类变量和具体的对象无关 9-7 类与对象的变量查找顺序 (12:51) 类变量和实例变量的特性 动态语言最大的缺点就是坑挺多 class Student(): name = ‘’ age = 0 def __init__(self, name, age): name = name age = age def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)print(student1.name) 打印出来是空字符串 class Student(): name = ‘xixi’ age = 0 def __init__(self, name, age): name = name age = age def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)print(student1.name)打印出来的是 xixi 为什么想打印的是实例变量，最终打印出来的却是类变量？打印类变量的正确方法：Student.name 对象隐藏的变量dict python内置的变量 class Student(): name = ‘xixi’ age = 0 def __init__(self, name, age): name = name age = age def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)print(student1.dict) 打印：{}空的字典 dict是个字典，保存着当前对象所有的相关变量 class Student(): name = ‘xixi’ age = 0 def __init__(self, name, age): self.name = name self.age = age def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)print(student1.dict) 打印：{‘name’: ‘nana’, ‘age’: 18} python寻找相关变量的机制：实例变量找不到 会去类变量里面找如果在类里面没有找到，会去父类里寻找 还可以打印类的dict class Student(): name = ‘xixi’ age = 0 def __init__(self, name, age): self.name = name self.age = age def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)print(student1.dict)print(Student.dict) {‘name’: ‘nana’, ‘age’: 18}{‘module‘: ‘main‘, ‘sum’: 0, ‘name’: ‘xixi’, ‘age’: 0, ‘init‘: , ‘do_homework’: , ‘dict‘: , ‘weakref‘: , ‘doc‘: None} sum这样的统计数字是和类绑定在一起的 class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age def do_homework(self): print(&apos;homework&apos;) 思考；class Student(): name = ‘xixi’ age = 0 def __init__(self, name, age): self.name = name self.age = age print(age) print(name) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18) 问：print(age)print(name) 打印的是什么 我：猜想的是类变量 实际终端输出的是18nana实例变量的值？？？？？？ 方法里不一定是构造函数里，能不能访问类的变量？ 9-8 self与实例方法 (08:01) 实例方法 参数第一个必须是self 类下面的实例方法，默认会有一个python所规定的参数，和我们自定义的参数是不同的 定义实例方法需要传入self，但是调用实例方法的时候，不需要传入self. self是python为我们默认传入的，我们自己不需要为self参数来赋值 self的两个特点：定义实例方法的时候，self必须出现调用实例方法的时候，不需要对self传参 self这个概念在其他编程语言里面也是有的其他语言不需要显式的指定这样的一个参数，python特殊，强制要求必须显式指定很多其他语言是使用this来代替python里面的self 只不过python要求：1.必须显式定义2.不叫this，叫self self可以不叫self,可以改成任意喜欢的名字 class Student(): sum = 0 name = ‘xixi’ age = 0 def __init__(this, name, age): this.name = name this.age = age def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)print(student1.dict) 输出：{‘name’: ‘nana’, ‘age’: 18} 总结：通过this一样可以指定这样的一个对象的实例变量，但是python建议使用self这样的实例变量 显胜于隐 self就是当前调用某一个方法的对象 student1.do_homework()此时do_homework()的self指的就是student1 student2.do_homework()self指的就是student2 self只和对象有关，和类没有关系谁调用了这个方法，self就指代的就是谁 self代表的是实例，而不是类self.name = name 就是对这样的一个实例变量在赋值 实例变量 和对象 也就是类生成的实例相关联的变量 实例方法 和对象 也就是类生成的实例相关联的方法，也就是实例可以调用的方法最大特点：第一个参数需要传入self self可以改成别的，所以self不是关键字 9-9 在实例方法中访问实例变量与类变量 (16:00) 思维导图 理清楚思路和结构 Python类：变量：类变量 实例变量方法：实例方法 后面类方法，静态方法构造函数 这节实践 需要认真听 方法代表类的行为，而变量代表刻画类的特征 方法和变量的关系：方法需要对变量做一系列的运算或者逻辑上的操作，最终改变变量的状态，这是方法最本质的意义方法也可以完全不操作变量 少数 方法操作变量，方法如何访问变量？ 实例方法操作实例变量，因为它们都是和对象相关联的self.实例变量 给实例变量赋值 或读取实例变量 实例方法内部可以访问类变量吗？ 1.构造方法可以看作特殊的实例方法，调用方式和实例方法不一样，调用构造函数是通过类后面的括号的方式来调用。调用普通的实例方法是通过对象.实例方法的方式如student1.do_homework()的方式来调用的2.它们的意义不一样，实例方法主要用来描述类的行为，构造函数主要用来初始化类的各种特征的 不加self也可以访问实例变量print(self.name)print(name) 但是最好用self.name，经典错误如下： self.name 和 name 是不等价的 self.name 与 nameclass Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age print(self.name) print(name) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18) 输出：nananana 产生了假象 构造函数的形参改为name1 self.name 与 nameclass Student(): sum = 0 def __init__(self, name1, age): self.name = name1 self.age = age print(self.name) print(name) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18) 输出：此时报错了nanaTraceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 99, in student1 = Student(‘nana’, 18) File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 94, in init print(name)NameError: name ‘name’ is not defined self.name 读取了对象的实例变量，并且打印出来了name 并不是读取了对象的实例变量，它读取的是形参name 另一个误解：dict的查找机制 print(self.name) print(self.__dict__) nana{‘name’: ‘nana’, ‘age’: 18}确实有name的变量存在但是打印print(name) 依然会出错要强调的误区：实例方法内部，想通过一个name去进行dict的查找是不可以的，这种查找机制仅仅在通过在类的对象的外部调用的时候是可以的 实例方法如何访问类变量： 实例方法如何访问类变量class Student(): sum = 0 def __init__(self, name1, age): self.name = name1 self.age = age print(sum) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18) 输出；把python内置函数sum给打印出来了 class Student(): sum1 = 0 def __init__(self, name1, age): self.name = name1 self.age = age print(sum1) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)sum改成sum1,输出：Traceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 116, in student1 = Student(‘nana’, 18) File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 111, in init print(sum1)NameError: name ‘sum1’ is not defined 如何在类的外部访问类变量呢？print(Studeng.name) 类名.类变量来访问类变量外部可以这样使用，内部也可以这样使用 class Student(): sum1 = 0 def __init__(self, name1, age): self.name = name1 self.age = age print(Student.sum1) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)print(Student.sum1) print(Student.sum1)，输出：00 实例方法访问类变量的第二种方式：class Student(): sum1 = 0 def __init__(self, name1, age): self.name = name1 self.age = age # print(Student.sum1) print(self.__class__.sum1) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18) 输出：0 9-10 类方法 (15:40) 为什么会有类方法以及类方法的作用： 如何在方法里操作sum? self.class.sum，这是数字，别忘了str(self.class.sum)每当实例化一个对象，sum的基数就会增加1 class Student(): sum = 0 def __init__(self, name1, age): self.name = name1 self.age = age # print(Student.sum1) self.__class__.sum += 1 print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) def do_homework(self): print(&apos;homework&apos;) student1 = Student(‘nana’, 18)student2 = Student(‘betty’, 17)student3 = Student(‘jessica’, 16) 当前班级学生总数为：1当前班级学生总数为：2当前班级学生总数为：3 类变量和实例变量的区别？ 类变量的作用类变量的正确使用场景是什么 可以放在别的方法，但是要调用那个方法才能生效 class Student(): sum = 0 def __init__(self, name1, age): self.name = name1 self.age = age # print(Student.sum1) # self.__class__.sum += 1 # print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) def do_homework(self): print(&apos;homework&apos;) self.__class__.sum += 1 print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) student1 = Student(‘nana’, 18)student1.do_homework()student2 = Student(‘betty’, 17)student2.do_homework()student3 = Student(‘jessica’, 16)student3.do_homework() 输出：homework当前班级学生总数为：1homework当前班级学生总数为：2homework当前班级学生总数为：3 类方法专门用来操作类变量的类方法如何定义： def plus_sum(cls): pass 这个就是类方法吗？不是的 @classmethod def plus_sum(cls): pass cls就是class的简写，@classmethod是装饰器 类方法的作用是用来操作和类相关的一些变量 @classmethod def plus_sum(cls): cls.sum += 1 print(cls.sum)完成了最简单的类方法 类方法如何调用：类方法只和类相关，和对象没什么关系class Student(): sum = 0 def __init__(self, name1, age): self.name = name1 self.age = age # self.__class__.sum += 1 # print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) def do_homework(self): print(&apos;homework&apos;) @classmethod def plus_sum(cls): cls.sum += 1 print(cls.sum) student1 = Student(‘nana’, 18)Student.plus_sum()student2 = Student(‘nana’, 18)Student.plus_sum()student3 = Student(‘jessica’, 16)Student.plus_sum() 输出：123cls可以叫别的名字吗？可以，实例方法可以更改，类方法也可以更改 @classmethod def plus_sum(self): self.sum += 1 print(self.sum) 输出：123是一样的 是不是实例方法和self cls没有关系 类方法和实例方法的区别：类与对象的区别实例方法关联的是对象这样一个事物而类方法关联的是类本身 可以在实例方法操作类变量，还要类方法做什么？ self与cls的区别self代表student1 student2 student3等对象cls代表Student这个类 重要！！！可以用对象来调用类方法吗？可以 class Student(): sum = 0 def __init__(self, name1, age): self.name = name1 self.age = age self.__class__.sum += 1 print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) def do_homework(self): print(&apos;homework&apos;) @classmethod def plus_sum(self): self.sum += 1 print(self.sum) student1 = Student(‘nana’, 18)student1.plus_sum() 输出：当前班级学生总数为：12 但是最好不要。逻辑上说不通 9-11 静态方法 (09:08) python静态方法应该如何调用？ @staticmethod def add(x,y): pass 静态方法和实例方法 类方法有什么不同？ 最大不同：不需要强制传入self或者cls; 就是一个普通的方法； 一个函数要成为静态方法需要加@staticmethod装饰器 如何调用静态方法？对象和类都可以调用静态方法 class Student(): sum = 0 def __init__(self, name1, age): self.name = name1 self.age = age self.__class__.sum += 1 print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) def do_homework(self): print(&apos;homework&apos;) @classmethod def plus_sum(self): self.sum += 1 print(self.sum) @staticmethod def add(x, y): print(&apos;This is a static method&apos;) student1 = Student(‘nana’, 18)student1.add(1, 2)Student.add(1, 2) 输出：当前班级学生总数为：1This is a static methodThis is a static method 静态方法内部可以访问类变量吗？可以 @staticmethod def add(x, y): print(Student.sum) print(&apos;This is a static method&apos;) 输出：1This is a static method1This is a static method 为什么不是1和2？？？ 类方法和静态方法可以访问实例变量吗？class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.__class__.sum += 1 # print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) def do_homework(self): print(&apos;homework&apos;) @classmethod def plus_sum(self): print(self.name) @staticmethod def add(x, y): print(self.name) student1 = Student(‘nana’, 18)student1.add(1, 2)Student.add(1, 2)student1.plus_sum()Student.plus_sum() Traceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 216, in student1.add(1, 2) File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 213, in add print(self.name)NameError: name ‘self’ is not defined会报错 class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.__class__.sum += 1 # print(&apos;当前班级学生总数为：&apos; + str(self.__class__.sum)) def do_homework(self): print(&apos;homework&apos;) @classmethod def plus_sum(self): print(name) @staticmethod def add(x, y): print(name) student1 = Student(‘nana’, 18)student1.add(1, 2)Student.add(1, 2)student1.plus_sum()Student.plus_sum() Traceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 216, in student1.add(1, 2) File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 213, in add print(name)NameError: name ‘name’ is not defined还是会报错 Traceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 218, in student1.plus_sum() File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 209, in plus_sum print(self.name)AttributeError: type object ‘Student’ has no attribute ‘name’报错 静态方法作用：能用静态方法的地方，都可以用静态方法来代替类方法更方便，而且静态方法还需要写类的全称才能访问类变量建议静态方法不要经常使用，而且静态方法和面向对象的关联性非常弱 当一个函数和类和对象没有什么关联的时候，可以使用静态方法 Python的静态方法和其他语言的静态方法是不太一样的C#的静态方法更像python里的类方法 思维导图总结 9-12 成员可见性：公开和私有 (23:12) 并非python所独有，绝大多数面向对象的语言都有 成员： 变量和方法 类是有内外之分的 类的外部 类的内部： student1 = Student(‘nana’, 18)student1.do_homework()类的外部调用和访问类的方法 def do_homework(self): self.do_english_homework() print(&apos;homework&apos;) def do_english_homework(self): print(&apos;do english homework&apos;) 在类的内部调用 不仅方法有内外调用的区别，类变量和实例变量也有内外调用的区别。 类的最基本作用：封装代码 类的不安全 class Student(): sum = 0 def __init__(self, name, age, score): self.name = name self.age = age self.score = score self.__class__.sum += 1 def do_homework(self): self.do_english_homework() print(&apos;homework&apos;) def do_english_homework(self): print(&apos;do english homework&apos;) @classmethod def plus_sum(self): pass @staticmethod def add(x, y): pass student1 = Student(‘nana’, 18) student1.add(1, 2)Student.add(1, 2)student1.plus_sum()Student.plus_sum()student1.score = -1 student1.score = -1造成类的内部数据的不安全只应该由类的内部的方法来操作类内部的变量class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.score = 0 self.__class__.sum += 1 def marking(self, score): self.score = score print(self.name + &apos;同学本次开始分数为:&apos; + str(self.score)) def do_homework(self): self.do_english_homework() print(&apos;homework&apos;) def do_english_homework(self): print(&apos;do english homework&apos;) @classmethod def plus_sum(self): pass @staticmethod def add(x, y): pass student1 = Student(‘nana’, 18)student1.marking(90) 输出：nana同学本次开始分数为:90 student1.marking(-1)student1.score = -1 通过方法的话，可以判断的class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.score = 0 self.__class__.sum += 1 def marking(self, score): if score &lt; 0: # score = 0 return &apos;不能够给别人打负分&apos; self.score = score print(self.name + &apos;同学本次开始分数为:&apos; + str(self.score)) def do_homework(self): self.do_english_homework() print(&apos;homework&apos;) def do_english_homework(self): print(&apos;do english homework&apos;) @classmethod def plus_sum(self): pass @staticmethod def add(x, y): pass student1 = Student(‘nana’, 18)result = student1.marking(-1) student1.score = -1print(result) 输出：不能够给别人打负分 编程提倡的规范：一个类下面的数据变量是类非常重要的特征数据如果要修改类的特征值，不应该直接通过访问变量的方式来改变变量的状态，正确：所有对于类变量的更改都应该通过方法来完成，几乎所有语言都是这样来提倡的 在类的外部依然可以对类的变量进行赋值，解决？涉及成员的可见性问题 student1.score = -1成员可见性是公开的 public 类的外部可以直接访问 赋值或者读取 私有 private 类的外部无法直接访问 赋值或者读取 如何变成私有的？ 其他语言，成员的可见性是非常明显的标记 python如何决定成员的可见性？ 如果变量或者方法开头没有双下划线，都会认为变量或者方法是公开的 变量或者方法开头加了双下划线，就会认为变量或者方法是私有的 def __marking(self, score): if score &lt; 0: # score = 0 return &apos;不能够给别人打负分&apos; self.score = score print(self.name + &apos;同学本次开始分数为:&apos; + str(self.score)) Traceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 255, in result = student1.marking(-1)AttributeError: ‘Student’ object has no attribute ‘marking’因为它已经变成了私有方法 为什么构造函数的前面有双下划线，我们依然可以在外部调用？构造函数属于python特有的函数，确实是可以从外部访问的init前面有双下划线，后面也有双下划线。这样的命名方式，python不会认为是私有的 def __marking__(self, score): if score &lt; 0: # score = 0 return &apos;不能够给别人打负分&apos; self.score = score print(self.name + &apos;同学本次开始分数为:&apos; + str(self.score)) 输出：不能够给别人打负分 如果想让变量或者方法变成私有的，只需在前面加双下划线，不要在后面也加双下划线 init 这种命名风格是python内置变量的命名庚哥 score加双下划线：class Student(): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.__score = 0 self.__class__.sum += 1 def __marking__(self, score): if score &lt; 0: # score = 0 return &apos;不能够给别人打负分&apos; self.__score = score print(self.name + &apos;同学本次开始分数为:&apos; + str(self.__score)) def do_homework(self): self.do_english_homework() print(&apos;homework&apos;) def do_english_homework(self): print(&apos;do english homework&apos;) @classmethod def plus_sum(self): pass @staticmethod def add(x, y): pass student1 = Student(‘nana’, 18)result = student1.marking(-1)student1.__score = -1print(result) 输出：不能够给别人打负分 并没有报错，为什么__score没有报错？ 9-13 没有什么是不能访问 (09:21) student1.score = -1print(student1.score)输出：不能够给别人打负分-1 赋值和读取都成功了 student1.__score = -1，实际上是给student1新添加了一个实例变量python是可以通过.的方式来新添加一个新的实例变量 student1 = Student(‘nana’, 18)student2 = Student(‘nana’, 18) student1.score = -1print(student1.score) print(student2.__score) 输出：-1Traceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 266, in print(student2.score)AttributeError: ‘Student’ object has no attribute ‘score’ student1.score = -1 并不是类里面定义的score python动态语言的特性 student1.score = -1print(student1.dict)输出：{‘name’: ‘nana’, ‘age’: 18, ‘_Studentscore’: 0, ‘__score’: -1}打印dict的内置变量 ‘_Studentscore’就是我们原来定义的私有变量双下划线scorepython存储私有变量的时候会做一个更改 ‘__score’是我们在外面动态添加的 为什么python访问私有变量或者方法的时候会报错呢？‘_Student__score’ 因为python已经把私有变量或者方法的名字给改了 print(student2.dict) {‘name’: ‘nana’, ‘age’: 18, ‘_Studentscore’: 0}没有’score’ python对私有变量的保护机制 所以不能通过动态的方式来访问私有变量，否则还是能访问到 严格意义上来将，python是没有私有变量的print(student2._Studentscore)输出；0可以通过这种方式来访问私有变量：_Studentscore间接读取私有变量 9-14 继承. (24:55) 面向对象三大特性：继承性 封装性 多态性最难讲清楚 变化最多的反而是封装性继承性 多态性 实实在在的语法问题 封装性抽象程度非常高 继承性作用：类由两大块组成：类的特征和类的行为 1.避免我们定义重复的方法和重复的变量； 学生本质是一个人 学生和人构成继承关系 Python虽然可以在一个模块写多个类，但是建议一个模块只写一个类 一个文件定义一个类，结构上也是比较清晰的 from people import Peopleclass Student(People): sum = 0 def __init__(self, name, age): self.name = name self.age = age self.__score = 0 self.__class__.sum += 1 def do_homework(self): print(&apos;english homework&apos;) 类括号里的空格是用来填写类的父类的 People是Student的父类而Student是People的子类 什么是有意义的继承？ from human import Humanclass Student(Human): # sum = 0 # def __init__(self, name, age): # self.name = name # self.age = age # self.__score = 0 # self.__class__.sum += 1 def do_homework(self): print(&apos;english homework&apos;) student1 = Student()print(student1.sum)print(Student.sum)print(student1.name)print(student1.age) 输出；Traceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 286, in student1 = Student()TypeError: init() missing 2 required positional arguments: ‘name’ and ‘age’构造函数的继承性 print(Student.sum)输出：0 TypeError: init() missing 2 required positional arguments: ‘name’ and ‘age’实例化类的时候还是需要传入name和age 父类需要传入name和age，所以实例化子类的时候也需要传入name和age from human import Humanclass Student(Human): # sum = 0 # def __init__(self, name, age): # self.name = name # self.age = age # self.__score = 0 # self.__class__.sum += 1 def do_homework(self): print(&apos;english homework&apos;) student1 = Student(‘nana’, 18)print(student1.sum)print(Student.sum)print(student1.name)print(student1.age) 00nana18 类变量和实例变量同样可以被子类继承 student1.get_name()输出：nana 子类也能继承父类的方法 python可以多继承 一个子类可以继承多个父类 一个子类只能有一个父类 单继承 单继承可以让整个的继承链条变得清晰 子类需要有自己的特征变量 子类调用父类的构造函数；class Student(Human): # sum = 0 def __init__(self, school, name, age): self.school = school Human.__init__(name, age) 显式调用父类的构造函数 from human import Humanclass Student(Human): # sum = 0 def __init__(self, school, name, age): self.school = school Human.__init__(name, age) # self.__score = 0 # self.__class__.sum += 1 def do_homework(self): print(&apos;english homework&apos;) student1 = Student(‘牛逼小学’,’nana’, 18) print(student1.sum)print(Student.sum)print(student1.school)print(student1.name)print(student1.age) 输出：Traceback (most recent call last): File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 286, in student1 = Student(‘牛逼小学’,’nana’, 18) File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 278, in init Human.init(name, age)TypeError: init() missing 1 required positional argument: ‘age’ Human.__init__(self,name, age) 输出：牛逼小学nana18 为什么要传self? 9-15 子类方法调用父类方法：super关键字 (15:17) Human.init(self,name, age)类去调用实例方法是说不通的但是python不限制你强行这么做 对象调用实例方法不需要传入self Student.do_homework()输出： File “C:/Users/Administrator/PycharmProjects/Native_Spider/student.py”, line 292, in Student.do_homework()TypeError: do_homework() missing 1 required positional argument: ‘self’ Student.do_homework(student1)输出：english homework Student.do_homework(student1)但是这种方式可笑 并且多此一举 Student.do_homework(‘’)没有报错 通过类来调用，self变成普通参数了 更改类的代码的行为，是非常不可取的 编程 开闭原则 扩展代码是开放的，但是更改本身代码是关闭的 第二种调用构造函数的方式： class Student(Human): # sum = 0 def __init__(self, school, name, age): self.school = school # Human.__init__(self,name, age) super(Student, self).__init__(name,age) 输出：牛逼小学nana18 super关键字并不是只能用在构造函数里面 class Human(): sum = 0 def init(self, name, age): self.name = name self.age = age def get_name(self): print(self.name) def do_homework(self): print(&apos;This ia a parent method&apos;) from human import Humanclass Student(Human): # sum = 0 def __init__(self, school, name, age): self.school = school # Human.__init__(self,name, age) super(Student, self).__init__(name,age) # self.__score = 0 # self.__class__.sum += 1 def do_homework(self): print(&apos;english homework&apos;) student1 = Student(‘牛逼小学’,’nana’, 18)student1.do_homework() 输出： english homework 子类和父类出现同名方法，python不会报错，会优先调用子类方法 def do_homework(self): super(Student, self).do_homework() print(&apos;english homework&apos;) 输出：This ia a parent methodenglish homework super也可以用于普通的实例方法 第10章 正则表达式与JSON 10-1 初识正则表达式 (13:24)10-2 元字符与普通字符 (09:10)10-3 字符集 (07:31)10-4 概括字符集 (10:33)10-5 数量词 (05:43)10-6 贪婪与非贪婪 (05:09)10-7 匹配0次1次或者无限多次 (10:45)10-8 边界匹配符 (07:59)10-9 组 (03:36)10-10 匹配模式参数 (06:46)10-11 re.sub正则替换 (16:02)10-12 把函数作为参数传递 (07:52)10-13 search与match函数 (09:02)10-14 group分组 (12:55)10-15 一些关于学习正则的建议 (04:36)10-16 理解JSON (10:28)10-17 反序列化 (16:28)10-18 序列化 (10:51)10-19 小谈JSON、JSON对象与JSON字符串 (09:29) 第11章 Python的高级语法与用法 11-1 枚举其实是一个类 (08:54)11-2 枚举和普通类相比有什么优势 (08:48)11-3 枚举类型、枚举名称与枚举值 (05:11)11-4 枚举的比较运算 (04:33)11-5 枚举注意事项 (05:18)11-6 枚举转换 (05:59)11-7 枚举小结 (09:09)11-8 进阶内容开场白 (06:00)11-9 一切皆对象 (12:45)11-10 什么是闭包 (15:41)11-11 一个事例看看闭包 (04:24)11-12 闭包的经典误区 (08:08)11-13 出个题,用闭包解决! (04:29)11-14 我先用非闭包解决一下 (09:21)11-15 再用闭包解决一下_ (09:55)11-16 小谈函数式编程 (08:10) 第12章 函数式编程： 匿名函数、高阶函数、装饰器 12-1 lambda表达式。 (10:12)12-2 三元表达式 (06:30)12-3 map (07:30)12-4 map与lambda (06:41)12-5 reduce (14:19)12-6 filter (06:15)12-7 命令式编程vs函数式编程 (06:47)12-8 装饰器 一 (13:04)12-9 装饰器 二 (08:43)12-10 装饰器 三 (08:46)12-11 装饰器 四 (07:38)12-12 装饰器 五 (07:35)12-13 装饰器 六 (08:43) 第13章 实战：原生爬虫 13-1 分析抓取目的确定抓取页面 (07:30)13-2 整理爬虫常规思路 (09:38)13-3 VSCode中调试代码 (11:57)13-4 HTML结构分析基本原则二条 (08:23)13-5 数据提取层级分析及原则三 (13:07)13-6 正则分析HTML (15:12)13-7 正则分析获取名字和人数 (06:05)13-8 数据精炼 (06:53)13-9 sorted 排序 (12:11)13-10 案例总结 (19:10) 第14章 Pythonic与Python杂记 14-1 导言 (05:30)14-2 用字典映射代替switch case语句 (13:57)14-3 列表推导式 (09:36)14-4 字典如何编写列表推导式 (05:19)14-5 None (08:53)14-6 对象存在并不一定是True (05:56)14-7 len与bool内置方法 (10:16)14-8 装饰器的副作用 (08:27)]]></content>
  </entry>
  <entry>
    <title><![CDATA[为元组元素命名提高程序可读性]]></title>
    <url>%2F2017%2F12%2F01%2F%E4%B8%BA%E5%85%83%E7%BB%84%E5%85%83%E7%B4%A0%E5%91%BD%E5%90%8D%E6%8F%90%E9%AB%98%E7%A8%8B%E5%BA%8F%E5%8F%AF%E8%AF%BB%E6%80%A7%2F</url>
    <content type="text"><![CDATA[数据格式固定，意味字段总数是确定的，字段相对位置也是确定的。这时可以使用元组存储信息。元组优势存储空间小，访问速度快。但是使用元组的时候会遇到一些问题，访问是，使用引索index访问，大量引索降低程序可读性。 student = (‘Jim’, 16, ‘male’, ‘jim8721@gmail.com’) nameprint student[0] ageif student[1] &gt;= 18:… sexif student[2] == ‘male’:… 程序将大量充斥着0 1 2 3这样的一些引索值，这些数字对于程序的维护是不利的，因为很难一眼就看出这些0 1 2代表是什么含义 C语言宏定义 #define NAME 0 #define AGE 1 c语言的枚举类型enum Studnet { NAME, AGE, SEX}它们分别等于0 1 2这些数字 方案1： 定义类似于其他语言的枚举类型，也就是定义一系列数值常量。方案2：使用标准库中collections.nametuple替代内置tuple 方案1： 定义类似于其他语言的枚举类型，也就是定义一系列数值常量。 python没有真正的枚举类型，但是我们可以定义一些常量，访问元组的字段就可以用这些常量了。NAME = 0AGE = 1SEX = 2EMAIL = 3 student = (‘Jim’, 16, ‘male’, ‘jim8721@gmail.com’) nameprint student[NAME] ageif student[AGE] &gt;= 18:… sexif student[SEX] == ‘male’:… 列表拆包的形式：NAME. AGE, SEX, EMAIL = xrange(4) student = (‘Jim’, 16, ‘male’, ‘jim8721@gmail.com’) nameprint student[NAME] ageif student[AGE] &gt;= 18:… sexif student[SEX] == ‘male’:…会分别把0 1 2 3赋给这些变量 方案2：使用标准库中collections.nametuple替代内置tuple from collections import nametuple Student = nametuple(‘Student’, [‘name’, ‘age’, ‘sex’, ‘email’]) nametuple函数能返回一个内置元组的子类第一个参数，新创建的类起个名字然后传入每个引索的名字相当于类的工厂 s就是一个命名的元组 s = Student(‘Jim’, 16, ‘male’, ‘jim@gmail.com’)sStudent(name=’Jim’, age=16, sex=’male’, email=’jim@gmail.com’) 位置传参 还可以使用关键字传参s2 = Student(name=’Jim’, age=16, sex=’male’, email=’jim@gmail.com’) s.names.ages.sex 我们以类对象的形式访问元组，整个开销仅比普通元组大了一点点 并且s是内置元组的子类 任何使用普通元组的地方都可以使用nametuple from collections import nametupleTraceback (most recent call last): File ““, line 1, in ImportError: cannot import name nametuple???? 这是怎么回事？]]></content>
  </entry>
  <entry>
    <title><![CDATA[列表字典集合中根据条件筛选数据]]></title>
    <url>%2F2017%2F11%2F30%2F%E5%88%97%E8%A1%A8%E5%AD%97%E5%85%B8%E9%9B%86%E5%90%88%E4%B8%AD%E6%A0%B9%E6%8D%AE%E6%9D%A1%E4%BB%B6%E7%AD%9B%E9%80%89%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[实际案例； 过滤掉列表[3,9,-1,10,20,-2…中的负数] 筛出字典{‘Lilei’:79, ‘Jim’:88, ‘Lucy’:92…}中值高于90的项 筛出集合{77，89，32，20…}中能被3整除的元素 通用做法=迭代：123456789101112131415161718192021222324252627282930data = [1, 5, -3, -2, 6, 0 , 9]res = []for x in data: 依次迭代列表中每个项 if x &gt;= 0: 条件判断 res.append(x)print res函数式编程 解析等解决方案：## 列表#### filter函数 filter(lambda x: x &gt;=0, data)#### 列表解析 [x for x in data if x &gt;= 0]## 字典#### 字典解析 &#123;k:v for k,v in d.iteritems() if v &gt; 90&#125;## 集合#### 集合解析 &#123;x for x in s if x % 3 == 0&#125;生成随机列表 from random import randintdata = [randint(-10, 10) for _ in xrange(10)]过滤掉其中负数### filter函数filter(lambda x: x &gt;= 0, data) C:\Windows\system32&gt;python2Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. from random import randintdata = [randint(-10, 10) for _ in xrange(10)]data[-1, 8, 9, 9, 4, 1, -9, 7, -7, -1]filter? File ““, line 1 filter? ^SyntaxError: invalid syntaxfilter help(filter)Help on built-in function filter in module builtin: filter(…) filter(function or None, sequence) -&gt; list, tuple, or string Return those items of sequence for which function(item) is true. If function is None, return the items that are true. If sequence is a tuple or string, return the same type, else return a list. filter(lambda x: x &gt;= 0, data)[8, 9, 9, 4, 1, 7] 123### 列表解析 [x for x in data if x &gt;= 0][8, 9, 9, 4, 1, 7]``` filter和列表解析对比 timeit filter(lambda x:x &gt;= 0, data) timeit filter(lambda x: x &gt;= 0, data) File ““, line 1 timeit filter(lambda x: x &gt;= 0, data) ^SyntaxError: invalid syntaxtimeitTraceback (most recent call last): File ““, line 1, in NameError: name ‘timeit’ is not definedhelp(timeit)Traceback (most recent call last): File ““, line 1, in NameError: name ‘timeit’ is not definedimport timeittimeit filter(lambda x: x &gt;= 0, data) File ““, line 1 timeit filter(lambda x: x &gt;= 0, data) ^SyntaxError: invalid syntaxtimeit(‘filter(lambda x: x &gt;= 0, data)’)Traceback (most recent call last): File ““, line 1, in TypeError: ‘module’ object is not callablefrom timeit import timeittimeit(‘filter(lambda x: x &gt;= 0, data)’)Traceback (most recent call last): File ““, line 1, in File “C:\Python27\lib\timeit.py”, line 237, in timeit return Timer(stmt, setup, timer).timeit(number) File “C:\Python27\lib\timeit.py”, line 202, in timeit timing = self.inner(it, self.timer) File ““, line 6, in innerNameError: global name ‘data’ is not definedfrom random import randintdata = [randint(-10, 10) for in xrange(10)]data[-10, -6, 8, 2, -6, -1, -3, -6, -9, -7]filter(lambda x: x &gt;= 0, data)[8, 2]from timeit import timeittimeit(‘filter(lambda x: x &gt;= 0, data)’)Traceback (most recent call last): File ““, line 1, in File “C:\Python27\lib\timeit.py”, line 237, in timeit return Timer(stmt, setup, timer).timeit(number) File “C:\Python27\lib\timeit.py”, line 202, in timeit timing = self.inner(it, self.timer) File ““, line 6, in innerNameError: global name ‘data’ is not definedfrom timeit import timeitfrom random import randinttimeit(‘filter(lambda x: x &gt;= 0, data=[randint(-10, 10) for in xrange(10)])’)Traceback (most recent call last): File ““, line 1, in File “C:\Python27\lib\timeit.py”, line 237, in timeit return Timer(stmt, setup, timer).timeit(number) File “C:\Python27\lib\timeit.py”, line 202, in timeit timing = self.inner(it, self.timer) File ““, line 6, in innerNameError: global name ‘randint’ is not definedtimeit filter(lambda x:x &gt;= 0, [-1, 8, 9, 9, 4, 1, -9, 7, -7, -1]) File ““, line 1 timeit filter(lambda x:x &gt;= 0, [-1, 8, 9, 9, 4, 1, -9, 7, -7, -1]) ^SyntaxError: invalid syntaxtimeit(‘filter(lambda x: x &gt;= 0, [-1, 8, 9, 9, 4, 1, -9, 7, -7, -1])’)4.256596223743941 timeit(‘[x for x in [-1, 8, 9, 9, 4, 1, -9, 7, -7, -1] if x &gt;= 0]’)2.2746409958225513 通常认为列表解析更快一点，首选也是列表解析这两种方式都远快于迭代的方式 字典d = {x：randint(60, 100) for x in xrange(1, 21)} from random import randintd = {x：randint(60, 100) for x in xrange(1, 21)} File ““, line 1 d = {x：randint(60, 100) for x in xrange(1, 21)} ^SyntaxError: invalid syntaxd = {x: randint(60, 100) for x in xrange(1, 21)}d{1: 67, 2: 87, 3: 79, 4: 76, 5: 78, 6: 61, 7: 75, 8: 97, 9: 83, 10: 71, 11: 94, 12: 87, 13: 65, 14: 88, 15: 90, 16: 91, 17: 76, 18: 73, 19: 67, 20: 77} {k: v for k, v in d.iteritems() if v &gt; 90} from random import randintd = {x：randint(60, 100) for x in xrange(1, 21)} File ““, line 1 d = {x：randint(60, 100) for x in xrange(1, 21)} ^SyntaxError: invalid syntaxd = {x: randint(60, 100) for x in xrange(1, 21)}d{1: 67, 2: 87, 3: 79, 4: 76, 5: 78, 6: 61, 7: 75, 8: 97, 9: 83, 10: 71, 11: 94, 12: 87, 13: 65, 14: 88, 15: 90, 16: 91, 17: 76, 18: 73, 19: 67, 20: 77}{k: v for k, v in d.iteritems() if v &gt; 90}{8: 97, 16: 91, 11: 94} 集合data转换成集合s = set(data)集合解析类似字典解析{x for x in s if x % 3 == 0} from random import randintdata = [randint(-10, 10) for _ in xrange(10)]data[-8, -6, 6, -3, 10, -10, 8, -5, 2, 9]s = set(data){for x in s if x % 3 == 0} File ““, line 1 {for x in s if x % 3 == 0} ^SyntaxError: invalid syntax{x for x in s if x % 3 == 0}set([9, -6, -3, 6])]]></content>
  </entry>
  <entry>
    <title><![CDATA[python错误与异常]]></title>
    <url>%2F2017%2F11%2F28%2Fpython%E9%94%99%E8%AF%AF%E4%B8%8E%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[错误： 语法错误：代码不符合解释器或者编译器语法； 逻辑错误：不完成或者不合法输入或者计算出现问题。 异常：执行过程中出现问题导致程序无法执行 程序遇到逻辑或者算法问题； 运行过程中计算机错误（内存不够或者IO错误） 错误与异常区别：错误：代码运行前的语法或者逻辑错误；语法错误在执行前修改，逻辑错误无法修改。 异常分为两个步骤：1.异常产生，检查到错误且解释器认为是异常，抛出异常； 异常处理，截获一场，忽略或者终止程序处理异常。 python常见错误： a:NameErrorPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. aTraceback (most recent call last):File ““, line 1, in NameError: name ‘a’ is not defined C:\Windows\system32&gt;python2Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. aTraceback (most recent call last): File ““, line 1, in NameError: name ‘a’ is not defined if True: SyntaxErrorPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. if aFile ““, line 1 if a ^ SyntaxError: invalid syntax Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. if a File ““, line 1 if a ^SyntaxError: invalid syntax Python 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. if a:… print a File ““, line 2 print a ^SyntaxError: Missing parentheses in call to ‘print’if a:… print (a)…Traceback (most recent call last): File ““, line 1, in NameError: name ‘a’ is not defined Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. if a:… print a…Traceback (most recent call last): File ““, line 1, in NameError: name ‘a’ is not defined f=open(‘1.txt’): IOErrorPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. f = open(‘test.txt’)Traceback (most recent call last):File ““, line 1, in FileNotFoundError: [Errno 2] No such file or directory: ‘test.txt’ Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. f = open(‘test.txt’)Traceback (most recent call last): File ““, line 1, in IOError: [Errno 2] No such file or directory: ‘test.txt’ 10/0: ZeroDivisionErrorPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. 10/0Traceback (most recent call last):File ““, line 1, in ZeroDivisionError: division by zero Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. 10/0Traceback (most recent call last): File ““, line 1, in ZeroDivisionError: integer division or modulo by zero 5: a = int(‘dd’): ValueError Python 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. a = int(‘100’)a100a = int(‘a100’)Traceback (most recent call last): File ““, line 1, in ValueError: invalid literal for int() with base 10: ‘a100’ Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. a = int(‘100’)a100a = int(‘a100’)Traceback (most recent call last): File ““, line 1, in ValueError: invalid literal for int() with base 10: ‘a100’ ctrl+C 杀掉程序Python 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. import timefor i in range(10):… time.sleep(2)…Traceback (most recent call last): File ““, line 2, in KeyboardInterrupt Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. import timefor i in range(10):… time.sleep(2)…Traceback (most recent call last): File ““, line 2, in KeyboardInterrupt try-except: 异常处理try: try_suiteexcept Exception [e]: exception_block try用来捕获try_suite中的错误，并且将错误交给except处理 except用来处理异常，如果处理异常和设置捕获异常一致，使用exception_block处理异常。不一致会被系统解释器进行处理。错误信息保存在变量域中 vi error.pyaprint “exec over” C:\Users\Administrator\Desktop&gt;python2 error.pyTraceback (most recent call last): File “error.py”, line 1, in aNameError: name ‘a’ is not defined try: aexcept NameError, e: print “catch Error:”, eprint “exec over” C:\Users\Administrator\Desktop&gt;python2 error.pycatch Error: name ‘a’ is not definedexec over C:\Users\Administrator\Desktop&gt; a = 0try: aexcept NameError, e: print “catch Error:”, eprint “exec over” C:\Users\Administrator\Desktop&gt;python2 error.pyexec over except后面没有加任何参数，就是捕捉到所有的异常 try-except捕获异常分析:try: undefexcept: print “catch an except” try: if undefexcept: print “catch an except” try: undefexcept: print “catch an except”C:\Users\Administrator\Desktop&gt;python2 error.pycatch an except try: if undefexcept: print “catch an except”C:\Users\Administrator\Desktop&gt;python2 error.py File “error.py”, line 25 if undef ^SyntaxError: invalid syntax这里并没有捕获到异常，而是打印了语法错误 case1: 可以捕获异常，因为是运行时错误case2；不能捕获异常，因为是语法错误，运行前错误 python代码执行过程，首先由py文件生成二进制的字节码文件，字节码文件由python解释器生成，生成过程python解释器会自动对我们的语法进行检查，发现语法有问题，自动在转化的过程中，就会把错误抛出来。这时代码还没有真正运行，所以说python解释器是没有办法截获到异常的。 try: undefexcept NameError, e: print “catch an except:”, e try: if undefexcept IOError, e: print “catch an except:”, e try: undefexcept NameError, e: print “catch an except:”, eC:\Users\Administrator\Desktop&gt;python2 error.pycatch an except: name ‘undef’ is not defined try: if undefexcept IOError, e: print “catch an except:”, eC:\Users\Administrator\Desktop&gt;python2 error.py File “error.py”, line 35 if undef ^SyntaxError: invalid syntax try: undefexcept IOError, e: print “catch an except:”, eC:\Users\Administrator\Desktop&gt;python2 error.pyTraceback (most recent call last): File “error.py”, line 40, in undefNameError: name ‘undef’ is not defined这里没有捕获到NameError,而是被python解释器给捕获到了 case3: 可以捕获异常，因为设置捕获NameError异常case4: 不能捕获异常，因为设置IOError,不会处理NameError往上抛，抛给python解释器。python解释器会处理这个NameError，终止当前代码的执行 猜数字游戏 import random num = random.randiant(0, 100) while True: guess = int(raw_input(“Enter 1~100:”)) if guess &gt; num: print “guess Bigger:”, guess elif guess &lt; num: print “guess Smaller:”, guess else: print “Guess OK, Game Over” break print “\n”C:\Users\Administrator\Desktop&gt;python2 error.pyTraceback (most recent call last): File “error.py”, line 47, in num = random.randiant(0, 100)AttributeError: ‘module’ object has no attribute ‘randiant’ import random num = random.randint(0, 100) while True: guess = int(raw_input(“Enter 1~100:”)) if guess &gt; num: print “guess Bigger:”, guess elif guess &lt; num: print “guess Smaller:”, guess else: print “Guess OK, Game Over” break print “\n”C:\Users\Administrator\Desktop&gt;python2 error.pyEnter 1~100:80guess Bigger: 80 Enter 1~100:70guess Bigger: 70 Enter 1~100:60guess Bigger: 60 Enter 1~100:50guess Bigger: 50 Enter 1~100:40guess Bigger: 40 Enter 1~100:30guess Bigger: 30 Enter 1~100:20guess Bigger: 20 Enter 1~100:10guess Bigger: 10 Enter 1~100:5guess Bigger: 5 Enter 1~100:1guess Smaller: 1 Enter 1~100:2guess Smaller: 2 Enter 1~100:3Guess OK, Game OverC:\Users\Administrator\Desktop&gt;python2 error.pyEnter 1~100:50guess Smaller: 50 Enter 1~100:40dTraceback (most recent call last): File “error.py”, line 67, in guess = int(raw_input(“Enter 1~100:”))ValueError: invalid literal for int() with base 10: ‘40d’这时代码没法正常执行 允许用户错误输入， try except对代码进行保护 import random num = random.randint(0, 100) while True: try: guess = int(raw_input(“Enter 1~100:”)) except ValueError, e: print “Enter 1~100” if guess &gt; num: print “guess Bigger:”, guess elif guess &lt; num: print “guess Smaller:”, guess else: print “Guess OK, Game Over” break print “\n”C:\Users\Administrator\Desktop&gt;python2 error.pyEnter 1~100:45guess Smaller: 45 Enter 1~100:3dEnter 1~100guess Smaller: 45 Enter 1~100: import random num = random.randint(0, 100) while True: try: guess = int(raw_input(“Enter 1~100:”)) except ValueError, e: print “Enter 1~100” continue if guess &gt; num: print “guess Bigger:”, guess elif guess &lt; num: print “guess Smaller:”, guess else: print “Guess OK, Game Over” break print “\n”continue后面代码就不执行了C:\Users\Administrator\Desktop&gt;python2 error.pyEnter 1~100:35guess Smaller: 35 Enter 1~100:5fEnter 1~100Enter 1~100:]]></content>
  </entry>
  <entry>
    <title><![CDATA[Python Cookbook学习笔记（持续更新）]]></title>
    <url>%2F2017%2F11%2F27%2FPython%20Cookbook%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[第一章 数据结构和算法python内置了很多有用的数据结构，如列表（list）、集合（set）、字典（dictionary）。collections模块包含了针对各种数据结构的解决方案。1.1 将序列分解为单独的变量问题：将一个包含N个元素的元组或序列，分解为N个单独的变量。解决：任何序列（或可迭代的对象）都可以通过一个简单的赋值操作来分解为单独的变量。唯一要求：变量总数和结构要与序列相吻合。python2.7：12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; p=(4,5)&gt;&gt;&gt; x,y=p&gt;&gt;&gt; x4&gt;&gt;&gt; y5&gt;&gt;&gt; data = [&apos;ACME&apos;, 50, 91.1, (2013,12,21)]&gt;&gt;&gt; name, shares, price, date = data0Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name &apos;data0&apos; is not defined&gt;&gt;&gt; name, shares, price, date = data&gt;&gt;&gt; name&apos;ACME&apos;&gt;&gt;&gt; shares50&gt;&gt;&gt; price91.1&gt;&gt;&gt; data[&apos;ACME&apos;, 50, 91.1, (2013, 12, 21)]&gt;&gt;&gt; date(2013, 12, 21)&gt;&gt;&gt; name, shares, price, (year, mon, day) = data&gt;&gt;&gt; name&apos;ACME&apos;&gt;&gt;&gt; year2013&gt;&gt;&gt; mon12&gt;&gt;&gt; day21&gt;&gt;&gt; 元素数量不匹配，错误提示： p=(4,5)x,y,z=pTraceback (most recent call last): File ““, line 1, in ValueError: need more than 2 values to unpack 1不仅仅只是元组或列表，只要对象是可迭代的，就可以执行分解操作，包括字符串，文件，迭代器，生成器。 s = ‘hello’a,b,c,d,e=sa‘h’b‘e’c‘l’d‘l’e‘o’ 1分解操作丢弃某些特定的值。可以选一个用不到的变量名，来作为丢弃的值的名称。 data = [‘ACME’, 50, 91.1, (2012, 12, 21)], shares, price, = datashares50price91.1(2012, 12, 21) (2012, 12, 21) ```但是需要确保选择的变量名没有在其他地方用到过。Nana：_(2012, 12, 21) python3:C:\Windows\system32&gt;pythonPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. ^Z C:\Windows\system32&gt;python2Python 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. p=(4,5)x,y=-pTraceback (most recent call last): File ““, line 1, in TypeError: bad operand type for unary -: ‘tuple’x,y=px4y5data = [‘ACME’, 50, 91.1, (2013,12,21)]name, shares, price, date = data0Traceback (most recent call last): File ““, line 1, in NameError: name ‘data0’ is not definedname, shares, price, date = dataname‘ACME’shares50price91.1data[‘ACME’, 50, 91.1, (2013, 12, 21)]date(2013, 12, 21)name, shares, price, (year, mon, day) = dataname‘ACME’year2013mon12day21p=(4,5)x,y.,z=p File ““, line 1 x,y.,z=p ^SyntaxError: invalid syntaxx,y,z=pTraceback (most recent call last): File ““, line 1, in ValueError: need more than 2 values to unpacks = ‘hello’a,b,c,d,e=aTraceback (most recent call last): File ““, line 1, in NameError: name ‘a’ is not defineda,b,c,d,e=sa‘h’b‘e’c‘l’d‘l’e‘o’data = [‘ACME’, 50, 91.1, (2012, 12, 21)], shares, price, = datashares50price91.1(2012, 12, 21) (2012, 12, 21)^Z C:\Windows\system32&gt;pythonPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. p=(4,5)x,y=px4y5data = [‘ACME’, 50, 91.1, (2013,12,21)]name, shares, price, date = dataname‘ACME’shares50price91.1data[‘ACME’, 50, 91.1, (2013, 12, 21)]date(2013, 12, 21)name, shares, price, (year, mon, day) = dataname‘ACME’year2013mon12day21p=(4,5)x,y,z=pTraceback (most recent call last): File ““, line 1, in ValueError: not enough values to unpack (expected 3, got 2)s = ‘hello’a,b,c,d,e=sa‘h’b‘e’c‘l’d‘l’e‘o’data = [‘ACME’, 50, 91.1, (2012, 12, 21)], shares, price, = datashares50price91.1_(2012, 12, 21) 基本一样，除了ValueError: not enough values to unpack (expected 3, got 2)这个错误提示]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django REST framework相关笔记]]></title>
    <url>%2F2017%2F11%2F08%2FDjango%20REST%20framework%E7%9B%B8%E5%85%B3%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前后端分离技术 restful api 开发 Sentry线上系统的错误日志监控和告警 本地调试远程服务器代码 动态设置permission 文档自动化管理 django rest framework的缓存 Throttling 用户和ip进行限速 线上系统出现的本地系统不能重现的bug api文档管理问题 针对api的访问频率进行限制 数据加入缓存，加速某些api的访问速度 pycharm调试远程服务器代码 docker搭建sentry错误日志监控系统 线上错误栈 发生系统错误时收到邮件通知 第三方框架设置某些api的缓存 Django信号量 独立使用Django的model json web token登录 支付宝沙箱环境 Linux 通过命令启动Pycharm:bin/pycharm.sh文件/bin$ ./pycharm.sh另一种更快捷的方式：Linux建立自己的命令：12345678vim ~/.bashrcshift+G到最后一行alias pycharm=&quot;bash /home/nana/xxx/pycharm-xxx/bin/pycharm.sh&quot;调用pycharm命令 就会完成这个操作注意：编辑完成之后，一定要运行一个source命令来让配置文件生效source ~/.bashrcpycharmpycharm快捷启动方式 Linux安装MySQL```sudo apt-get install mysql-server系统软件要加sudops aux|grep mysqld查看mysql有没有启动成功 进程号 外部navacat连接虚拟机的mysqlbind-address = 0.0.0.0重启mysql: sudo service mysql restartHost xxx is not allowed to connect to this MySQL servermysql权限设置的命令： GRANTxxxxxxx权限赋值命令 flush privileges刷新权限命令 赋值后必须刷新才能生效 navicat安装栏位相当于列 另一个数据库的同步：数据传输如本地数据库和线上数据库的传输还可以把整个数据库转存sql文件，保存数据库-转储sql文件然后需要用到数据库文件的，使用运行sql文件的命令 Linux下同时安装python2和python3指明python版本sudo apt-get install python3.5python命令会进入默认的python2python3会进入python3的版本 python虚拟环境的安装和配置sudo apt-get install python-virtualenvvirtualenv xxx(name)cd xxx/ 进入虚拟环境目录下 注意：目录结构和windows下面不太一样，脚本是在bin目录下面cd bin/启动方式也不一样source activate 启动 进入虚拟环境如何新建python3的虚拟环境？virtualenv -p /usr/bin/python3 xxx(name) python3脚本的目录 pip install virtualenvwrapper注意 不能像windows直接调用mkvirtualenvsudo find / -name virtualenvwrapper.sh 根目录下通过name来寻找virtualenvwrapper.sh这个文件的存放路径因为不同系统可能存放的路径是不一样的配置source文件vim ~/.bashrc指明虚拟环境在哪里source virtualenvwrapper.sh文件的路径export WORKON_HOME=$HOME/.virtualenvssource /home/nana/.local/bin/virtualenvwrapper.sh注意，不同系统的目录不一样source ~/.bashrccd ~/.virtualenvs 查看虚拟环境删掉虚拟环境 rm -rf xxx(name)/新建python3版本的虚拟环境：mkvirtualenv –python=/usr/bin/python3 xxx(name) 调用python3 通过python3来新建我们的虚拟环境mkvirtualenv –python=/usr/bin/python3 xxx(name)python 查看虚拟环境python版本 windows 找不到workon命令尽量不要在Scripts下运行pip install virtualenvwrapper命令，因为xxx vue开发环境搭建nodejs cnpm npm包管理工具，安装nodejs时会有的nodejs 安装.msi类似exe文件 Node.js 中文网测试 node –versioncnpm npm的淘宝镜像 http://npm.taobao.org/node_modulescnpm run dev 前端项目就会独立运行起来注意：如果不同电脑项目运行不起来，就将node_modules包删掉，然后重新install 码云 CODING 私有仓库代码托管 可免费新建私有仓库 Django REST Framework pip install djangorestframeworkpip install markdown django-filter the browsable API??? 解释器实际上就是我们的python.exe文件 WORKON_HOME 新建虚拟环境的存放路径 Enable Django admin 不勾选 ‘OPTIONS’: {‘init_command’: ‘SET default_storage_engine=INNODB;’} # mysql的INNODB引擎 MySQL—python不支持python3 不建议 mysqlclient用来替代MySQL_python的mysqlclient安装出错解决：Unofficial Windows Binaries for Python Extension Packages –window系统的python第三方包文件https://www.lfd.uci.edu/~gohlke/pythonlibs/ db_tools 数据库初始化等等 Mark as source root import sysBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(file))) 获取项目根目录sys.path.insert(0, BASE_DIR)sys.path.insert(0, os.path.join(BASE_DIR, “apps”))sys.path.insert(0, os.path.join(BASE_DIR, “extra_apps”)) user 0719 5.1restfulapi也就是jsonapi???django实现restapi，也就是json的返回 django cbv class base view 代码可重用性比较高 fbv function base view http://python.usyiyi.cn/translate/Django_111/index.html Django1.11.6的中文文档]]></content>
  </entry>
  <entry>
    <title><![CDATA[python操作MySQL数据库]]></title>
    <url>%2F2017%2F10%2F28%2Fpython%E6%93%8D%E4%BD%9CMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[内容简介：Python开发数据库程序的通用接口规范搭建Python开发数据库程序的开发环境了解通用接口规范中的connection、cursor两大对象如何增删改查数据库实例代码演示数据库程序的开发流程 1. 基本知识1.1 前置知识客户端-业务逻辑层-数据访问层(底层、核心技术)-数据库目标：能够开发完整的数据库操作程序内容： Python访问DB的官方接口规范 Python开发DB程序的开发环境 Python访问DB的connection、cursor两大对象 Python执行增删改查操作的实例讲解 完整实例： 银行转账实现1.2 Python DB API介绍背景： 没有Python DB API之前，接口程序混乱。Python DB API： Python访问数据库的统一接口规范。 Module Interface 模块接口 Constructors 构造器 Globals 全局变量 Exceptions 异常Connection Objects connection对象 Connection methodsCursor Objects cursor对象 Cursor attributes Cursor methods 还有其他文档说明 使用Python DB API就能完成针对不同数据库的访问 Python DB API：Python程序数据库连接对象 Connection数据库交互对象 Cursor事故 exceptions 使用Python DB API访问数据库流程：开始-创建connection-获取cursor-执行查询执行命令获取数据处理数据-关闭cursor-关闭connection-结束。 1.3 Python开发MySQL环境Python代码编辑器如Eclipse&amp;Pydev—–&gt;Python代码（包含SQL语句)—–&gt;Python 2.7 客户端 and Python-MySQL connector(https://sourceforge.net/projects/mysql-python/?source=directory)-----&gt;MySQL服务器5.6&lt;—–MySQL客户端工具SQLyog MySQL for PythonMySQL database connector for Python programming 2. python操作数据库对象2.1 Python-数据库连接对象connection连接对象：建立Python客户端与数据库的网络连接创建方法：MySQLdb.Connect(参数)host-字符串: 127.0.0.1是回送地址，指本地机，一般用来测试使用。port-数字：3306 MySQL的默认端口user-字符串 数据库用户名password-字符串 数据库密码db-字符串 数据库名称charset-字符串 连接编码 utf8-防止中文出现乱码 connect对象支持的方法：cursor() 使用该连接创建并返回游标commit() 提交当前事务rollback() 回滚当前事务close() 关闭连接实例代码：1待 连接MYSQL，并且获取了cursor对象 python操作MySQL五大步：1.import 导入标准库；2.建立连接对象connector;3.建立游标对象cursor,并通过游标对象的参数属性来操作数据库;4.操作完毕后，关闭游标对象；5.关闭连接对象 2.2 Python-游标对象cursor游标对象：用于执行查询和获取结果cursor对象支持的方法：execute(op[,args])执行一个数据库查询(select)和命令(update insert delete)如下方式可以对execute方法执行结果进行各种各样的遍历fetchone() 取得结果集的下一行fetchmany(size) 指定size变量，获取结果集的多行fetchall() 获取结果集的剩下的所有行，注意，不是将结果集所有的数据返回，而是将没有遍历过的所有数据返回rowcount 最近一次excute返回数据的行数和影响行数。 注意，这不是方法，它返回excute方法执行的结果数据的行数或影响的行数close（）关闭游标对象 各种方法详解 3. Python增删改查数据库3.1 Python-实例演示select数据3.2 Python-实例演示inset-update-delete数据4. 使用Python实现实例4.1 [Python操作MySQL]银行转账实例-代码流程4.1 [Python操作MySQL]准备数据表和代码编写更详细的资料参考课程]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django开发心得与笔记]]></title>
    <url>%2F2017%2F10%2F28%2FDjango%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97%E4%B8%8E%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Pycharm是专门用于python开发的一款IDE免费版将不能新建django项目Mysql for windows 安装注意：记住注册当初设置的密码，因为连接过程需要用到密码python2.7 windows x86-64 MSI installer 数据库其实安装完成以后， 没有一套管理系统来进行管理会觉得很麻烦， 所以mysql-server实际上就是数据库， 你安装mysql-cli的话才能连接上数据库进行管理， navicat也是用来管理数据库的， 所以一般开发的时候你只需要安装mysql-server， 然后安装navicat来连接数据库进行管理就行了 系统环境变量的设置：ComSpec %SystemRoot%\system32\cmd.exePath：C:\Python27C:\Python27\ScriptsC:\Users\Administrator\AppData\Local\Programs\Python\Python35C:\Users\Administrator\AppData\Local\Programs\Python\Python35\ScriptsC:\Users\Administrator\AppData\Local\Programs\Python\Python36C:\Users\Administrator\AppData\Local\Programs\Python\Python36\Scripts 使用pip install xxx报错UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xc0 in position 0: ordinal not in range(128)1234567891、在Python的安装目录C:/Python27/Lib/里找到mimetypes.py文件；2、打开mimetypes.py文件，在import结束后添加以下代码：import sysreload(sys)sys.setdefaultencoding(&apos;utf-8&apos;)保存文件 重新执行pip即可 pip install virtualenvvirtualenv xxxVirtualenv 安装目录默认放在当前命令的运行目录下 进入和退出虚拟环境: 进入Scripts目录，activate.bat deactivate.bat 上面的方法需要我们知道当前安装的虚拟环境的目录，比较麻烦。下面这种方法可以很方便的进入虚拟环境：pip install virtualenvwrapper(注意windows下virtualenvwrapper-win)mkvirtualenv xxx进入 退出虚拟环境 workon xxx deactivate 百度 virtualenvwrapper 默认虚拟环境目录的设置 pip install timeout问题pip –default-timeout=100 install -U pip或者使用国内镜像 豆瓣源 清华源等 pycharm配置虚拟环境：Interpreter: xxx/python.exepycharm设置快捷键 settings-keymap-Eclipse全局搜索Ctrl+H Run-Edit Configuration-Host:0.0.0.0 通过IP地址访问Invalid HTTP_HOST header: ‘192.168.x.xxx:8000’. You may need to add u’192.168.x.xxx’ to ALLOWED_HOSTS.settings.py文件中有个参数 ALLOWED_HOSTS 你搜索一下， 将这个值设置为 ALLOWED_HOSTS = [‘*’] 就行了 cmd-ipconfig 查看本地IP地址（Linux ifconfig）设置source root navicat创建到数据库的连接 连接测试新建数据库字符集一定要选utf8排序规则：utf8_general_ci设计表新加列-添加栏位navicat执行sql语句 查询-新建查询-输入sql语句-select * from users 所有sql语句都可以在这里执行快速表的复制 复制-粘贴数据库传输：右键-数据传输-源到目标 复制操作还是剪切操作？？？数据库的导入和导出：运行SQL文件 转储SQL文件 先讲一下什么是ping：Ping是Windows下的一个命令。在Unix和Linux下也有这个命令。ping也属于一个通信协议，是TCP/IP协议的一部分利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。应用格式：Ping空格IP地址。该命令还可以加许多参数使用，具体是键入Ping按回车即可看到详细说明。 新建appTools-Run manage.py Task-startapp xxxstatic目录存放静态文件-普通文件夹log文件夹存放日志-普通文件夹media目录存放用户上传的文件-普通文件夹apps文件夹用于存放各个app-可导入的包，含init.py文件 apps mark as source root 不需要输入apps的路径 但是这样命令行会报错No module named xxxBASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(file)))sys.path.insert(0, os.path.join(BASE_DIR, ‘apps’))sys.path.insert(0, os.path.join(BASE_DIR, ‘extra_apps’))这样设置 django请求到响应的完整过程 配置settings连接数据库数据库创建好以后DATABASES = { ‘default’: { ‘ENGINE’: ‘django.db.backends.mysql’, #&apos;NAME&apos;: os.path.join(BASE_DIR, &apos;db.sqlite3&apos;), &apos;NAME&apos;: &apos;xxxxxx&apos;, &apos;USER&apos;: &apos;root&apos;, &apos;PASSWORD&apos;: &apos;xxx&apos;, &apos;HOST&apos;: &apos;127.0.0.1&apos;, } } 生成django默认的数据表Run-Run manage.py Task报错：提示没有mysqlDB 这就是django需要用到的驱动，连接mysql的驱动Error loading MySQLdb module: No module name MySQLdb解决：pip install mysql-pythonpip install mysql-python安装过程报错：error: command ‘C:\Program Files (x86)\Microsoft\Visual Studio\14.0\VC\BIN\amd64\link.exe’ failed with exit status 1120windows安装MySQL驱动的时候都会出现这个问题http://www.lfd.uci.edu/~gohlke/pythonlibs/ 下载对应的驱动下载目录安装对应的驱动 如pip install MySQL_python-1.2.5-cp27-none-win_amd64.whl新玉建议安装pymysql 使用pymysql需要在init中导入模块import pymysqlpymysql.install_as_MySQLdb() makemigrations-migrate 创建url映射url(r’^form/$’, getform) getform不需要括号，只需要名字即可^表示以form为开头,$表示以/结尾的地址配置相应的view来做处理 Ctrl 加鼠标左键 跟踪到render函数里 Alt+左箭头回来不能直接用form.html这个名称，因为django内置了很多html页面，这个名称，django会自动收集django本身的html文件 右键-Refactor-Rename ctrl+s pycharm会自动重启项目 报错TemplateDoesNotExist解决：settings-TEMPLATES-DIRS需要指明templates的目录，django就可以在该目录寻找html文件‘DIRS’: [os.path.join(BASE_DIR, ‘templates’)],12345678910111213141516TEMPLATES = [ &#123; &apos;BACKEND&apos;: &apos;django.template.backends.django.DjangoTemplates&apos;, &apos;DIRS&apos;: [os.path.join(BASE_DIR, &apos;templates&apos;)], &apos;APP_DIRS&apos;: True, &apos;OPTIONS&apos;: &#123; &apos;context_processors&apos;: [ &apos;django.template.context_processors.debug&apos;, &apos;django.template.context_processors.request&apos;, &apos;django.contrib.auth.context_processors.auth&apos;, &apos;django.contrib.messages.context_processors.messages&apos;, &apos;django.core.context_processors.media&apos;, ], &#125;, &#125;,] 页面可以显示，但是样式没有：css路径有问题涉及setting中静态路径的配置默认：STATIC_URL = ‘/static/‘因为没有配置static的根路径之前只是建了个static的文件夹，并没有跟django说该文件夹就是static的路径1234567STATICFILES_DIRS = [ os.path.join(BASE_DIR, &quot;static&quot;)]或者STATICFILES_DIRS = ( os.path.join(BASE_DIR, &quot;static&quot;),) 变量名DIRS复数形式，可以设置多个static的路径 mysql-python与mysqlclient tab与shift+tab 12def __unicode__(self): return self.username 以字符串的形式显示对象，和java里面的类的tostring方法一样 django orm与model CharField类型必须指定默认长度 max-length, 否则会报错CharField must define a ‘max_length’ attribute. MySQL does not allow unique CharFields to hava a max_length &gt; 255.verbose_name=u”昵称” 在后台管理系统会发挥很大的用处EmailField 专门对邮箱做验证 class Meta: verbose_name = &quot;用户信息&quot; 指定数据表显示名称 verbose_name_plural = verbose_name 如果编辑models.py后，makemigrations显示No changes detected in app xxx, 是因为没有将新建的app注册到settings里面 报错：SyntaxError: Non-ASCII character ‘\xe4’ in xxx , but no encoding declared解决：因为model中用到了中文，但文件开头并没有定义好utf编码 * encoding:utf-8 *django默认生成数据表的结构：app名称_model名称 所有小写 如message_usermessage django model的Field类型EmailFieldForeignKeyDateTimeFieldIntegerFieldIPAddressFieldFileFieldImageField 12345678&apos;AutoField&apos;, &apos;BLANK_CHOICE_DASH&apos;, &apos;BigIntegerField&apos;, &apos;BinaryField&apos;,&apos;BooleanField&apos;, &apos;CharField&apos;, &apos;CommaSeparatedIntegerField&apos;, &apos;DateField&apos;,&apos;DateTimeField&apos;, &apos;DecimalField&apos;, &apos;DurationField&apos;, &apos;EmailField&apos;, &apos;Empty&apos;,&apos;Field&apos;, &apos;FieldDoesNotExist&apos;, &apos;FilePathField&apos;, &apos;FloatField&apos;,&apos;GenericIPAddressField&apos;, &apos;IPAddressField&apos;, &apos;IntegerField&apos;, &apos;NOT_PROVIDED&apos;,&apos;NullBooleanField&apos;, &apos;PositiveIntegerField&apos;, &apos;PositiveSmallIntegerField&apos;,&apos;SlugField&apos;, &apos;SmallIntegerField&apos;, &apos;TextField&apos;, &apos;TimeField&apos;, &apos;URLField&apos;,&apos;UUIDField&apos; 该字段可以为空，null=True, blank=True 设定默认值，default=u””自动赋值为空 不指定主键会自动生成id,可以自己指定主键primary_key=True 报错：You are trying to add a non-nullable field ‘xxx’ to xxx without a default解决：default=””有些疑问，主键可以默认设置为空吗？ django的meta信息class Meta: verbose_name = “用户信息” verbose_name_plural = verbose_name db_table = “xxx” 指定数据表名称 ordering = “xxx” 默认排序 query的时候自动排序 加上-就是倒序的排列 就不需要通过order_by了 from .models import xxx .代表同级目录下的文件 all_courses = Course.objects.all().order_by(“-add_time”)objects 类默认的数据表管理器 这个管理器给我们提供了很多方法all()数据库所有的记录返回返回来的all_courses变量是queryset类型，django的内置类型，这种类型可以让我们进行for循环]]></content>
  </entry>
  <entry>
    <title><![CDATA[Django社区网站项目-自学笔记]]></title>
    <url>%2F2017%2F10%2F27%2FDjango%E7%A4%BE%E5%8C%BA%E7%BD%91%E7%AB%99%E9%A1%B9%E7%9B%AE-%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[最近在项目技术上遇到了瓶颈问题，正好看到这个bilibili上的django自学项目有讲到我需要用到django-guadian包，心里好奇，就开始学习折腾这个社区网站自学项目了。 Python是内功，框架是武功。 Python学习手册 Python3.5.1 确保勾选Add Python3.X to PATH 繁花嗅用Python3.4.2做演示 Python虚拟环境的介绍和创建 虚拟环境就是一个文件夹，文件夹里包含了最基本的python运行的文件 python3.3以后的版本，有个内置的命令，很方便就能创建一个虚拟环境 1234567891011121314C:\Windows\system32&gt;pythonPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; ^ZC:\Windows\system32&gt;python -n venv fanhuaxiuUnknown option: -nusage: python [option] ... [-c cmd | -m mod | file | -] [arg] ...Try `python -h&apos; for more information.C:\Windows\system32&gt;python -m venv fanhuaxiuC:\Windows\system32&gt; 我用的python版本是Python 3.5.3， 注意是python -m venv fanhuaxiu，不是python -n venv fanhuaxiu 进入虚拟环境12345678910C:\Windows\system32&gt;cd fanhuaxiuC:\Windows\System32\fanhuaxiu&gt;activate.bat&apos;activate.bat&apos; 不是内部或外部命令，也不是可运行的程序或批处理文件。C:\Windows\System32\fanhuaxiu&gt;cd scriptsC:\Windows\System32\fanhuaxiu\Scripts&gt;activate.bat(fanhuaxiu) C:\Windows\System32\fanhuaxiu\Scripts&gt; 安装django pip install django 缺点速度慢 官网下载安装包，本地直接安装 djangoxx.tar.gz文件下载到fanhuaxiu文件夹下面 与script文件夹同级亲测，这种安装方式也是比较慢的。。。123456789(fanhuaxiu) C:\Windows\System32\fanhuaxiu\Scripts&gt;cd ..(fanhuaxiu) C:\Windows\System32\fanhuaxiu&gt;pip install Django-1.9.13.tar.gzProcessing c:\windows\system32\fanhuaxiu\django-1.9.13.tar.gzInstalling collected packages: Django Running setup.py install for Django ... doneSuccessfully installed Django-1.9.13(fanhuaxiu) C:\Windows\System32\fanhuaxiu&gt; pip freeze 查看当前环境中已经安装的所有库12(fanhuaxiu) C:\Windows\System32\fanhuaxiu&gt;pip freezeDjango==1.9.13 退出虚拟环境，查看系统默认环境下有没有django库，结果是没有的1234567891011C:\Windows\system32&gt;pip freezeastroid==1.5.3colorama==0.3.9isort==4.2.15lazy-object-proxy==1.3.1mccabe==0.6.1mysqlclient==1.3.12pylint==1.7.4pyserial==3.4six==1.11.0wrapt==1.10.11 创建django工程django-admin startproject123(fanhuaxiu) C:\Windows\System32\fanhuaxiu&gt;django-admin startproject communityweb(fanhuaxiu) C:\Windows\System32\fanhuaxiu&gt; django项目文件夹所在 与script文件夹同级 Nana-CMD显示文件目录结构：1234567891011(fanhuaxiu) C:\Windows\System32\fanhuaxiu\communityweb&gt;tree /f卷 OS 的文件夹 PATH 列表卷序列号为 DE02-71F0C:.│ manage.py│└─communityweb settings.py urls.py wsgi.py __init__.py 参考网页 进入项目目录python manage.py runserver12345678910111213(fanhuaxiu) C:\Windows\System32\fanhuaxiu&gt;cd communityweb(fanhuaxiu) C:\Windows\System32\fanhuaxiu\communityweb&gt;python manage.py runserverPerforming system checks...System check identified no issues (0 silenced).You have unapplied migrations; your app may not work properly until they are applied.Run &apos;python manage.py migrate&apos; to apply them.October 27, 2017 - 23:31:15Django version 1.9.13, using settings &apos;communityweb.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CTRL-BREAK. 浏览器访问 http://127.0.0.1:8000/ 或者 localhost:8000显示信息如下：12345It worked!Congratulations on your first Django-powered page.Of course, you haven&apos;t actually done any work yet. Next, start your first app by running python manage.py startapp [app_label].You&apos;re seeing this message because you have DEBUG = True in your Django settings file and you haven&apos;t configured any URLs. Get to work! 创建的django默认网站成功了 如何查看文档？安装Part 1: Requests and responses 第一节完成了，哈哈，其实很多都很熟悉了，但是又重新巩固了下，也学到了不同的用法，温故知新。 下节课 app相关 什么是网站？人 你问他一个问题，他给你一个问题聊天微信，朋友交流，一问一答通过你的电脑，跟远方的电脑互相交流。 远方的电脑-服务器 接收信号 处理信号 然后把接口回馈给你 最复杂的是处理信号 所有的框架万变不离其宗 First steps¶ Are you new to Django or to programming? This is the place to start! From scratch: Overview | InstallationTutorial: Part 1: Requests and responses | Part 2: Models and the admin site | Part 3: Views and templates | Part 4: Forms and generic views | Part 5: Testing | Part 6: Static files | Part 7: Customizing the admin siteAdvanced Tutorials: How to write reusable apps | Writing your first patch for Django Requests and responses 信息的一个进一个出 Models and the admin site Models数据库 Views and templates Views处理数据的过程 处理和渲染的过程 Forms and generic views 表格和输入过程 Testing 测试 Static files 静态文件 Customizing the admin site 后台管理 The model layer¶ Django provides an abstraction layer (the “models”) for structuring and manipulating the data of your Web application. Learn more about it below: Models: Introduction to models | Field types | Indexes | Meta options | Model classQuerySets: Making queries | QuerySet method reference | Lookup expressionsModel instances: Instance methods | Accessing related objectsMigrations: Introduction to Migrations | Operations reference | SchemaEditor | Writing migrationsAdvanced: Managers | Raw SQL | Transactions | Aggregation | Search | Custom fields | Multiple databases | Custom lookups | Query Expressions | Conditional Expressions | Database FunctionsOther: Supported databases | Legacy databases | Providing initial data | Optimize database access | PostgreSQL specific features 数据库 The view layer¶ Django has the concept of “views” to encapsulate the logic responsible for processing a user’s request and for returning the response. Find all you need to know about views via the links below: The basics: URLconfs | View functions | Shortcuts | DecoratorsReference: Built-in Views | Request/response objects | TemplateResponse objectsFile uploads: Overview | File objects | Storage API | Managing files | Custom storageClass-based views: Overview | Built-in display views | Built-in editing views | Using mixins | API reference | Flattened indexAdvanced: Generating CSV | Generating PDFMiddleware: Overview | Built-in middleware classes 分析和逻辑处理 The template layer¶ The template layer provides a designer-friendly syntax for rendering the information to be presented to the user. Learn how this syntax can be used by designers and how it can be extended by programmers: The basics: OverviewFor designers: Language overview | Built-in tags and filters | HumanizationFor programmers: Template API | Custom tags and filters模板 页面显示 Forms¶ Django provides a rich framework to facilitate the creation of forms and the manipulation of form data. The basics: Overview | Form API | Built-in fields | Built-in widgetsAdvanced: Forms for models | Integrating media | Formsets | Customizing validation严格说属于template表单输入信息 The development process¶ Learn about the various components and tools to help you in the development and testing of Django applications: Settings: Overview | Full list of settingsApplications: OverviewExceptions: Overviewdjango-admin and manage.py: Overview | Adding custom commandsTesting: Introduction | Writing and running tests | Included testing tools | Advanced topicsDeployment: Overview | WSGI servers | Deploying static files | Tracking code errors by email开发处理的过程 The admin¶ Find all you need to know about the automated admin interface, one of Django’s most popular features: Admin siteAdmin actionsAdmin documentation generator自带后台处理默认简单的后台管理系统 Security¶ Security is a topic of paramount importance in the development of Web applications and Django provides multiple protection tools and mechanisms: Security overviewDisclosed security issues in DjangoClickjacking protectionCross Site Request Forgery protectionCryptographic signingSecurity Middleware网络安全问题 数据库安全问题 Internationalization and localization¶ Django offers a robust internationalization and localization framework to assist you in the development of applications for multiple languages and world regions: Overview | Internationalization | Localization | Localized Web UI formatting and form inputTime zones国际化和本地化 Performance and optimization¶ There are a variety of techniques and tools that can help get your code running more efficiently - faster, and using fewer system resources. Performance and optimization overview性能优化 Python compatibility¶ Django aims to be compatible with multiple different flavors and versions of Python: Jython supportPython 3 compatibilitypython兼容 Geographic framework¶ GeoDjango intends to be a world-class geographic Web framework. Its goal is to make it as easy as possible to build GIS Web applications and harness the power of spatially enabled data.地理框架 根据不同的方位来访问网站不同的地区不同的显示内容 Common Web application tools¶ Django offers multiple tools commonly needed in the development of Web applications: Authentication: Overview | Using the authentication system | Password management | Customizing authentication | API ReferenceCachingLoggingSending emailsSyndication feeds (RSS/Atom)PaginationMessages frameworkSerializationSessionsSitemapsStatic files managementData validation内置的工具 (fanhuaxiu) C:\Windows\System32\fanhuaxiu\communityweb&gt;tree /f卷 OS 的文件夹 PATH 列表卷序列号为 DE02-71F0C:.│ db.sqlite3│ manage.py│└─communityweb │ settings.py │ urls.py │ wsgi.py │ init.py │ └─pycache settings.cpython-35.pyc urls.cpython-35.pyc wsgi.cpython-35.pyc init.cpython-35.pyc db.sqlite3 这个文件是项目运行后生成的 数据库简单的数据库 只是处理小的项目可以用的数据库大项目 装一些商业的数据库 启动项目python manage.py runserver把网站运行起来 不同端口 如9000 打开1234567891011(fanhuaxiu) C:\Windows\System32\fanhuaxiu\communityweb&gt;python manage.py runserver 9000Performing system checks...System check identified no issues (0 silenced).You have unapplied migrations; your app may not work properly until they are applied.Run &apos;python manage.py migrate&apos; to apply them.October 28, 2017 - 10:24:23Django version 1.9.13, using settings &apos;communityweb.settings&apos;Starting development server at http://127.0.0.1:9000/Quit the server with CTRL-BREAK. 什么是app 一个app就是一个功能的集成 创建app123(fanhuaxiu) C:\Windows\System32\fanhuaxiu\communityweb&gt;python manage.py startapp blog(fanhuaxiu) C:\Windows\System32\fanhuaxiu\communityweb&gt; manage.py 相当于一个路由器一样的12345678910111213141516171819202122232425262728293031323334353637383940(fanhuaxiu) C:\Windows\System32\fanhuaxiu\communityweb&gt;tree /f卷 OS 的文件夹 PATH 列表卷序列号为 DE02-71F0C:.│ db.sqlite3│ manage.py│├─blog│ │ admin.py│ │ apps.py│ │ models.py│ │ tests.py│ │ views.py│ │ __init__.py│ ││ └─migrations│ __init__.py│└─communityweb │ settings.py │ urls.py │ wsgi.py │ __init__.py │ └─__pycache__ settings.cpython-35.pyc urls.cpython-35.pyc wsgi.cpython-35.pyc __init__.cpython-35.pyc├─blog│ │ admin.py│ │ apps.py│ │ models.py│ │ tests.py│ │ views.py│ │ __init__.py│ ││ └─migrations│ __init__.py 最基础的文件夹和文件 搭好一个架子 │ └─migrations│ init.py数据库修改记录数据库操作记录 init.py文件夹当模块一样来用 admin.py后台操作的命令 apps.py django1.9以后出现的关于app参数的设置以前设置到整个项目settings.py models.py数据库 tests.py 测试 views.py 业务逻辑 下节课 数据库 django的数据库配置，安装和数据模型的创建 数据库本质上就是一个一个的文件 数据的形式 django不生成数据，它就是数据的搬运工 djaong更高效的保存处理查询数据库 https://docs.djangoproject.com/en/1.11/ref/databases/ PostgreSQLhttps://www.postgresql.org/ Download-Windows-Download 老师 9.5.3 exe postgresql-9.5.9-win64.exe 我下载的是9.5.9放在scripts同级，点击安装它我安装PostgreSQL的时候出现问题了，报错 Error In InstallerInstaller Payload initialization failed. This is likely due to an incomplete or corrupt downloaded file.PostgreSQL-10.0-1-win64-bigsql.exe换了这个版本的还是不行PostgreSQL-9.6.5-1-win64-bigsql.exe这个版本的也还是不行。。。难道跟我的项目的目录有关系？C:\Windows\System32\fanhuaxiu关机重启 移动项目目录试下问题解决了，醉了，好吧Components-pgDEVOps/pgAdmin3 我都安装了password 8……..ndata directory:C:\PostgreSQL\data\pg96port:5432pgDEVOps: administractor username and password: 2503605326@qq.com 8……..n 安装过程又报错了Problem running post-install step. Installation may not complete correctly. Error with configuration or permissions. Please see log file for more information. 好吧，先把下面的那个连接的安装看下是不是因为要先安装psycopg2 注意：PostgreSQL notes¶ Django supports PostgreSQL 9.3 and higher. psycopg2 2.5.4 or higher is required, though the latest release is recommended. psycopg2 连接django和PostgreSQL的桥梁 http://initd.org/psycopg/ 针对python版本进行安装http://www.stickpeople.com/projects/python/win-psycopg/ (fanhuaxiu) C:\Windows\System32\fanhuaxiu\communityweb&gt;pythonPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 16:02:32) [MSC v.1900 64 bit (AMD64)] on win32Type “help”, “copyright”, “credits” or “license” for more information. &gt;我的python版本是Python 3.5.3 Virtual Environment Installation Notes Method 1 Do not double-click the package to run. Instead, use easy_install from either setuptools or distribute. Assuming the installer is downloaded to C:\ and the virtual environment is in C:\virtualenv, the command would look something like: C:> C:\virtualenv\Scripts\activate.bat(virtualenv) C:> easy_install psycopg2-2.6.2.win32-py2.7-pg9.5.3-release.exe Method 2 The same method as mentioned below with Zope can be used to extract the binaries and place them in the \Lib\site-packages\ directory. python跟数据库连接的包老师是2.6.1的版本 我的是2.6.2的版本 (fanhuaxiu) C:\Users\Administrator\Downloads\fanhuaxiu&gt;easy_install psycopg2-2.6.2.win-amd64-py3.5-pg9.5.3-release.exeProcessing psycopg2-2.6.2.win-amd64-py3.5-pg9.5.3-release.exepsycopg2.tests.pycache.test_module.cpython-35: module references filepsycopg2.tests.pycache.test_types_basic.cpython-35: module references filepsycopg2.pycache._psycopg.cp35-win_amd64.cpython-35: module references filecreating ‘C:\Users\ADMINI~1\AppData\Local\Temp\easy_install-rpfwruyp\psycopg2-2.6.2-py3.5-win-amd64.egg’ and adding ‘C:\Users\ADMINI~1\AppData\Local\Temp\easy_install-rpfwruyp\psycopg2-2.6.2-py3.5-win-amd64.egg.tmp’ to itcreating c:\users\administrator\appdata\local\programs\python\python35\lib\site-packages\psycopg2-2.6.2-py3.5-win-amd64.eggExtracting psycopg2-2.6.2-py3.5-win-amd64.egg to c:\users\administrator\appdata\local\programs\python\python35\lib\site-packagesAdding psycopg2 2.6.2 to easy-install.pth file Installed c:\users\administrator\appdata\local\programs\python\python35\lib\site-packages\psycopg2-2.6.2-py3.5-win-amd64.eggProcessing dependencies for psycopg2==2.6.2Finished processing dependencies for psycopg2==2.6.2 pip freeze 查看当前环境安装了什么东西 管理数据库的界面 创建django的数据模型 django没有数据，它保存的只是数据模型，真正的数据保存在数据库里面 数据模型 模子套出来 django内置创建模型的工具 类创建模型 Fields 字段 sublime编辑器 settings.py 中间件 https://docs.djangoproject.com/en/1.11/topics/settings/ Full List Of Settinghttps://docs.djangoproject.com/en/1.11/ref/settings/ 修改数据库设定]]></content>
  </entry>
  <entry>
    <title><![CDATA[SS in Ubuntu14.04]]></title>
    <url>%2F2017%2F10%2F20%2FSS%20in%20Ubuntu14.04%2F</url>
    <content type="text"><![CDATA[To set ss in your computer, please follow below steps:First register in http://banwagong.cn/ and select and create an account.Details: http://blog.csdn.net/win_turn/article/details/51559867 After set up your ss, please follow below steps to create one in your computer(My computer is Ubuntu14.04): Installation:sudo apt-get updatesudo apt-get install python-pipsudo apt-get install python-setuptools m2crypto pip install shadowsocks(or sudo pip install sxxxxxxxxxs) Download:download sxxxxxxxxxs.json file from email attachment to your computer example: /home/nana/Documents/sxxxxxxxxxs.json SwitchyOmega Setting:Visit https://pan.baidu.com/s/1gfHupSR and download SwitchyOmega plugin;Visit chrome://extensions/ in your Chrome browser and drag SwitchyOmega plugin to your extensions; Click proxy in the left sidebar and make sure below setting is applied:Protocol: SOCKS5Server: 127.0.0.1Port: 1080 And click Apply Changes Auto Switch:Click the SwitchyOmega plugin in your browser and make sure it’s auto switch. Startup in your terminal:sslocal -c /xxx/xxx/xxx/sxxxxxxxxxs.jsonexample: sslocal -c /home/nana/Documents/sxxxxxxxxxs.json]]></content>
      <categories>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu14.04,nginx,uwsgi部署django项目]]></title>
    <url>%2F2017%2F10%2F14%2FUbuntu14.04%20nginx%20uwsigi%E9%83%A8%E7%BD%B2django%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[自从我这Windows党在配置Ubuntu14.04开发环境的时候，把Ubuntu系统折腾奔溃了以后（千万不要手贱重装Ubuntu14.04的python, 升级或者多python共存都可以，就是不要把默认的卸载了重装，活生生的教训摆在眼前）。我就暗下决心要在家用虚拟机装个Ubuntu14.04好好折腾。趁着周末，抽出了几个小时，折腾了下如何用Ubuntu14.04,nginx,uwsgi部署django项目。中间遇到了几个坑。幸好这几个坑都没有很深，看来平时要多折腾多部署。今晚有点晚了，博客内容有点乱，下次复习部署的过程再把博客细节完善好。 1.下载虚拟机和Ubuntu1.1 下载Ubuntu14.04Ubuntu14.04官网下载ubuntu-14.04.5-desktop-amd64.iso 1.2 下载虚拟机下载虚拟机VM Workstation 14 虚拟机名称：ubuntu14 虚拟磁盘存储单个文件 2.安装nginx sudo apt-get install nginx 安装nginxps aux|grep nginx 查看进程是否启动 ifconfig查看IP地址，浏览器打开Welcome to nginx!欢迎界面安装成功！ 3.安装mysqlsudo apt-get install mysql-server提示输入mysql密码安装完成会自动启动mysql-serverps aux|grep mysql 查看进程是否启动 有个进程叫/usr/sbin/mysqld，就是mysql的server进入mysql mysql -u root -pshow databases; 记得分号 vim - gnome 安装sudo vim /etc/mysql/my.cnf 注意这里是my.cnf文件了mysql的ip绑定 bind-addressi 进入编辑模式bind-address = 127.0.0.1更改为：bind-address = 0.0.0.0 就可以通过IP地址来连接我们的mysql这里更改只是为了windows连接进来，真正部署尽量用127.0.0.1，这样就不会让我们的端口暴露出来。esc退出编辑模式，按shift加冒号，wq退出并保存配置文件修改完后，重启mysqlsudo service mysql restartmysql重启成功 ifconfig查看ip地址192.168.77.128navicat 主机名或ip地址填写ip地址连接测试 1130 - Host ‘192.168.77.128’ is not allowed to connect to this MySQL server默认mysql是只允许本地连接 mysql -h 192.168.77.128 -u root -pERROR 1130 (HY000): Host ‘192.168.77.128’ is not allowed to connect to this MySQL server用host连接也是不允许的 修改配置让所有ip地址都可以连接进来呢？GRANT ALL PRIVILEGES ON . TO ‘root’@’192.168.77.128’ IDENTIFIED BY ‘8xxxxxxxxn’ WITH GRANT OPTION;GRANT ALL PRIVILEGES ON . TO ‘root’@’%’ IDENTIFIED BY ‘8xxxxxxxxn’ WITH GRANT OPTION;.-指的是所有表 这里也可以指明某张表% 所有IP都可以访问123456789101112131415161718nana@ubuntu:~/Music$ mysql -u root -pEnter password: Welcome to the MySQL monitor. Commands end with ; or \g.Your MySQL connection id is 39Server version: 5.5.57-0ubuntu0.14.04.1 (Ubuntu)Copyright (c) 2000, 2017, Oracle and/or its affiliates. All rights reserved.Oracle is a registered trademark of Oracle Corporation and/or itsaffiliates. Other names may be trademarks of their respectiveowners.Type &apos;help;&apos; or &apos;\h&apos; for help. Type &apos;\c&apos; to clear the current input statement.mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;8xxxxxxxxn&apos; WITH GRANT OPTION;Query OK, 0 rows affected (0.00 sec)mysql&gt; 生效了 还需要刷新权限mysql&gt; FLUSH PRIVILEGES;Query OK, 0 rows affected (0.00 sec) 连接测试-连接成功这样就能通过主机的navicat去连接虚拟机上的数据库了 新建数据库 完成数据库的连接配置 Mysql配置完成 4.安装虚拟环境不管开发还是生产环境都尽量用虚拟环境来做nana@ubuntu:~/Music$ pip install virtualenv程序“pip”尚未安装。 您可以使用以下命令安装：12345678910111213141516171819202122232425262728sudo apt-get install python-pipnana@ubuntu:~/Music$ sudo apt-get install python-pipnana@ubuntu:~/Music$ pip install virtualenvDownloading/unpacking virtualenv Downloading virtualenv-15.1.0-py2.py3-none-any.whl (1.8MB): 1.8MB downloadedInstalling collected packages: virtualenvCleaning up...Exception:Traceback (most recent call last): File &quot;/usr/lib/python2.7/dist-packages/pip/basecommand.py&quot;, line 122, in main status = self.run(options, args) File &quot;/usr/lib/python2.7/dist-packages/pip/commands/install.py&quot;, line 283, in run requirement_set.install(install_options, global_options, root=options.root_path) File &quot;/usr/lib/python2.7/dist-packages/pip/req.py&quot;, line 1436, in install requirement.install(install_options, global_options, *args, **kwargs) File &quot;/usr/lib/python2.7/dist-packages/pip/req.py&quot;, line 672, in install self.move_wheel_files(self.source_dir, root=root) File &quot;/usr/lib/python2.7/dist-packages/pip/req.py&quot;, line 902, in move_wheel_files pycompile=self.pycompile, File &quot;/usr/lib/python2.7/dist-packages/pip/wheel.py&quot;, line 206, in move_wheel_files clobber(source, lib_dir, True) File &quot;/usr/lib/python2.7/dist-packages/pip/wheel.py&quot;, line 193, in clobber os.makedirs(destsubdir) File &quot;/usr/lib/python2.7/os.py&quot;, line 157, in makedirs mkdir(name, mode)OSError: [Errno 13] Permission denied: &apos;/usr/local/lib/python2.7/dist-packages/virtualenv-15.1.0.dist-info&apos;Storing debug log for failure in /home/nana/.pip/pip.log 安装虚拟环境报错命令前面加sudo，问题解决了sudo pip install virtualenv sudo pip install virtualenvwrapper安装完virtualenvwrapper之后，实际上workon命令是不能用的需要编辑一个文件主目录下面有个bashrc文件，编辑这个文件：vim ~/.bashrcexport WORKON_HOME=$HOME/.virtualenvssource /home/nana/.local/bin/virtualenvwrapper.sh（WORKON_HOME virtualenvwrapper集中保存虚拟环境的路径 凡是通过mkvirtualenv命令创建的虚拟环境都会放到这里来） nana@ubuntu:~/Music$ source ~/.bashrcbash: /home/nana/.local/bin/virtualenvwrapper.sh: 没有那个文件或目录nana@ubuntu:~/Music$ vim ~/.bashrcnana@ubuntu:~/Music$ source ~/.bashrcbash: /home/nana/.local/usr/bin/virtualenvwrapper.sh: 没有那个文件或目录 export WORKON_HOME=$HOME/.virtualenvssource /usr/local/bin/virtualenvwrapper.sh改成这样，注意Ubuntu14.04这里要这样写http://blog.csdn.net/yilovexing/article/details/72961594123456789101112131415161718192021222324252627282930nana@ubuntu:~/Music$ vim ~/.bashrcnana@ubuntu:~/Music$ source ~/.bashrcvirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/premkprojectvirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/postmkprojectvirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/initializevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/premkvirtualenvvirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/postmkvirtualenvvirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/prermvirtualenvvirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/postrmvirtualenvvirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/predeactivatevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/postdeactivatevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/preactivatevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/postactivatevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/get_env_detailsnana@ubuntu:~/Music$ workonnana@ubuntu:~/Music$ nana@ubuntu:~/Music$ mkvirtualenv molNew python executable in /home/nana/.virtualenvs/mol/bin/pythonInstalling setuptools, pip, wheel...done.virtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/mol/bin/predeactivatevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/mol/bin/postdeactivatevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/mol/bin/preactivatevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/mol/bin/postactivatevirtualenvwrapper.user_scripts creating /home/nana/.virtualenvs/mol/bin/get_env_details(mol) nana@ubuntu:~/Music$ pip listDEPRECATION: The default format will switch to columns in the future. You can use --format=(legacy|columns) (or define a format=(legacy|columns) in your pip.conf under the [list] section) to disable this warning.pip (9.0.1)setuptools (36.6.0)wheel (0.30.0) 虚拟环境创建完成了 5.安装开发包本地开发包导出来1234567891011121314151617181920212223242526272829303132333435363738394041424344454647C:\Windows\system32&gt;workonPass a name to activate one of the following virtualenvs:==============================================================================article_spiderFreshShopmolnanablogportuspy22scrapypy2scrapypy3scrapypython_learningtestvir2tp_supplier_platformC:\Windows\system32&gt;workon mol(mol) C:\Windows\System32&gt;pip listPackage Version---------------------- ---------certifi 2017.4.17chardet 3.0.4Django 1.9.8django-crispy-forms 1.6.1django-formtools 2.0django-pure-pagination 0.3.0django-simple-captcha 0.4.6DjangoUeditor 1.8.143future 0.16.0httplib2 0.9.2idna 2.5MySQL-python 1.2.5olefile 0.44Pillow 4.2.0pip 9.0.1requests 2.18.1setuptools 36.0.1six 1.10.0urllib3 1.21.1wheel 0.29.0xlrd 1.0.0XlsxWriter 0.9.8xlwt 1.2.0(mol) C:\Windows\System32&gt;pip freeze &gt; requirements.txt(mol) C:\Windows\System32&gt; 拷贝这个文件的内容到虚拟机的新建文件里 虚拟机里通过requriemtns来安装它从这个文件读取，然后一个一个的开发包安装到虚拟环境里面 报错12345678910sh: 1: mysql_config: not foundTraceback (most recent call last): File &quot;&lt;string&gt;&quot;, line 1, in &lt;module&gt; File &quot;/tmp/pip-build-O8vP9C/MySQL-python/setup.py&quot;, line 17, in &lt;module&gt; metadata, options = get_config() File &quot;setup_posix.py&quot;, line 43, in get_config libs = mysql_config(&quot;libs_r&quot;) File &quot;setup_posix.py&quot;, line 25, in mysql_config raise EnvironmentError(&quot;%s not found&quot; % (mysql_config.path,))EnvironmentError: mysql_config not found https://stackoverflow.com/questions/5178292/pip-install-mysql-python-fails-with-environmenterror-mysql-config-not-foundsudo apt-get install libmysqlclient-dev 发现某个开发包安装比较慢，Ctrl C停掉整个过程，单独安装这个开发包，使用豆瓣源加速安装。http://pypi.douban.com/simple/https://www.douban.com/note/302711300/注意不要用https 用豆瓣源下载pillow失败 清华源也是同样的问题 正常安装先 Failed building wheel for MySQL-pythonsudo apt-get install libmysqlclient-dev 发现我之前安装了这个，是不是可以暂时不安装呢Failed building wheel for mysqlclient 又报错了，然后发现两个报错都提到这个fatal error: Python.h: 没有那个文件或目录解决方法：sudo apt-get install python-dev 6.启动项目查看项目是否可以启动123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293nana@ubuntu:~/Music/MOl$ python manage.py runserverTraceback (most recent call last): File &quot;manage.py&quot;, line 8, in &lt;module&gt; from django.core.management import execute_from_command_lineImportError: No module named django.core.managementnana@ubuntu:~/Music/MOl$ workonmolnana@ubuntu:~/Music/MOl$ workon mol(mol) nana@ubuntu:~/Music/MOl$ python manage.py runserverPerforming system checks.../home/nana/.virtualenvs/mol/local/lib/python2.7/site-packages/DjangoUeditor/urls.py:11: RemovedInDjango110Warning: django.conf.urls.patterns() is deprecated and will be removed in Django 1.10. Update your urlpatterns to be a list of django.conf.urls.url() instances instead. url(r&apos;^controller/$&apos;,get_ueditor_controller)System check identified no issues (0 silenced).You have unapplied migrations; your app may not work properly until they are applied.Run &apos;python manage.py migrate&apos; to apply them.October 15, 2017 - 11:21:49Django version 1.9.8, using settings &apos;MOl.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C.^CUnhandled exception in thread started by &lt;function wrapper at 0x7fc6d4f4e320&gt;Traceback (most recent call last): File &quot;/home/nana/.virtualenvs/mol/local/lib/python2.7/site-packages/django/utils/autoreload.py&quot;, line 234, in wrapper filename = traceback.extract_tb(tb)[-1][0]TypeError: &apos;NoneType&apos; object is not callable(mol) nana@ubuntu:~/Music/MOl$ python manage.py makemigrations/home/nana/.virtualenvs/mol/local/lib/python2.7/site-packages/DjangoUeditor/urls.py:11: RemovedInDjango110Warning: django.conf.urls.patterns() is deprecated and will be removed in Django 1.10. Update your urlpatterns to be a list of django.conf.urls.url() instances instead. url(r&apos;^controller/$&apos;,get_ueditor_controller)No changes detected(mol) nana@ubuntu:~/Music/MOl$ python manage.py migrate/home/nana/.virtualenvs/mol/local/lib/python2.7/site-packages/DjangoUeditor/urls.py:11: RemovedInDjango110Warning: django.conf.urls.patterns() is deprecated and will be removed in Django 1.10. Update your urlpatterns to be a list of django.conf.urls.url() instances instead. url(r&apos;^controller/$&apos;,get_ueditor_controller)Operations to perform: Apply all migrations: xadmin, users, courses, admin, sessions, auth, captcha, contenttypes, organization, operationRunning migrations: Rendering model states... DONE Applying contenttypes.0001_initial... OK Applying contenttypes.0002_remove_content_type_name... OK Applying auth.0001_initial... OK Applying auth.0002_alter_permission_name_max_length... OK Applying auth.0003_alter_user_email_max_length... OK Applying auth.0004_alter_user_username_opts... OK Applying auth.0005_alter_user_last_login_null... OK Applying auth.0006_require_contenttypes_0002... OK Applying auth.0007_alter_validators_add_error_messages... OK Applying users.0001_initial... OK Applying admin.0001_initial... OK Applying admin.0002_logentry_remove_auto_add... OK Applying captcha.0001_initial... OK Applying organization.0001_initial... OK Applying organization.0002_auto_20170712_2240... OK Applying organization.0003_auto_20170723_2037... OK Applying organization.0004_auto_20170725_1731... OK Applying organization.0005_teacher_image... OK Applying courses.0001_initial... OK Applying courses.0002_auto_20170712_2240... OK Applying courses.0003_course_course_org... OK Applying courses.0004_course_category... OK Applying courses.0005_course_tag... OK Applying courses.0006_video_url... OK Applying courses.0007_video_learn_times... OK Applying courses.0008_course_teacher... OK Applying courses.0009_auto_20170728_2318... OK Applying courses.0010_course_is_banner... OK Applying courses.0011_auto_20170826_1149... OK Applying operation.0001_initial... OK Applying organization.0006_teacher_age... OK Applying organization.0007_courseorg_tag... OK Applying sessions.0001_initial... OK Applying users.0002_banner_emailverifyrecord... OK Applying users.0003_auto_20170708_1210... OK Applying users.0004_auto_20170708_1523... OK Applying users.0005_auto_20170708_2220... OK Applying users.0006_auto_20170802_0829... OK Applying xadmin.0001_initial... OK Applying xadmin.0002_log... OK Applying xadmin.0003_auto_20160715_0100... OK(mol) nana@ubuntu:~/Music/MOl$ python manage.py runserverPerforming system checks.../home/nana/.virtualenvs/mol/local/lib/python2.7/site-packages/DjangoUeditor/urls.py:11: RemovedInDjango110Warning: django.conf.urls.patterns() is deprecated and will be removed in Django 1.10. Update your urlpatterns to be a list of django.conf.urls.url() instances instead. url(r&apos;^controller/$&apos;,get_ueditor_controller)System check identified no issues (0 silenced).October 15, 2017 - 11:22:58Django version 1.9.8, using settings &apos;MOl.settings&apos;Starting development server at http://127.0.0.1:8000/Quit the server with CONTROL-C. 记得要在虚拟环境里这样弄记得migrate 192.168.77.128:8000 但是这里显示的是nginx192.168.77.128:8080 网站访问成功，但是静态文件没有显示成功 navicat数据传输 从主机传输到虚拟机 7.uwsgi方式启动项目uwsgi方式启动起来 安装uwsgi pip install uwsgiSuccessfully installed uwsgi-2.0.15 测试uwsgi 用http的方式测试uwsgi –http :8080 –module MOl.wsgi注意命令要写对http://192.168.77.128:8080/ 浏览器访问 没问题 1234567891011121314151617181920212223242526272829303132# the upstream component nginx needs to connect toupstream django &#123;# server unix:///path/to/your/mysite/mysite.sock; # for a file socketserver 127.0.0.1:8000; # for a web port socket (we&apos;ll use this first)&#125;# configuration of the serverserver &#123;# the port your site will be served onlisten 80;# the domain name it will serve forserver_name 你的ip地址 ; # substitute your machine&apos;s IP address or FQDNcharset utf-8;# max upload sizeclient_max_body_size 75M; # adjust to taste# Django medialocation /media &#123; alias 你的目录/Mol/media; # 指向django的media目录&#125;location /static &#123; alias 你的目录/Mol/static; # 指向django的static目录&#125;# Finally, send all non-media requests to the Django server.location / &#123; uwsgi_pass django; include uwsgi_params; # the uwsgi_params file you installed&#125;&#125; 你的ip地址 ip地址或者域名都可以 1234567891011121314151617181920212223242526272829303132# the upstream component nginx needs to connect toupstream django &#123;# server unix:///path/to/your/mysite/mysite.sock; # for a file socketserver 127.0.0.1:8000; # for a web port socket (we&apos;ll use this first)&#125;# configuration of the serverserver &#123;# the port your site will be served onlisten 80;# the domain name it will serve forserver_name 192.168.77.128 ; # substitute your machine&apos;s IP address or FQDNcharset utf-8;# max upload sizeclient_max_body_size 75M; # adjust to taste# Django medialocation /media &#123; alias /home/nana/Music/MOl/media; # 指向django的media目录&#125;location /static &#123; alias /home/nana/Music/MOl/static; # 指向django的static目录&#125;# Finally, send all non-media requests to the Django server.location / &#123; uwsgi_pass django; include uwsgi_params; # the uwsgi_params file you installed&#125;&#125; 建立软链接sudo cp uc_nginx.conf /etc/nginx/conf.d/ 重启nginxsudo service nginx restart ps aux|grep nginx 查看nginx是否已经启动 所有static文件全部放到一个目录下面来 collectstatic会将所有static文件放到一个目录上面来 STATICFILES_DIRS注释掉，这两个不能同时存在 甚至Xadmin的静态文件也会拷贝到这里来 8.uwsgi的socket方式启动项目新建uwsgi的配置文件 uwsgi不对外暴露http方式 通过读配置文件来启动我们的uwsgisocket方式启动，而不是http方式来启动 socket比http方式传输效率更快 nginx指明转发到8000端口，所有uwsgi也要指明8000端口123456789101112131415161718192021222324# mysite_uwsgi.ini file[uwsgi]# Django-related settings# the base directory (full path)chdir = /home/nana/Music/MOl# Django&apos;s wsgi filemodule = MOl.wsgi# the virtualenv (full path)# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 10# the socket (use the full path to be safesocket = 127.0.0.1:8000# ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = truevirtualenv = /home/nana/.virtualenvs/mol# logto = /tmp/mylog.log 注意这里要注释掉 保存后，通过uwsgi来启动 http://192.168.77.128/ 访问网站 没有问题 注意这里不要加上8000端口完成uwsgi的配置完成ip地址访问 测试域名访问修改hosts文件 uwsgi的重启 参考教程]]></content>
      <categories>
        <category>部署</category>
      </categories>
      <tags>
        <tag>部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[404和500页面配置]]></title>
    <url>%2F2017%2F10%2F14%2F404%E5%92%8C500%E9%A1%B5%E9%9D%A2%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[生产环境需要配置404和500页面，如果没有配置404和500页面，给用户的体验不是很好。 Django配置404和500页面具体如下： templates设置404和500页面拷贝到templates目录下。 View设置views.py:1234567891011121314def page_not_found(request): # 全局404处理函数 from django.shortcuts import render_to_response response = render_to_response(&apos;404.html&apos;, &#123;&#125;) response.status_code = 404 return responsedef page_error(request): # 全局500处理函数 from django.shortcuts import render_to_response response = render_to_response(&apos;500.html&apos;, &#123;&#125;) response.status_code = 500 return response url设置根urls.py文件设置：123# 全局404和500页面配置handler404 = &apos;users.views.page_not_found&apos;handler500 = &apos;users.views.page_error&apos; settings设置123settings.py：Debug=False （生成环境部署的时候必须改为False,否则报错提示信息可能会泄漏网站的关键信息)ALLOWED_HOSTS = [&apos;*&apos;] (所有客户端都可以连接) 注意，Debug=False的情况下，Django是不会再帮你代管static文件的访问。部署的时候Apache或者Nginx会自动代理这些静态文件。如下这种方式就会失效：1234STATIC_URL = &apos;/static/&apos;STATICFILES_DIRS = ( os.path.join(BASE_DIR, &quot;static&quot;),) 我们给static配置url处理函数：setting.py:STATIC_ROOT = os.path.join(BASE_DIR, ‘static’)urls.py:url(r’^static/(?P.*)$’, serve, {“document_root”: STATIC_ROOT}), 重启系统]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学上网，开阔眼界]]></title>
    <url>%2F2017%2F10%2F12%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%EF%BC%8C%E5%BC%80%E9%98%94%E7%9C%BC%E7%95%8C%2F</url>
    <content type="text"><![CDATA[Bandwagon Host VPS Hosting - Services - My Services - KiwiVM Control Panel - Shadowsocks Server - Install Shadowsocks Server - Go back(when Completed) - Remember your encryption/port/passaprd for Shadowsocks. 启动系统代理 - 全局模式 好了，可以科学上网，开阔眼界了。 下次有空折腾下多用户的设置，今天太晚了，好困啊。]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python2.7项目升级python3.6]]></title>
    <url>%2F2017%2F10%2F12%2Fpython2-7%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7python3-6%2F</url>
    <content type="text"><![CDATA[新建python3虚拟环境首先新建python3.6的虚拟环境，关于python2和python3虚拟环境的共存，之前的博客电脑多版本Python共存的方法。这里就不讲了。 重装虚拟环境安装的开发包 打包安装：requirements.txtpip freeze &gt; requirements.txtpip install -r requirements.txt搭配豆瓣源清华源加速安装。 单个安装：或者一个一个开发包安装，比较可控。注意：mysqlclient(支持python3和python2)替换MySQL-Python(只支持python2.7)xlrd/XlwtWriter/xlwt - Excel输入有关 Project Interpreter配置虚拟环境开发包升级加了新功能的要合并 setting配置django升级到1.11的，记得将django.core.context_processors.media更改成django.template.context_processors.media(django版本不同的原因) models.py里面定义的unicode()函数改成str()函数]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python之千千问]]></title>
    <url>%2F2017%2F10%2F05%2Fpython%E4%B9%8B%E5%8D%83%E5%8D%83%E9%97%AE%2F</url>
    <content type="text"><![CDATA[python中如何交换两个变量的值？The Zen Of Python Python之禅是什么？type()函数的作用？ 2/2 和 2//2的区别？Python如何表示10、2、8、16进制？Python中不同进制之间如何转换？ 布尔类型：是不是只有数字1表示True 0表示False？bool(None)返回值？python中如何表示复数？‘Hello World’不同方式截取W？‘Hello World’不同方式截取World？‘Hello World’[6:20]返回值？‘Hello World’[6:0]返回值？\n和\r的区别？ 如何定义只有一个元素的元组？如何表示一个元素都没有的空的元组？min(‘hello world’)返回什么？如何定义一个空的集合？空的字典如何定义？##]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL入门到应用]]></title>
    <url>%2F2017%2F09%2F14%2FMySQL%E5%85%A5%E9%97%A8%E5%88%B0%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[一、MySQL基本操作1.1 MySQL安装与配置MySQL官网根目录：C:\Program Files\MySQL配置文件my.ini目录：C:\ProgramData\MySQL\MySQL Server 5.7bin目录（C:\Program Files\MySQL\MySQL Server 5.7\bin）添加到环境变量，确保在任何目录下，可以直接调用bin目录下的可执行文件 MySQL目录结构：bin目录：存储可执行文件data目录：存储数据文件 （data目录在这个路径下C:\ProgramData\MySQL\MySQL Server 5.7\Data）docs目录：文档include目录: 存储包含的头文件lib目录：存储库文件share目录: 错误消息和字符集文件 修改编码方式:打开配置文件my.ini，配置如下；12345[mysql]default-character-set=utf8[mysqld]character-set-server=utf8 注意：utf8，不是utf-8 设置端口号port=3306 默认端口号 目录位置基础安装目录：Path to installation directory. All paths are usually resolved relative to this.basedir=”C:/Program Files/MySQL/MySQL Server 5.7/“数据文件存储位置：Path to the database rootdatadir=C:/ProgramData/MySQL/MySQL Server 5.7\Data 1.2 启动和关闭MySQL服务启动MySQL服务两种方式：1.通过图形界面，在操作系统级别上启动MySQL服务；2.命令行方式输入命令：启动MySQL服务net start mysql关闭MySQL服务net start mysql注意：net start/stop 不知可以启动MySQL服务，还可以启动所有服务列表上的服务报错提示1：如果出现 服务名无效 的提示，是因为电脑安装的MySQL版本是MySQL5.7，在windows系统MySQL默认的名字是MySQL57,所以应该输入如下命令：启动MySQL服务net start mysql57关闭MySQL服务net start mysql57报错提示2：如果出现发生系统错误 5。拒绝访问。的提示, 需要切换到管理员模式，要以管理员身份来运行cmd程序来启动mysql。高级设置：右键点击命令提示符，选择属性-快捷方式-高级-勾选用管理员身份运行。以后就可以直接以管理员身份运行命令提示符了。 mysql -V ？？？ 1.3 MySQL登录与退出]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python进阶]]></title>
    <url>%2F2017%2F09%2F12%2FPython%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[一、数据结构1.1 列表字典集合中根据条件筛选数据1.1.1 列表filter函数：filter(lambda x: x &gt;=0, data)列表解析： [x for x in data if x &gt;=0] 1.1.2 字典字典解析{k:v for k,v in d.iteritems() if v &gt; 90} 1.1.3 集合集合解析{x for x in s if x % 3 == 0} 1.2 元组元素命名为元组中的每个元素命名，提高程序可读性。 1.2.1 定义数值变量python没有真正的枚举类型，但是我们可以定义类似于其他语言的枚举类型，也就是定义一系列数值变量。 1.2.2 namedtuple替代内置tuple使用标准库中collections.namedtuple替代内置tuple。 1.3 统计序列元素出现频度使用collections.Counter对象： 将序列传入Counter的构造器，得到Counter对象是元素频度的字典。2.Counter.most_commmon(n)方法得到频度最高的n个元素的列表。 Details 方法1from random import randint 列表解析生成随机序列data = [randint(0, 20) for _ in xrange(30)]print data [6, 11, 15, 6, 20, 6, 7, 7, 10, 5, 4, 15, 10, 16, 15, 16, 12, 3, 13, 13, 15, 2, 19, 7, 17, 10, 16, 1, 17, 6]date作为字典的键，0作为字典的值，创建一个字典来c = dict.fromkeys(data, 0)print c {1: 0, 2: 0, 3: 0, 4: 0, 5: 0, 6: 0, 7: 0, 10: 0, 11: 0, 12: 0, 13: 0, 15: 0, 16: 0, 17: 0, 19: 0, 20: 0}进行对data的迭代for x in data: c[x] += 1print c {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 4, 7: 3, 10: 3, 11: 1, 12: 1, 13: 2, 15: 4, 16: 3, 17: 2, 19: 1, 20: 1}根据字典的值对字典中的项进行排序方法2，更简洁的方法from collections import Counter 直接把data传给Counter的构造器c2 = Counter(data)print c {1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 6: 4, 7: 3, 10: 3, 11: 1, 12: 1, 13: 2, 15: 4, 16: 3, 17: 2, 19: 1, 20: 1}print “**“print c2 Counter({6: 4, 15: 4, 7: 3, 10: 3, 16: 3, 13: 2, 17: 2, 1: 1, 2: 1, 3: 1, 4: 1, 5: 1, 11: 1, 12: 1, 19: 1, 20: 1})print “**“ c2这个Counter对象，可以更直接的统计出哪些频度出现更高c2_most_3_common = c2.most_common(3)print c2_most_3_common [(6, 4), (15, 4), (7, 3)]英文文章词频统计import retxt = open(‘CodingStyle’).read()print txt 首先分隔词，把每个词取出来放到一个序列中使用正则表达式的分隔模块words = re.split(‘\W+’, txt) # 用非字母作为分隔 对每个词出现的频度进行统计words2 = Counter(words)words2_most_10_common = words2.most_common(10)print words2_most_10_common 1.4 字典中的项排序根据字典中值的大小，对字典中的项排序。使用内置函数sorted: 利用zip将字典数据转化元组； 传递sorted函数的key参数。 Details 内置函数在内部是以C的速度运行，速度更快sorted_list = sorted([2, 5, 9, 1, 0])print sorted_list [0, 1, 2, 5, 9]创建随机成绩表from random import randint 字典解析student_grades = {x: randint(60, 100) for x in ‘xyzabc’ }print student_grades {‘a’: 67, ‘c’: 90, ‘b’: 66, ‘y’: 100, ‘x’: 62, ‘z’: 100}sorted_student_grades = sorted(student_grades)print sorted_student_grades [‘a’, ‘b’, ‘c’, ‘x’, ‘y’, ‘z’]并不是按照值进行排序的，而是按照键进行排序的sorted传入的是一个可迭代对象，对于字典的可迭代对象，也就是iter(sorted_student_grades),为了看见它可以转换为listprint iter(sorted_student_grades) print list(iter(sorted_student_grades)) [‘a’, ‘b’, ‘c’, ‘x’, ‘y’, ‘z’]实际上是对键进行了排序，并且值已经不存在了对字典进行转换，让它变成sorted（）可以排序的结构元组的比较，先比较第0个元素，如果第0个元素想等的情况下，再比较第1个元素print (97, ‘a’) &gt; (69, ‘b’) Trueprint (97, ‘a’) &gt; (97, ‘b’) Falseprint (97, ‘a’) &lt; (97, ‘b’) True将字典转换成元组的列表keys()得到所有的键print student_grades.keys() [‘a’, ‘c’, ‘b’, ‘y’, ‘x’, ‘z’]values()得到所有的值print student_grades.values() [67, 90, 66, 100, 62, 100]使用zio()函数把两个列表拼起来，变成一个print zip(student_grades.values(), student_grades.keys()) [(67, ‘a’), (90, ‘c’), (66, ‘b’), (100, ‘y’), (62, ‘x’), (100, ‘z’)]依次类推，构成元组的列表在内存使用上，更优化一些python2的版本上，keys()和values()得到的都是列表。如果列表很大，很浪费空间，可以使用它的迭代版本同样也能得到这样的结果， 但是存储空间上少一些浪费print zip(student_grades.itervalues(), student_grades.iterkeys()) [(67, ‘a’), (90, ‘c’), (66, ‘b’), (100, ‘y’), (62, ‘x’), (100, ‘z’)]成绩由小到大进行排序print sorted(zip(student_grades.itervalues(), student_grades.iterkeys())) [(62, ‘x’), (66, ‘b’), (67, ‘a’), (90, ‘c’), (100, ‘y’), (100, ‘z’)]方法二 利用sorted()的key参数字典的items()直接就是每个键，值print student_grades.items() [(‘a’, 67), (‘c’, 90), (‘b’, 66), (‘y’, 100), (‘x’, 62), (‘z’, 100)]使用sorted()的一个参数，也就是key,key就是你要传入一个函数print sorted(student_grades.items(), key = lambda x: x[1]) [(‘x’, 62), (‘b’, 66), (‘a’, 67), (‘c’, 90), (‘y’, 100), (‘z’, 100)] 1.5 快速找到多个字典中的公共键（key)利用集合（set)的交集操作： 使用字典的viewkeys()方法，得到一个字典keys的集合； 使用map函数，得到所有字典的keys的集合； 使用reduce函数，取所有字典的keys的集合的交集。 Details 多个字典中的公共键，也就是在每个字典中都出现的键from random import randint, sample # sample取样 产生随机进球球员print sample(‘abcdefg’, 3) [‘a’, ‘e’, ‘b’]进球球员数目也是随机的, 3-6个人进球了print sample(‘abcdefg’, randint(3, 6)) [‘e’, ‘b’, ‘g’, ‘d’]字典解析产生每轮的数据每一轮的进球数限定为1-4个s1 = {x: randint(1, 4) for x in sample(‘abcdefg’, randint(3, 6))}s2 = {x: randint(1, 4) for x in sample(‘abcdefg’, randint(3, 6))}s3 = {x: randint(1, 4) for x in sample(‘abcdefg’, randint(3, 6))}print s1 {‘a’: 1, ‘c’: 2, ‘b’: 4, ‘e’: 2, ‘d’: 2, ‘f’: 4}print ‘——–’print s2 {‘c’: 4, ‘b’: 2, ‘g’: 1}print ‘——–’print s3 {‘c’: 3, ‘e’: 3, ‘g’: 3}print ‘——–’ 迭代键值，对于字典的迭代就是迭代它的键res = [] # 列表或者集合存储起来for k in s1: if k in s2 and k in s3: res.append(k)print res [‘c’]但是这种方法啰嗦而且执行的效率也不好方法2 集合的操作首先使用字典的viewkeys()得到每个字典所有键的集合实际上是keys的视图print s1.viewkeys() dict_keys([‘a’, ‘c’, ‘b’, ‘e’, ‘d’, ‘f’])print s2.viewkeys() dict_keys([‘c’, ‘b’, ‘g’])集合 支持集合的交集操作print s1.viewkeys() &amp; s2.viewkeys() set([‘c’, ‘b’])前三轮的print s1.viewkeys() &amp; s2.viewkeys() &amp; s3.viewkeys() set([‘c’])print ‘——‘ 对于n轮 分别使用map() reduce()来处理这样的问题首先得到每一轮的keys的集合print map(dict.viewkeys, [s1, s2, s3]) [dict_keys([‘a’, ‘c’, ‘b’, ‘e’, ‘d’, ‘f’]), dict_keys([‘c’, ‘b’, ‘g’]), dict_keys([‘c’, ‘e’, ‘g’])]使用reduce函数进行交集, 迭代map中的所有集合print reduce(lambda a, b: a &amp; b, map(dict.viewkeys, [s1, s2, s3])) set([‘c’]) 1.6 字典保持有序使用collections.OrderedDict: 以OrderedDict替代内置字典Dict, 依次将选手成绩存入OrderedDict。 Details 像列表一样，按照每个项进入字典的次序来打印，但是python默认的字典是不具备这个功能的，不具备有序性d = {}d[‘Jim’] = (1, 35)d[‘Leo’] = (2, 37)d[‘Bob’] = (3, 40) 我们希望迭代字典d的时候，按照先后顺序遍历for k in d: print k BobJimLeo但是内置dict并不维护每个项进入的先后顺序我们需要一个能维护每个项进入的先后顺序的数据结构使用collections.OrderedDictfrom collections import OrderedDictd = OrderedDict()d[‘Jim’] = (1, 35)d[‘Leo’] = (2, 37)d[‘Bob’] = (3, 40)for k in d: print k JimLeoBob按照每个项进入字典的次序来遍历的from time import time # 返回当前系统时间from random import randintfrom collections import OrderedDict d = OrderedDict()players = list(‘ABCDEFGH’)start = time() for i in xrange(8): raw_input() p = players.pop(randint(0, 7-i)) end = time() print i + 1, p, end - start d[p] = (i + 1, end - start) print ‘-‘ * 20for k in d: print k, d[k] 1 C 2.22200012207# 2 A 2.80599999428# 3 D 3.13300013542# 4 F 3.42000007629# 5 B 3.77200007439# 6 G 4.1400001049# 7 E 4.49399995804# 8 H 4.91799998283——————–C (1, 2.2220001220703125)A (2, 2.805999994277954)D (3, 3.133000135421753)F (4, 3.4200000762939453)B (5, 3.7720000743865967)G (6, 4.140000104904175)E (7, 4.49399995803833)H (8, 4.917999982833862) 1.7 实现历史纪录功能实现用户的历史纪录功能（最多n条）。使用容量为n的队列存储历史纪录： 使用标准库collections中的deque，它是一个双端循环队列。（相关：Python语言及其应用-5.5.4 双端队列：栈+队列 103页）； 程序退出前，可以使用pickle将队列对象存入文件，再次运行程序时将其导入。 Details from random import randint# N = randint(1, 100) # 产生0-100之间的随机数# def guess(k):if k == N:print ‘right’if k &lt; N:print “%s is less-than N” % kelse:print “%s is greater-than N” % kreturn False# while True:line = raw_input(“please inout a number: “) # 接收用户输入if line.isdigit():k = int(line)if guess(k):break使用容量为n的队列存放历史记录 先入先出使用collections.deque,它是一个双端循环队列from collections import deque deque()函数创建队列如果创建带有容量的队列，需要传入第2个参数，容量值q = deque([], 5) # 队列初始值设为空q.append(1) # 进行右边的入队操作print q deque([1], maxlen=5)q.append(2)q.append(3)q.append(4)q.append(5)print q deque([1, 2, 3, 4, 5], maxlen=5)q.append(6)print q deque([2, 3, 4, 5, 6], maxlen=5)q.append(100)print q deque([3, 4, 5, 6, 100], maxlen=5)from random import randintfrom collections import deque N = randint(1, 100) # 产生0-100之间的随机数history = deque([], 5) # 初始化队列 def guess(k): if k == N: print ‘right’ if k &lt; N: print “%s is less-than N” % k else: print “%s is greater-than N” % k return False while True: line = raw_input(“please inout a number: “) # 接收用户输入 if line.isdigit(): k = int(line) history.append(k) if guess(k): break elif line == ‘history’ or line == ‘h?’: print history print list(history) please inout a number: 5050 is less-than Nplease inout a number: 8080 is greater-than Nplease inout a number: 7070 is greater-than Nplease inout a number: h?deque([50, 80, 70], maxlen=5)[50, 80, 70]please inout a number: 6060 is greater-than Nplease inout a number: 6565 is greater-than Nplease inout a number: h?deque([50, 80, 70, 60, 65], maxlen=5)[50, 80, 70, 60, 65]please inout a number: 6464 is greater-than Nplease inout a number: 6363 is greater-than Nplease inout a number: h?deque([70, 60, 65, 64, 63], maxlen=5)[70, 60, 65, 64, 63]please inout a number: 6262 is greater-than Nplease inout a number: 6161 is greater-than Nplease inout a number: 55right55 is greater-than Nplease inout a number: 5050 is less-than Nplease inout a number: 5454 is less-than Nplease inout a number: h?deque([62, 61, 55, 50, 54], maxlen=5)[62, 61, 55, 50, 54]please inout a number: 5353 is less-than Nplease inout a number: 5252 is less-than Nplease inout a number: 5151 is less-than Nplease inout a number: h?deque([50, 54, 53, 52, 51], maxlen=5)[50, 54, 53, 52, 51]please inout a number: 55right55 is greater-than Nplease inout a number: 5050 is less-than Nplease inout a number: 5151 is less-than Nplease inout a number: 5252 is less-than Nplease inout a number: 5353 is less-than Nplease inout a number: 5454 is less-than Nplease inout a number: 55right55 is greater-than N目前这个队列queue是在内存当中，程序退出就消失掉了。需要把历史记录这个对象存储到文件中也就是把history对象存储到文件中，下次运行程序再把它load进来import pickle pickle可以把一个python对象存储到文件当中，也可以从文件当中load一个python对象存储文件pickle.dump(q, open(‘history’, ‘w’)) # dump方法接收两个参数，第一个参数是存储的python对象，第二个参数是要指定一个文件 q2 = pickle.load(open(‘history’)) # 从文件中提取python对象 q2和q是一致的 二、迭代器与生成器2.1 实现可迭代对象和迭代器对象 实现一个迭代器对象WeatherIterator, next方法每次返回一个城市气温； 实现一个可迭代对象WeatherIterable, iter方法返回一个迭代器对象。 Details 这两种对象都是python中的可迭代对象l = [1, 2, 3, 4]s = ‘abcde’ 迭代列表for x in l: print x 1234迭代字符串for x in s: print x abcde首先要确保in 后面是个可迭代对象如果它是一个可迭代对象的话，它能由python的内置函数iter得到一个迭代器对象可迭代和迭代器，这两个概念不要混淆iter(l) 由可迭代对象，得到迭代器print iter(l) # 得到列表的迭代器对象 print iter(s) print iter(5)Traceback (most recent call last):File “C:/Users/Administrator/PycharmProjects/HighEndPython/3_1.py”, line 34, in print iter(5)TypeError: ‘int’ object is not iterable数字不是一个可迭代对象为什么列表和字符串是可迭代对象？他们满足了某种特殊接口print l.iter() print ‘—‘ 列表下有一个叫iter的方法，它就是迭代协议的接口调用iter(l),实际内部执行了 l.iter(),也就调用了这个对象的iter()方法字符串中没有找到iter()方法，但是它有个getitem()方法内置函数iter()首先会去找标准的迭代接口iter(),如果找不到就找getitem()方法# In the first form, the argument mustsupply its own iterator, or be a sequence.要么支持自身迭代器，要么是一个序列，getitem()就是一个序列的接口迭代器对象满足什么接口？t = iter(l)print t.next() 它只有next()接口print t.next()print t.next()print t.next()print t.next()print t.next() 1234整个列表迭代完毕会抛出异常for循环工作的机制实际上先由iter(l)得到一个迭代器，接下来不停的调用next()直到最终捕获到一个StopIteration的异常，整个for循环就跳出来了 2.2 生成器函数实现可迭代对象将该类的iter方法实现成生成器函数，每次yield返回一个素数。 Details 首先实现一个迭代器对象，它有一个next()方法，当迭代完毕应该抛出一个停止迭代异常实现一个可迭代对象，它有一个iter()方法，它能返回上面这样一个迭代器对象import requests def getweather(city): r = requests.get(u’http://wthrcdn.etouch.cn/weather_mini?city=‘ + city) data = r.json()[‘data’][‘forecast’][0] return ‘%s: %s , %s ‘ % (city, data[‘low’], data[‘high’]) #[u’北京’,u’上海’,u’广州’,u’长春’print getweather(u’北京’)print getweather(u’长春’)print getweather(u’深圳’) 北京: 低温 -6℃ , 高温 6℃长春: 低温 -17℃ , 高温 -7℃深圳: 低温 13℃ , 高温 23℃可迭代对象和迭代器对象，python的标准库当中，对它们的接口已经有了定义from collections import Iterable, Iteratorprint Iterator.abstractmethods frozenset([‘next’])迭代器的抽象接口是nextprint Iterable.abstractmethods frozenset([‘iter‘])可迭代对象的抽象接口是iter直接继承这两个抽象类import requests# def getweather(city):r = requests.get(u’http://wthrcdn.etouch.cn/weather_mini?city=‘ + city)data = r.json()[‘data’][‘forecast’][0]return ‘%s: %s , %s ‘ % (city, data[‘low’], data[‘high’])#[u’北京’,u’上海’,u’广州’,u’长春’] print getweather(u’北京’)print getweather(u’长春’)print getweather(u’深圳’)from collections import Iterable, Iterator 首先实现Iteratorclass WeatherIterator(Iterator): def init(self, cities): # 天气的迭代器应该有一个参数，描述这个迭代器都能返回哪些城市的基本信息 self.cities = cities # 还需要知道迭代位置,刻画迭代的位置 self.index = 0 def getweather(self, city): r = requests.get(u&apos;http://wthrcdn.etouch.cn/weather_mini?city=&apos; + city) data = r.json()[&apos;data&apos;][&apos;forecast&apos;][0] return &apos;%s: %s , %s &apos; % (city, data[&apos;low&apos;], data[&apos;high&apos;]) def next(self): if self.index == len(self.cities): raise StopIteration city = self.cities[self.index] self.index += 1 return self.getweather(city) # 气温迭代器完成 class WeatherIterable(Iterable): def init(self, cities): self.cities = cities # 为了后面传给Iterator这个构造器 def __iter__(self): return WeatherIterator(self.cities) # 实例 for x in WeatherIterable([u’北京’,u’上海’,u’广州’,u’长春’]): print x 北京: 低温 -6℃ , 高温 6℃上海: 低温 3℃ , 高温 12℃广州: 低温 11℃ , 高温 22℃长春: 低温 -17℃ , 高温 -7℃在某些惰性场合使用它们的优势 2.3 反向迭代如何进行反向迭代以及如何实现反向迭代？实现反向迭代协议的reversed方法，它返回一个反向迭代器。 2.4 迭代器做切片操作使用标准库中的itertools.islice, 它能返回一个迭代对象切片的生成器。 2.5 迭代多个可迭代对象如何在一个for语句中迭代多个可迭代对象：并行：使用内置函数zip, 它能将多个可迭代对象合并，每次迭代返回一个元组。串行：使用标准库中的itertools.chain, 它能将多个可迭代对象连接。 三、字符串处理3.1 拆分含有多种分割符的字符串3.1.1 str.split()方法连续使用str.split()方法，每次处理一种分割符号。 3.1.2 正则表达式re.split()方法使用正则表达式的re.split()方法，一次性拆分字符串。 3.2 判断字符串a是否以字符串b开头或结尾使用字符串的str.startswith()和str.endswith()方法。注意：多个匹配时参数使用元组。 3.3 调整字符串中文本的格式使用正则表达式re.sub()方法做字符串替换，利用正则表达式的捕获组，捕获每个部分内容，在替换字符串中调整各个捕获组的顺序。 3.4 字符串拼接多个小字符串拼接成大的字符串。 3.4.1 迭代列表迭代列表，连续使用’+’操作依次拼接每一个字符串。 3.4.2 str.join()方法使用str.join()方法，更加快速的凭借列表中所有字符串。 3.5 字符串左右居中对齐3.5.1 str.ljust(), str.rjust, str.center()使用字符串的str.ljust(), str.rjust, str.center()进行左、右，居中对齐。 3.5.2 format()使用format()方法，传递类似’20’,’^20’参数完成同样任务。 3.6 去掉字符串中不需要的字符3.6.1 strip(),lstrip(),rstrip()方法字符串strip(),lstrip(),rstrip()方法去掉字符串两端字符。 3.6.2 切片 + 拼接删除单个固定位置的字符，可以使用切片 + 拼接的方式。 3.6.3 replace()方法或re.sub()字符串的replace()方法或正则表达式re.sub()删除任意位置字符。 3.6.4 translate()方法字符串translate()方法，可以同时删除多种不同字符。 四、文件I/O4.1 读写文本文件4.1.1 python2.x写入文件前对unicode编码，读入文件后对二进制字符串解码。 4.1.2 python3.xopen函数指定’t’的文本模式，encoding指定编码格式。 4.2 处理二进制文件open函数以二进制模式打开文件，指定mode参数为’b’.二进制数据可以用readinto, 读入到提前分配好的buffer中，便于数据处理。解析二进制数据可以使用标准库中的struct模块的unpack方法。 4.3 设置文件的缓冲全缓冲：open函数的buffering设置为大于1的整数n,n为缓冲区大小。行缓冲：open函数的buffering设置为1。无缓冲：open函数的buffering设置为0。 4.4 文件映射到内存使用标准库中mmap模块的mmap()函数，它需要一个打开的文件描述符作为参数。 4.5 访问文件的状态函数调用：标准库中os模块下的三个系统调用stat,fstat,lstat获取文件状态。快捷函数：标准库中os.path下一些函数，使用起来更加简洁。 4.6 使用临时文件使用标准库中tempfile下的TemporaryFile,NamedTemporaryFile。 五、csv、json、xml、excel5.1 读写csv数据使用标准库中的csv模块，可以使用其中reader和writer完成csv文件读写。 5.2 读写json数据使用标准库中的json模块，其中loads、dumps函数可以完成json数据的读写。 5.3 解析简单的xml文档使用标准库中的xml.etree.ElementTree，其中的parse函数可以解析xml文档。 5.4 构建xml文档使用标准库中的xml.etree.ElementTree，使用write()方法写入文件。 5.5 读写excel文件使用第三方库xlrd和xlwt，这两个库分别用于excel读和写。 六、类与对象6.1 派生内置不可变类型并修改实例化行为定义类IntTuple继承内置tuple,并实现_new__,修改实例化行为。 6.2 创建大量实例节省内存定义类的slots属性，它是用来声明实例属性名字的列表。 6.3 让对象支持上下文管理实现上下文管理协议，需定义实例的enter,exit方法，他们分别在with开始和结束时被调用。 6.4 创建可管理的对象属性使用property函数为类创建可管理属性，fget/fset/fdel对应相应属性访问。 6.5 让类支持比较操作比较符号运算符重载，需要实现以下方法：小于lt,小于等于le,大于gt,大于等于ge,等于eq,不等于ne。使用标准库下的functools下的类装饰器total_ordering可以简化此过程。 6.6 使用描述符对实例属性做类型检查使用描述符来实现需要类型检查的属性：分别实现get,set,delete方法，在set内使用isinstancce函数做类型检查。 6.7 在环状数据结构中管理内存使用标准库weakref，它可以创建一种能访问对象但不增加引用计数的对象。 6.8 通过实例方法名字的字符串调用方法方法一：使用内置函数getattr,通过名字在实例上获取方法对象，然后调用。方法二：使用标准库operator下的methodcaller函数调用。 七、多线程与多进程7.1 使用多线程使用标准库threading.Thread创建线程，在每一个线程中下载并转换一只股票数据。 7.2 线程间通信使用标准库中Queue.Queue，它是一个线程安全的队列。Download线程把下载数据放入队列，Convert线程从队列里提取数据。 7.3 线程间进行事件通知线程间的事件通知，可以使用标准库中Threading.Event: 等待事件一端调用wait, 等待事件。 通知事件一端调用set，通知事件。 7.4 使用线程本地数据threading.local函数可以创建线程本地数据空间，其下属性对每个线程独立存在。 7.5 使用线程池使用标准库中concurrent.futures下的ThreadPoolExecutor，对象的submit和map方法可以用来启动线程池中线程执行任务。 7.6 使用多进程使用标准库中multiprocessing.Process，它可以启动子进程执行任务，操作接口，进程间通信，进程间同步等都与Threading,Thread类似。 八、装饰器8.1 使用函数装饰器定义函数装饰器，用它来生成一个在原函数基础添加了新功能的函数，替换原函数。 8.2 为被装饰的函数保存元数据使用标准库functools中的装饰器wraps装饰内部包裹函数，可以制定将原函数的某些属性，更新到包裹函数上面。 8.3 定义带参数的装饰器带参数的装饰器，也就是根据参数定制化一个装饰器，可以看成生产装饰器的工厂，每次调用typeasseert，返回一个特定的装饰器，然后用它去修饰其他函数。 8.4 实现属性可修改的函数装饰器为包裹函数增添一个函数，用来修改闭包中使用的自由变量。在python3中：使用nonlocal访问嵌套作用域中的变量引用。 8.5 在类中定义装饰器为了让装饰器在使用上更加灵活，可以把类的实例方法作为装饰器，此时在包裹函数中就可以持有实例对象，便于修改属性和拓展功能。 更多：Python高效编程技巧实战]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django Xadmin入门与进阶]]></title>
    <url>%2F2017%2F09%2F10%2FXadmin%E5%85%A5%E9%97%A8%E4%B8%8E%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Django的admin也是一个app,默认配置 INSTALLED_APPS = [ ‘django.contrib.admin’,] urlpatterns = [ url(r’^admin/‘, admin.site.urls),] 浏览器访问admin127.0.0.1:8000/admin登录框提示输入用户名和密码Tools-Run manage.py Taskcreate superuser记住密码不能是纯数字 admin改成中文界面LANGUAGE_CODE = ‘zh-hans’ TIME_ZONE = ‘Asia/Shanghai’ USE_I18N = True USE_L10N = True USE_TZ = False （不这样设置，Django在我们数据库存储过程中会把我们的时间改为UTC时间，也就是国际事件。减少以后很多关于时间的问题） admin.py1234567891011from django.contrib import adminRegister your models here.from .models import UserProfileclass UserProfileAdmin(admin.ModelAdmin): passadmin.site.register(UserProfile, UserProfileAdmin) makemigrations app name ValueError: too many values to unpack migration里所有apps.去掉 org = models.ForeignKey(CourseOrg, verbose_name=u”所属机构”) Django自带CASCADE?migration里显示on_delete=django.db.models.deletion.CASCADE 增加用户，一是createsuperuser二，是后台管理界面新增用户 Xadmin：pip install xadminINSTALLED_APPS = [ ‘xadmin’, ‘crispy_forms’, （注意这里是下划线，一定不要搞错了）] urls.pyimport xadminurlpatterns = [ url(r’^xadmin/‘, xadmin.site.urls),]之前注册的admin要注销掉 报错：xadmin_usersettings doesn’t exist记得makemigrations migrate Xadmin后台样式Bootstrap 基于源码安装Xadminclone and downloadxadmin拷贝到项目根目录记得pip uninstall xadminRun-没有报错，源码安装成功127.0.0.1:8000/xadmin model全部注册到后台管理系统中 Xadmin也继承了很多admin的用法比如model注册如何注册model新建adminx.py文件 pycharm设定新建py文件的模板File and Code tEMPLATEpython文件自动生成模板]]></content>
      <categories>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Django</tag>
        <tag>Xadmin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sublime Text使用技巧]]></title>
    <url>%2F2017%2F09%2F01%2FSublime%20Text%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言：本文基于Windows系统 一、安装Sublime Text安装地址：Sublime Text 二、常用快捷键sublime快捷键配置：Shift+Ctrl+P打开命令面板，输入keybin（sublime支持模糊匹配），点击提示里的Preferences: Key Bindings - Default这一项，就可以看到所有sublime的快捷键配置。 Ctrl+N: 打开新页面Ctrl+Tab: 两个页面之间做跳转Ctrl+J: 合并两个代码行（光标需要定位在第一个代码行后面）Ctrl+[: 回退一个级别Ctrl+]: 缩进一个级别Ctrl+L: 选择当前行Ctrl+C: 拷贝Ctrl+V: 粘贴Ctrl+Enter: 当前行之下新增一行Shift+Ctrl+Enter: 当前行之上新增一行Ctrl+Z: 撤销操作Ctrl+D: 选中相同关键词Ctrl+鼠标左键: 进入多点编辑模式Esc: 跳出多点编辑模式Ctrl+A: 全选Ctrl+K+B: 打开侧边栏Shift+Ctrl+P： 打开命令面板Command Palette。Sublime的命令面板非常强大，可以减少对鼠标的以来，多用键盘。输入相应的单词，就可以执行想要的操作。 操作粒度：方向键左右键： 移动单位的是一个字符Alt+方向键左右键： 移动单位的是一个单词Ctrl+方向键左右键： 移动到一行代码的头部和末尾Shift+方向键左右键： 选中光标左/右边一个字符Shift+Alt+方向键左右键： 选中光标左/右边一个单词 Shift+Ctrl+方向键左右键： 选中光标左/右边整行代码 Shift+Ctrl+方向键下键： 选中光标后到文件末尾的全部代码 Shift+Ctrl+方向键上键： 选中光标前到文件头部的全部代码 三、自定制Sublime所有自定制的数据都会保存到一个特殊的文件夹当中，点击Preferences-Browse Packages, 显示的User文件夹就是存放用户所有自定制数据的文件夹。User文件夹中的文件作用如下：Default (Windows).sublime-keymap：保存用户绑定的快捷键配置Preferences.sublime-settings：保存用户自定制的配置 示例显示如何自定制一个自动调整缩进的快捷键： 3.1 调整缩进 Shift+Ctrl+P：打开命令面板 输入rein(模糊匹配)，选择Indentation: Reindent Lines 3.2 Indentation: Reindent Lines命令绑定快捷键 Shift+Ctrl+P：打开命令面板, 输入keybin（sublime支持模糊匹配），点击提示里的Preferences: Key Bindings - User这一项，输入以下代码:123[&#123; &quot;keys&quot;: [&quot;shift+tab&quot;], &quot;command&quot;: &quot;reindent&quot;, &quot;args&quot;: &#123;&quot;single_line&quot;: false&#125; &#125;,] 这里如何知道精确的命令名呢？ Ctrl+`：打开工作台； 输入sublime.log_commands命令设置为True，回车执行。代码如下： 1sublime.log_commands(True) 命令面板中输入rein,选择Indentation: Reindent Lines； 工作台就可以看到精确的命令名以及参数：command: reindent {“single_line”: false} Esc退出 四、Package Control安装扩展包Sublime默认自带了很多包，如果需要安装扩展包，首先需要安装Package Control工具。 4.1 安装Package Control 进入Package Control官网，点击右上角的Installation, 根据电脑的Sublime Text版本复制左侧相应的代码： 12345Sublime Text 3:import urllib.request,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by)Sublime Text 2:import urllib2,os,hashlib; h = &apos;df21e130d211cfc94d9b0905775a7c0f&apos; + &apos;1e3d39e33b79698005270310898eea76&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); os.makedirs( ipp ) if not os.path.exists(ipp) else None; urllib2.install_opener( urllib2.build_opener( urllib2.ProxyHandler()) ); by = urllib2.urlopen( &apos;http://packagecontrol.io/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); open( os.path.join( ipp, pf), &apos;wb&apos; ).write(by) if dh == h else None; print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h) if dh != h else &apos;Please restart Sublime Text to finish installation&apos;) Sublime Text中按Ctrl+`打开工作台，粘贴代码，回车执行。 安装完成之后，Ctrl+Q退出，重启Sublime。 打开Sublime之后，Shift+Ctrl+P打开命令面板, 敲Install, 选择Package Control:Install Package， 回车执行，读取包的列表。 打开后搜索包名，比如AdvanceNewFile，Emmet，Git等，回车进行安装，Sublime就会自动安装好指定的包。注意：Ctrl+W可以关闭说明文档。 4.2 常用扩展包AdvanceNewFile： 新建层级比较复杂的文件，如app/views/comments/show.html.erb。Alt+Ctrl+N 打开对话框之后，输入路径及文件名，回车就可打开输入内容。Git：安装后可以直接在Sublime上执行Git命令，把修改推送到GitHub上。SyncedSideBar： 侧边栏同步显示当前文件在目录树中的具体位置。 五、Goto Anything5.1 速查文件Ctrl+P打开Goto Anything，输入文件名，回车打开文件。 5.2 速查文件代码具体行输入文件名+“:”+代码行数，回车可以打开指明的文件并定位到指定的代码行。如shohtm:10可以打开show.html.erb文件并定位到第十行，光标会停留在文件中的第十行。 5.3 速查文件中的函数输入文件名+@+函数名，回车，光标定位到指定文件的指明函数代码行。 5.4 速查字符串#+字符串，可以快速定位到指定字符串, 不过这种方式，用得不多。 5.5 专门查找字符串 使用苹果电脑的同学可以参考如下的Mac和PC键盘布局对比图，比如Windows系统的Ctrl键对应Mac系统的Command键。其他好用的代码编辑器：ATOM： GitHub的开源免费代码编辑器Vim： 类似于Vi的著名的功能强大、高度可定制的文本编辑器textmate： Mac下的著名的文本编辑器软件，与BBedit一起并称苹果机上的emacs和vim 参考资料：快乐的sublime编辑器前端开发工具技巧介绍—Sublime篇前端开发必备！Emmet使用手册]]></content>
      <categories>
        <category>Sublime</category>
      </categories>
      <tags>
        <tag>Sublime</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask Web开发：基于Python的Web应用开发实战(不定期更新)]]></title>
    <url>%2F2017%2F08%2F31%2FFlask%20Web%E5%BC%80%E5%8F%91%EF%BC%9A%E5%9F%BA%E4%BA%8EPython%E7%9A%84Web%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[前言: 最近开始学习Flask了，学的是经典的图灵系列之《Flask Web开发：基于Python的Web应用开发实战》不定期更新学习笔记。Flask官方文档 示例代码Flasky 和其他框架相比，Flask的优点：扩展性高，让开发者做主，使其能对程序具有全面的创意控制。Flask支持所有的关系型数据库，还可以自主选择程序的组件，如果没有合适的，还可以自己开发。 课前须知： 一定的Python编程经验 熟练使用操作系统命令行 HTML、CSS、JavaScript 基本的Git使用技巧 首先安装Git客户端Administrator@DESKTOP-PCS85E7 MINGW64 /c/Nana/TP&amp;TACH/折腾来折腾去123456$ git clone https://github.com/miguelgrinberg/flasky.gitCloning into 'flasky'...remote: Counting objects: 830, done.remote: Total 830 (delta 0), reused 0 (delta 0), pack-reused 830Receiving objects: 100% (830/830), 146.70 KiB | 44.00 KiB/s, done.Resolving deltas: 100% (455/455), done. git clone命令从Github上下载源码，安装到当前目录下的flasky文件夹中。这个文件夹有源码，还有一个包含了程序修改完整历史的Git仓库。 Hexo 创建日志的时候报错ERROR Process failed: _posts/Flask Web开发：基于Python的Web应用开发实战.mdYAMLException: can not read a block mapping entry; a multiline key may not be an implicit key at line 2, column 5: date: 2017-08-31 11:34:02 ^解决：[Flask]把这个删掉试试， 问题解决了切换提交历史的Git命令：1$ git checkout xxx（标签，项目中某次提交历史的名字） 修改程序源文件，Git会阻止你签出其他历史版本，因为这会导致本地修改历史的丢失？？？签出其他历史版本之前，要把文件还原到原始状态。最简单的方法是使用git reset命令：1$ git reset --hard 这个命令会损坏本地修改，所以执行此命令前你需要保存所有不想丢失的改动。？？？ 从GitHub上下载修正和改进后的源码用于更新本地仓库。命令如下：123$ git fetch --all$ git fetch --tags$ git reset --hard origin/master （git reset命令 用于更新文件的操作，执行git reset命令后，本地修改会丢失） git fetch命令用于利用GitHub上的远程仓库更新本地仓库的提交历史和标签，但不会改动真正的源文件查看程序两个版本之间的区别，以便了解改动详情：1$ git diff xxx xxx 补丁以Patch形式显示区别。 补丁文件？？？ GitHub网站显示的图形化对比更容易让人理解，查看两个历史版本的区别，可访问https://github.com/miguelgrinberg/flasky/compare/2a...2b 安装Flask有两个主要依赖：路由、调试和Web服务器网关接口（Web Server Gateway Interface, WSGI),子系统由Werkzeug提供; 模版系统由Jinja2 提供。python版本：Python2.7 / Python3.3 使用虚拟环境虚拟环境是Python解释器的一个私有副本，这个环境中可以安装私有包，而且不会影响系统中安装的全局Python解释器。优点：1. 系统的Python解释器中避免包的混乱和版本的冲突。2. 为每个程序单独创建虚拟环境可以保证程序智能访问虚拟环境中的包，从而保持全局解释器的干净整洁，使其只作为创建（更多）虚拟环境的源。3. 不需要管理员权限。虚拟环境用第三方实用工具virtualenv创建。 检查系统是否安装了virtualenv命令：$ virtualenv –versionPython3.3 venv模块原生支持虚拟环境，命令为pyvenv。pyvenv 不包含pip Python3.4改进，pyvenv完全代替virtualenv。安装： Linux 1$ sudo apt-get install python-virtualenv Mac OS X 1$ sudo easy_install virtualenv Windows 1pip install virtualenv 书上的方式不一样注意： 上述命令必须以具有管理员权限的用户身份执行。Windows系统“以管理员身份运行”， 基于Unix系统，命令前面加上sudo,或以根用户身份执行。安装完毕，virtualenv实用工具就可以从常规账户中调用。 从GitHub下载示例代码：123$ git clone https://github.com/miguelgrinberg/flasky.git$ cd flasky$ git checkout 1a Administrator@DESKTOP-PCS85E7 MINGW64 /c/Nana$ git clone https://github.com/miguelgrinberg/flasky.gitCloning into ‘flasky’…remote: Counting objects: 830, done.Reremote: Total 830 (delta 0), reused 0 (delta 0), pack-reused 830Receiving objects: 100% (830/830), 146.70 KiB | 172.00 KiB/s, done.Resolving deltas: 100% (455/455), done. Administrator@DESKTOP-PCS85E7 MINGW64 /c/Nana$ cd flasky Administrator@DESKTOP-PCS85E7 MINGW64 /c/Nana/flasky (master)$ git checkout 1aNote: checking out ‘1a’. You are in ‘detached HEAD’ state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -b with the checkout command again. Example: git checkout -b HEAD is now at e4777c9… Chapter 1: initial version (1a)使用virtualenv命令（只有一个必需的参数，即虚拟环境的名字，一般命名venv）在flasky文件夹中创建Python虚拟环境：子文件夹 名字是虚拟环境的名字 虚拟环境相关文件都保存在子文件夹中1$ virtualenv venv cmd中C:\Nana\flasky&gt;virtualenv venvUsing base prefix ‘c:\users\administrator\appdata\local\programs\python\python35-32’New python executable in C:\Nana\flasky\venv\Scripts\python.exeInstalling setuptools, pip, wheel…done.使用虚拟环境之前，先要“激活”。bash命令行（Linux和Mac OS X）1$ source venv/bin/activate Windows系统：1$ venv\Scripts\activate C:\Nana\flasky&gt;venv\Scripts\activate (venv) C:\Nana\flasky&gt;激活后，Python解释器的路径就被添加进PATH中，不是永久性的，只会影响当前的命令行对话。激活虚拟环境的命令会修改命令行提示符，加入环境名，提醒你已经激活了虚拟环境：1(venv) $ 虚拟环境的工作完成后，命令行输入deactivate,回到全局Python解释器中。 使用pip安装Python包大多数Python包都使用pip实用工具安装，使用virtualenv创建虚拟环境时会自动安装pip。激活虚拟环境后，pip所在的路径会被添加进PATH。我用的python3.5的版本来做的’虚拟环境中安装Flask:1(venv) $ pip install flask (venv) C:\Nana\flasky&gt;pip install flaskCollecting flask Downloading Flask-0.12.2-py2.py3-none-any.whl (83kB) 100% |████████████████████████████████| 92kB 264kB/sCollecting click&gt;=2.0 (from flask) Downloading click-6.7-py2.py3-none-any.whl (71kB) 100% |████████████████████████████████| 71kB 863kB/sCollecting itsdangerous&gt;=0.21 (from flask) Downloading itsdangerous-0.24.tar.gz (46kB) 100% |████████████████████████████████| 51kB 624kB/sCollecting Jinja2&gt;=2.4 (from flask) Downloading Jinja2-2.9.6-py2.py3-none-any.whl (340kB) 100% |████████████████████████████████| 348kB 635kB/sCollecting Werkzeug&gt;=0.7 (from flask) Downloading Werkzeug-0.12.2-py2.py3-none-any.whl (312kB) 100% |████████████████████████████████| 317kB 424kB/sCollecting MarkupSafe&gt;=0.23 (from Jinja2&gt;=2.4-&gt;flask) Downloading MarkupSafe-1.0.tar.gzBuilding wheels for collected packages: itsdangerous, MarkupSafe Running setup.py bdist_wheel for itsdangerous … done Stored in directory: C:\Users\Administrator\AppData\Local\pip\Cache\wheels\fc\a8\66\24d655233c757e178d45dea2de22a04c6d92766abfb741129a Running setup.py bdist_wheel for MarkupSafe … done Stored in directory: C:\Users\Administrator\AppData\Local\pip\Cache\wheels\88\a7\30\e39a54a87bcbe25308fa3ca64e8ddc75d9b3e5afa21ee32d57Successfully built itsdangerous MarkupSafeInstalling collected packages: click, itsdangerous, MarkupSafe, Jinja2, Werkzeug, flaskSuccessfully installed Jinja2-2.9.6 MarkupSafe-1.0 Werkzeug-0.12.2 click-6.7 flask-0.12.2 itsdangerous-0.24 验证Flask是否正确安装，启动Python解释器，导入Flask：123(venv) $ python&gt;&gt;&gt; import flask&gt;&gt;&gt; 没有错误提醒，则成功。 程序的基本结构初始化所有Flask程序都必须创建一个程序实例。Web服务器使用一种名为Web服务器网关接口（Web Server Gateway Interface, WSGI)的协议，把接受自客户端的所有请求都转交给这个对象处理。程序实例是Flask类的对象，常用如下代码创建：12from flask import Flaskapp = Flask(__name__) Flask类的构造函数只有一个必须指定的参数，即程序主模块或包的名字。大多数程序中，Python的name变量就是所需的值。更多：将构造函数的name参数传给Flask程序，Flask用这个参数决定程序的根目录，以便找到相对于程序根目录的资源文件位置。 路由和视图函数请求：客户端–&gt;Web服务器–&gt;Flask程序实例。 程序实例需要知道对每个URL请求运行哪些代码，所以保存了一个URL到Python函数的映射关系。路由：处理URL和函数之间关系的程序。Flask程序定义路由，最简便方式是用程序实例提供的app.route修饰器(装饰器)，把修饰的函数注册为路由。使用app.route修饰器(装饰器)声明路由：123@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;' 修饰器(装饰器)？？？第八页这个例子把index()函数注册为程序根地址的处理程序。像index()这样的函数称为视图函数（view function)。python代码嵌入响应式字符串导致代码难以维护？？？8日常所用服务的某些URL格式，很多地址都包含可变部分。Flask支持这种形态的URL,只需在route修饰器重使用特殊的句法即可。定义有一部分是动态名字的路由：123@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % name 尖括号中的内容-动态部分，调用视图函数时。Flask会把动态部分作为参数传入函数。路由中的动态部分默认使用字符串，不过也可使用类型定义。 如路由/user/只会匹配动态片段id为整数的URL。Flask支持在路由中使用int、float和path类型。path类型也是字符串，但不把斜线视作分隔符，而将其作为动态片段的一部分。 启动服务器程序实例用run方法启动Flask集成的开发Web服务器：if name == ‘main‘: app.run(debug=True) name == ‘main‘是Python的惯常用法，这里确保直接执行这个脚本时才启动开发Web服务器。如果这个脚本由其他脚本引入，不会执行app.run()。服务器启动-轮询，等待并处理请求。一直运行到程序停止，如按Ctrl+C。有一些选项参数可被app.run()函数接受用于设置Web服务器的操作模式。 启动调试模式（如激活调试器和重载程序），可将debug参数设为True。更多：Flask提供的Web服务器不适合在生产环境中使用。 一个完整的程序示例2-1 hello.py: 一个完整的Flask程序12345678910111213from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;'if __name__ == '__main__': app.run(debug=True) 调试地址启动程序：123(venv) $ python hello.py * Running on http://127.0.0.1:5000/ * Restarting with reloader 我的运行如下，不过浏览器显示一样1234567(venv) C:\Nana\flasky&gt;python hello.py * Restarting with stat * Debugger is active! * Debugger PIN: 929-772-137 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)127.0.0.1 - - [31/Aug/2017 18:06:47] "GET / HTTP/1.1" 200 -127.0.0.1 - - [31/Aug/2017 18:06:47] "GET /favicon.ico HTTP/1.1" 404 - 示例2-2 hello.py: 包含动态路由的Flask程序12345678910111213141516171819from flask import Flaskapp = Flask(__name__)@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;'@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % nameif __name__ == '__main__': app.run(debug=True) 调试地址1 浏览器显示：Hello, Dave!调试地址2 浏览器显示：Hello, Nana!1234567891011121314(venv) C:\Nana\flasky&gt;python hello.py * Restarting with stat * Debugger is active! * Debugger PIN: 929-772-137 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)127.0.0.1 - - [31/Aug/2017 18:06:47] "GET / HTTP/1.1" 200 -127.0.0.1 - - [31/Aug/2017 18:06:47] "GET /favicon.ico HTTP/1.1" 404 - * Detected change in 'C:\\Nana\\flasky\\hello.py', reloading 从这里开始变化了 * Restarting with stat * Debugger is active! * Debugger PIN: 929-772-137 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)127.0.0.1 - - [31/Aug/2017 18:18:31] "GET /user/Dave HTTP/1.1" 200 -127.0.0.1 - - [31/Aug/2017 18:19:01] "GET /user/Nana HTTP/1.1" 200 - 请求 - 响应循环程序和请求上下文请求对象封装了客户端发送的HTTP请求。将请求对象做为参数传入视图函数，能让视图函数访问请求对象。但会导致程序中的每个视图函数都增加一个参数。而且如果视图函数在处理请求时还要访问其他对象，情况会变糟。Flask使用上下文临时把某些对象变为全局可访问。123456from flask import request@app.route('/')def index(): user_agent = request.headers.get('User_Agent') return '&lt;p&gt;Your brower is %s&lt;/p&gt;' % user_agent 事实上，request不可能是全局变量。多线程服务器中，Flask使用上下文让特定的变量在一个线程中全局可访问，于此同时却不会干扰其他线程。更多：线程是可单独管理的最小指令集。多线程Web服务器会创建一个线程池，再从线程池中选择一个线程用于处理接收到的请求。 Flask中两种上下文： 程序上下文和请求上下文。 变量名 上下文 说明 current_app 程序上下文 当前激活程序的程序实例 g 程序上下文 处理请求时用作临时存储的对象，每次请求都会重设这个变量 request 请求上下文 请求对象，封装了客户端发出的HTTP请求中的内容 session 请求上下文 用户会话，用于存储请求之间需要“记住”的值的词典 Flask发送请求之前激活（或推送）程序和请求上下文，推送后，可以在线程中使用current_app，g，request，session变量，请求处理完成后再将其删除。如果使用这些变量时没有激活程序或请求上下文，就会导致错误。示例：123456789101112131415161718192021222324252627282930313233343536373839404142&gt;&gt;&gt; from hello import app&gt;&gt;&gt; from flask import current_app&gt;&gt;&gt; current_app.nameTraceback (most recent call last):...RuntimeError: Working outside of application context.&gt;&gt;&gt; app_ctx = app.app_context()&gt;&gt;&gt; app_ctx.push()&gt;&gt;&gt; current_app.name'hello'&gt;&gt;&gt; app_ctx.pop()C:\Nana\flasky\venv\Scripts&gt;activate(venv) C:\Nana\flasky\venv\Scripts&gt;cd C:\Nana\flasky(venv) C:\Nana\flasky&gt;pythonPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 15:51:26) [MSC v.1900 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; from hello import app&gt;&gt;&gt; from flask import current_app&gt;&gt;&gt; current_app.nameTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt; File "C:\Nana\flasky\venv\lib\site-packages\werkzeug\local.py", line 347, in __getattr__ return getattr(self._get_current_object(), name) File "C:\Nana\flasky\venv\lib\site-packages\werkzeug\local.py", line 306, in _get_current_object return self.__local() File "C:\Nana\flasky\venv\lib\site-packages\flask\globals.py", line 51, in _find_app raise RuntimeError(_app_ctx_err_msg)RuntimeError: Working outside of application context.This typically means that you attempted to use functionality that neededto interface with the current application object in a way. To solvethis set up an application context with app.app_context(). See thedocumentation for more information.&gt;&gt;&gt; app_ctx = app.app_context()&gt;&gt;&gt; app_ctx.push()&gt;&gt;&gt; current_app.name'hello'&gt;&gt;&gt; app_ctx.pop() 这里没激活程序上下文前就调用current_app.name会导致错误，但推送完上下文之后就可以调用了。注意，在程序实例上调用app.app_context()可获得一个程序上下文。 请求调度Flask使用app.route修饰器或者非修饰器形式的app.add_url_rule()生成映射。在Python shell中测试为hello.py生成的映射：12345678910111213141516(venv) $ python&gt;&gt;&gt; from hello import app&gt;&gt;&gt; app.url_mapMap([&lt;Rule '/' (HEAD, GET, OPTIONS) -&gt; index&gt;, &lt;Rule '/static/&lt;filename&gt;' (HEAD, GET, OPTIONS) -&gt; static&gt;, &lt;Rule '/user/&lt;name&gt;' (HEAD, GET, OPTIONS) -&gt; user&gt;])(venv) C:\Nana\flasky&gt;pythonPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 15:51:26) [MSC v.1900 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; from hello import app&gt;&gt;&gt; app.url_mapMap([&lt;Rule '/' (HEAD, GET, OPTIONS) -&gt; index&gt;, &lt;Rule '/static/&lt;filename&gt;' (HEAD, GET, OPTIONS) -&gt; static&gt;, &lt;Rule '/user/&lt;name&gt;' (HEAD, GET, OPTIONS) -&gt; user&gt;]) /和/user/路由在程序中使用app.route修饰器定义。/static/路由是Flask添加的特殊路由，用于访问静态文件。URL映射中的HEAD, GET, OPTIONS是请求方法，由路由进行处理。 请求钩子有时在处理请求之前或之后执行代码会很有用。Flask提供了注册通用函数的功能，注册的函数可在请求之前或之后调用。请求钩子使用修饰器实现。Flask支持四种钩子。 before_first_request: 注册一个函数，在处理第一个请求之前运行。 before_request: 注册一个函数，在每次请求之前运行。 after_request: 注册一个函数，如果没有未处理的异常抛出，在每次请求之后运行。 teardown_request: 注册一个函数，如果有未处理的异常抛出，也在每次请求之后运行。在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g。 响应Flask调用视图函数后，会将其返回值作为响应的内容。HTTP协议需要作为请求响应的字符串还有状态码，Flask默认设为200， 表明请求已经被成功处理。如果需要使用不同的状态码，就要把数字代码作为第二个返回值，添加到响应文本之后。如400状态码，表示请求无效：123@app.route('/')def index(): return '&lt;h1&gt;Bad Request&lt;/h1&gt;', 400 视图函数返回的响应还可以接受第三个参数，这是一个有首部（header）组成的字典，可以添加到HTTP响应中。如果不想返回由1个、2个或3个值组成的元组，Flask视图函数还可以返回Response对象。make_response()函数可接受1个、2个或3个参数，并返回一个Response对象。示例创建了一个响应对象，然后设置了cookie:1234567from flask import make_response@app.route('/')def index(): response = make_response('&lt;h1&gt;This document carries a cookie!&lt;/h1&gt;') response.set_cookie('answer', '42') return response 重定向（特殊响应类型）没有页面文档，只告诉浏览器一个新地址用以加载新页面，常用在Web表单中。重定向常用302状态码表示，指向的地址由Location首部提供。Flask提供了redirect()辅助函数来生成重定向响应：12345from flask import redirect@app.route('/')def index(): return redirect('http://www.example.com') abort函数（特殊响应）用于处理错误。示例中如果URL中动态参数id对应的用户不存在，就返回状态码404：12345678from flask import abort@app.route('/user/&lt;id&gt;')def get_user(id): user = load_user(id) if not user: abort(404) return '&lt;h1&gt;Hello, %s&lt;/h1&gt;' % user.name 注意，abort不会把控制权交还给调用它的函数，而是抛出异常把控制权交给Web服务器。 Flask扩展如何把扩展整合到程序中：示例，在hello.py中添加一个扩展，使用命令行参数增强程序的功能。 使用Flask-Script支持命令行选项传递设置选项的理想方式是使用命令行参数。Flask-Script是一个Flask扩展，为Flask程序添加了一个命令行解析器。安装方式：123456789101112(venv) $ pip install flask-script(venv) C:\Nana\flasky&gt;pip install flask-scriptCollecting flask-scriptRequirement already satisfied: Flask in c:\nana\flasky\venv\lib\site-packages (from flask-script)Requirement already satisfied: itsdangerous&gt;=0.21 in c:\nana\flasky\venv\lib\site-packages (from Flask-&gt;flask-script)Requirement already satisfied: Jinja2&gt;=2.4 in c:\nana\flasky\venv\lib\site-packages (from Flask-&gt;flask-script)Requirement already satisfied: Werkzeug&gt;=0.7 in c:\nana\flasky\venv\lib\site-packages (from Flask-&gt;flask-script)Requirement already satisfied: click&gt;=2.0 in c:\nana\flasky\venv\lib\site-packages (from Flask-&gt;flask-script)Requirement already satisfied: MarkupSafe&gt;=0.23 in c:\nana\flasky\venv\lib\site-packages (from Jinja2&gt;=2.4-&gt;Flask-&gt;flask-script)Installing collected packages: flask-scriptSuccessfully installed flask-script-2.0.5 示例2-3 hello.py: 使用Flask-Script1234567891011121314151617181920from flask import Flaskfrom flask_script import Managerapp = Flask(__name__)manager = Manager(app)@app.route('/')def index(): return '&lt;h1&gt;Hello World!&lt;/h1&gt;'@app.route('/user/&lt;name&gt;')def user(name): return '&lt;h1&gt;Hello, %s!&lt;/h1&gt;' % nameif __name__ == '__main__': manager.run() 专为Flask开发的扩展都暴漏在flask.ext命名空间下。这个扩展的初始化方法也适用于其他很多扩展：把程序实例作为参数传给构造函数， 初始化主类的实例。创建的对象可以在各个扩展中使用。这里，服务器由manager.run()启动，启动后就能解析命令行了。运行后，会显示一个用法消息： 1234567891011121314151617181920usage: hello.py [-h] &#123;shell,runserver&#125; ...positional arguments: &#123;shell,runserver&#125; shell Runs a Python shell inside Flask application context. runserver Runs the Flask development server i.e. app.run()optional arguments: -h, --help show this help message and exit我的运行结果，和书里有点出入：(venv) C:\Nana\flasky&gt;python hello.pyusage: hello.py [-?] &#123;runserver,shell&#125; ...positional arguments: &#123;runserver,shell&#125; runserver Runs the Flask development server i.e. app.run() shell Runs a Python shell inside Flask application context.optional arguments: -?, --help show this help message and exit shell命令：在程序的上下文中启动Python shell会话。runserver命令：启动Web服务器。运行python hello.py runserver将以调试模式启动Web服务器，但是还有很多选项可用：123456789101112131415161718192021222324252627282930我的和书里的有出入(venv) C:\Nana\flasky&gt;python hello.py runserver * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)(venv) C:\Nana\flasky&gt;python hello.py runserver --helpusage: hello.py runserver [-?] [-h HOST] [-p PORT] [--threaded] [--processes PROCESSES] [--passthrough-errors] [-d] [-D] [-r] [-R]Runs the Flask development server i.e. app.run()optional arguments: -?, --help show this help message and exit -h HOST, --host HOST -p PORT, --port PORT --threaded --processes PROCESSES --passthrough-errors -d, --debug enable the Werkzeug debugger (DO NOT use in production code) -D, --no-debug disable the Werkzeug debugger -r, --reload monitor Python files for changes (not 100&#123;'const': True, 'prog': 'hello.py runserver', 'option_strings': ['-r', '--reload'], 'help': 'monitor Python files for changes (not 100% safe for production use)', 'container': &lt;argparse._ArgumentGroup object at 0x0338BF30&gt;, 'default': None, 'required': False, 'type': None, 'dest': 'use_reloader', 'choices': None, 'metavar': None, 'nargs': 0&#125;afe for production use) -R, --no-reload do not monitor Python files for changes …host参数告诉Web服务器在哪个网络接口上监听来自客户端的链接，默认监听localhost上的连接，所以只接受来自服务器所在计算机发起的连接。 python hello.py runserver –host 0.0.0.0命令让Web服务器监听公共网络接口上的连接，允许同网中的其他计算机连接服务器（这样Web服务器可使用http://a.b.c.d:5000/网络中的任一台电脑进行访问，其中“a.b.c.d”是服务器所在计算机的外网IP地址）：12345678910(venv) C:\Nana\flasky&gt;python hello.py runserver --host 0.0.0.0 * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)192.168.1.22 - - [31/Aug/2017 22:10:20] "GET /user/%E5%A8%9C%E5%A8%9C HTTP/1.1" 200 -192.168.1.22 - - [31/Aug/2017 22:10:20] "GET /favicon.ico HTTP/1.1" 404 -192.168.1.22 - - [31/Aug/2017 22:10:37] "GET /user/Nana HTTP/1.1" 200 -调试1：http://192.168.1.22:5000/user/娜娜 显示Hello,娜娜!调试2：http://192.168.1.22:5000/user/Nana 显示Hello,Nana!CTRL+C 退出 然后输入python hello.py runserver调试3：http://192.168.1.22:5000/user/Nana 显示无法访问此网站，192.168.1.22 拒绝了我们的连接请求。调试4：http://127.0.0.1:5000/user/Nana 显示Hello,Nana! 模板视图函数的作用很明确，即生成请求的响应。一般而言，请求会改变程序的转台，而这种变化也会在视图函数中产生。业务逻辑和表现逻辑混在一起会导致代码难以理解和维护。把表现逻辑移到模板中能够提升程序的可维护性。模板是一个包含响应文本的文件，其中包含用占位变量表示的动态部分，其具体值只在请求的上下文中才能知道。渲染：使用真实值替换变量，再返回最终得到的响应字符串的过程。Flask使用Jinja2模板引擎来渲染模板。 Jinja2模板引擎形式最简单的Jinja2模板就是一个包含响应文本的文件。示例3-1 templates/index.html: Jinja2模板1&lt;h1&gt;Hello World!&lt;/h1&gt; 示例3-2 templates/user.html: Jinja2模板1&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt; 渲染模板默认情况下，Flask在程序文件夹中的templates子文件夹中寻找模板。示例3-3 hello.py: 渲染模板1234567891011121314151617181920from flask import Flask, render_templatefrom flask_script import Managerapp = Flask(__name__)manager = Manager(app)@app.route(&apos;/&apos;)def index(): return render_template(&apos;index.html&apos;)@app.route(&apos;/user/&lt;name&gt;&apos;)def user(name): return render_template(&apos;user.html&apos;, name=name) 收到一个名为name的变量if __name__ == &apos;__main__&apos;: manager.run() Flask提供的render_template()函数把Jinja2模板引擎集成到了程序中。render_template()函数： 第一个参数是模板的文件名。 随后的参数都是键值对，表示模板中变量对应的真实值。name=name：关键字参数，左边的“name”表示参数名，就是模板中使用的占位符;右边的“name”是当前作用域中的变量，表示同名参数的值。 变量示例3-2 templates/user.html: Jinja2模板1&lt;h1&gt;Hello, &#123;&#123; name &#125;&#125;!&lt;/h1&gt; 示例3-2 模板中使用的结构表示一个变量，它是一种特殊的占位符，告诉模板引擎这个位置的值从渲染模板时使用的数据中获取。Jinja2能识别所有类型的变量，甚至是一些复制的类型，例如列表、字典和对象。p*4 用户在表单中输入的文本，千万不能使用safe 4.4 在视图函数中处理表单4.5 重定向和用户会话Post/重定向/Get模式 这里使用get()获取字典中键对应的值来避免未找到键的异常情况？？？ 4.6 Flask消息五、数据库5.1 SQL数据库外键，引用同一个表？或不同表中某行的主键？？？ 5.2 NoSQL数据库NoSQL数据库使用集合代替表，使用文档代替记录。? 减少了表的数量，却增加了数据重复量。好处： 数据重复可以提升查询速度？？？。列出用户及其角色的操作很简单，因为无需联结。 5.3 使用SQL还是NoSQL那大型程序呢？ 5.4 Python数据库框架数据库抽象库代码包？？？使用这些抽象包直接处理高等级的Python对象，而不用处理如表 文档和查询语言此类的数据库实体 ORM ODM 平台提供了那些数据库可供选择 5.5 使用Flask-SQLAlchemy管理数据库ad对象是 类的实例？？？ 5.6 定义模型模型？？？ db.String(64)?默认的表名没有遵守使用复数形式进行命名的约定，？？？index=True是什么意思？？？ BigInterger 不限制精度的整数？？？ Numeric 定点数？ String和Text的区别 repr()??? 5.7 关系面向对象视角？？？ 关系表？？？多对多？？？ 5.8 数据库操作5.8.1 创建表5.8.2 插入行回滚？？？ 5.8.3 修改行5.8.4 删除行5.8.5 查询行Query对象paginate对象？？？ 5.9 在视图函数中操作数据库5.10 集成Python shell5.11 使用Flask-Migrate实现数据库迁移5.11.1 创建迁移仓库5.11.2 创建迁移脚本5.11.3 更新数据库六、电子邮件6.1 使用Flask-Mail提供电子邮件支持6.1.1 在Python shell中发送电子邮件6.1.2 在程序中集成发送电子邮件功能6.1.3 异步发送电子邮件七、大型程序的结构7.1 项目结构7.2 配置选项7.3 程序包7.3.17.3.27.47.57.6、.1.2.3.4.5.6、.1.2.3.4.5.6]]></content>
      <categories>
        <category>Flask</category>
      </categories>
      <tags>
        <tag>Flask</tag>
        <tag>Web开发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scrapy安装报错的解决办法]]></title>
    <url>%2F2017%2F08%2F30%2Fscrapy%E5%AE%89%E8%A3%85%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Windows系统的电脑通过pip安装scrapy的过程中，有时会遇到如下错误: 123456789101112error: command &apos;cl.exe&apos; failed: No such file or directory ---------------------------------------- Failed building wheel for Twisted Running setup.py clean for TwistedFailed to build Twisted............error: command &apos;cl.exe&apos; failed: No such file or directory ----------------------------------------Command &quot;c:\users\administrator\envs\portexaminer\scripts\python.exe -u -c &quot;import setuptools, tokenize;__file__=&apos;C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\pip-build-8wsecd7d\\Twisted\\setup.py&apos;;f=getattr(tokenize, &apos;open&apos;, open)(__file__);code=f.read().replace(&apos;\r\n&apos;, &apos;\n&apos;);f.close();exec(compile(code, __file__, &apos;exec&apos;))&quot; install --record C:\Users\ADMINI~1\AppData\Local\Temp\pip-xv8fa2ny-record\install-record.txt --single-version-externally-managed --compile --install-headers c:\users\administrator\envs\portexaminer\include\site\python3.5\Twisted&quot; failed with error code 1 in C:\Users\ADMINI~1\AppData\Local\Temp\pip-build-8wsecd7d\Twisted\ 网上搜索了很久，试了很多方法还是报错，最后终于解决了。 解决办法： 1.首先检查电脑里安装Microsoft Visual Studio的路径如C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin下是否有cl.exe这个文件，如果没有要重新下载安装icrosoft Visual Studio 14.0，并确保安装路径如C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin下有cl.exe这个文件； 2.把cl.exe的安装路径如C:\Program Files (x86)\Microsoft Visual Studio 14.0\VC\bin添加到环境变量PATH； 3.Unofficial Windows Binaries for Python Extension Packages这个网站上有很多window系统的python第三方包文件。 找到对应版本的Twisted并下载，下载后在Twisted的目录下按住Shift键，右击选择在此处打开命令窗口（W），进入window的命令窗口CMD。 复制Twisted文件名，注意一般文件名不能连同文件后缀一起复制，这里要确保将文件名和文件后缀一起复制。 在CMD中输入pip install Twisted-17.5.0-cp35-cp35m-win32.whl（注意这个Twisted包对应的是window32位系统python3.5的版本，小伙伴下载的时候要下载有自己电脑系统及python版本对应的Twisted扩展包）, 下载完成后再通过pip下载scrapy。 更多：Scrapy官网]]></content>
      <categories>
        <category>Scrapy</category>
      </categories>
      <tags>
        <tag>Scrapy</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电脑多版本Python共存的方法]]></title>
    <url>%2F2017%2F08%2F27%2F%E7%94%B5%E8%84%91%E5%AE%89%E8%A3%85%E5%A4%9A%E7%89%88%E6%9C%ACpython%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[常说一山不容二虎，但是通过一些小技巧，一电脑还是可以容二python的（一机可容二蛇，逃）。如果电脑里有多个不同版本的python，安装python虚拟环境经常会出现python版本混乱的情况。比如通过mkvirtualenv新建虚拟环境后，进入虚拟环境后，命令行输入python,结果发现当前虚拟环境的python版本不是自己要的。网上查了常用的方法是修改python文件名，比如python2下的python.exe或pip.exe或virtualenv.exe或mkvirtualenv.bat等文件名改成python2.exe或pip2.exe或virtualenv2.exe或mkvirtualenv2.bat，python3同理。然后在命令行指定，比如基于python2的，就使用pip2 install xxx, mkvirtualenv2 xxx等。但是这样设置有点麻烦，而且有时虽然运行的是xx2,但是输入python验证后，发现还是基于python3的。这里我来介绍一个命令行指明python安装路径来指定python版本的方法，来安装对应的虚拟环境。这种方法我个人用起来觉得非常方便，但是具体因人而异。 本文例子基于以下电脑配置参数： 操作系统：windows10 64位python版本如下： Python 2.7.12，安装路径：C:\Python27 Python 3.5.3，安装路径：C:\Users\Administrator\AppData\Local\Programs\Python\Python35-32 经常使用python的童鞋知道，如果我们安装python的时候勾选了Add python.exe to path，则环境变量里面已经有python安装路径了。如果我们安装python的时候没有勾选Add python.exe to path，我们需要把python安装路径添加到环境变量。这是使用命令行运行pythond的前提, 否则会报错。这样找到python安装路径的方法就非常简单了，直接打开环境变量，复制里面的python路径就可以了。 假设我们要安装两个python虚拟环境，一个基于python2的虚拟环境apple2, 一个基于python3的虚拟环境apple3 基于python2的虚拟环境打开cmd，输入mkvirtualenv –python C:\Python27\python.exe apple2，然后再新建的虚拟环境下运行python,查看对应的python版本。运行结果如下：123456789C:\Users\Administrator&gt;mkvirtualenv --python C:\Python27\python.exe apple2Running virtualenv with interpreter C:\Python27\python.exeNew python executable in C:\Users\Administrator\Envs\apple2\Scripts\python.exeInstalling setuptools, pip, wheel...done.(apple2) C:\Users\Administrator&gt;pythonPython 2.7.12 (v2.7.12:d33e0cf91556, Jun 27 2016, 15:24:40) [MSC v.1500 64 bit (AMD64)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; ^Z 基于python3的虚拟环境（注意这里因为之前要安装一个只支持32位python的python第三方包，所以我安装python3的版本是32位的。）12345678910C:\Users\Administrator&gt;mkvirtualenv --python C:\Users\Administrator\AppData\Local\Programs\Python\Python35-32\python.exe apple3Running virtualenv with interpreter C:\Users\Administrator\AppData\Local\Programs\Python\Python35-32\python.exeUsing base prefix 'C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35-32'New python executable in C:\Users\Administrator\Envs\apple3\Scripts\python.exeInstalling setuptools, pip, wheel...done.(apple3) C:\Users\Administrator&gt;pythonPython 3.5.3 (v3.5.3:1880cb95a742, Jan 16 2017, 15:51:26) [MSC v.1900 32 bit (Intel)] on win32Type "help", "copyright", "credits" or "license" for more information.&gt;&gt;&gt; ^Z 命令格式从上面看出创建不同版本的python虚拟环境的命令如下：mkvirtualenv –python xxx(python安装路径\python.exe) 虚拟环境名 也可以写成如下，亲测有效：mkvirtualenv –python==xxx(python安装路径\python.exe) 虚拟环境名]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>版本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git常见命令小结]]></title>
    <url>%2F2017%2F08%2F25%2FGit%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一、前言Git是目前世界上最先进的分布式版本控制系统。Git是Linux创始人Linus花了两周时间自己用C写的一个分布式版本控制系统。学习Git分布式版本控制系统，可以帮助我们告别手动管理多个“版本”的痛苦过去，拥抱版本控制的美好明天。 二、安装Git具体安装教程请参考廖雪峰老师的官方网站。安装完成后，需要设置Git的用户名和邮箱，在命令行输入：12$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;email@example.com&quot; 注意git config命令的–global参数，表示全局配置。 三、创建版本库Repository3.1 创建空目录：123$ mkdir xxx （创建指定的名称的目录）$ cd xxx （切换工作目录）$ pwd （显示当前目录） 3.2 初始化仓库12$ git init （把当前目录变成Git可以管理的仓库）Initialized empty Git repository in /xxx/xxx/xxx/.git/ 初始化仓库后，当前目录下多了一个.git目录，这个目录是Git用来跟踪管理版本库的。如果没有看到.git目录，用ls-ah命令可以看见默认隐藏的目录。 3.3 添加文件到版本库 git add命令告诉Git把文件添加到仓库： 1$ git add &lt;file&gt; (如git add readme.md) git commit命令告诉Git把文件提交到仓库： 1$ git commit -m &quot;xxx&quot; -m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 注意commit可以一次提交很多文件，所以可以多次add不同的文件。 四、查看日志4.1 查看提交日志git log命令显示从最近到最远的提交日志：1$ git log 精简日志，加上–pretty=oneline参数：1$ git log --pretty=oneline 用git log可以查看提交历史，以便确定要回退到哪个版本。 4.2 查看命令日志1$ git reflog $ git reflog命令用来记录每一次命令用git reflog查看命令历史，以便确定要回到未来的哪个版本。 五、版本回退在Git中，用HEAD表示当前版本，也就是最新的提交，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写成HEAD~100。 5.1 当前版本回退到上一个版本1$ git reset --hard HEAD^ 5.2 根据commit id指定某个版本12$ git reset --hard commit_id HEAD is now at commit_id xxx 六、管理文件操作6.1 显示文件内容1$ cat filename 6.2 查看仓库状态1$ git status 6.3 查看工作区和版本库最新版本的区别1$ git diff HEAD -- &lt;file&gt; 6.4 撤销工作区修改 1git checkout -- &lt;file&gt; git checkout – 让文件回到最近一次git commit或git add时的状态。命令中的–很重要，没有–，就变成了“切换到另一个分支”的命令。 6.5 撤销暂存区修改1$ git reset HEAD &lt;file&gt; 把暂存区的修改撤销掉（unstage），重新放回工作区 6.6 删除文件删除工作区文件可以直接在文件管理器删除，或者用rm命令删除：1$ rm &lt;file&gt; 工作区文件删除后，工作区和版本库就不一致了。如果确定要从版本库删除文件，用命令git rm删掉，并且git commit:1$ git rm &lt;file&gt; 如果想撤销工作区文件的删除，因为版本库里还有文件，所以可以很轻松地把误删的文件恢复到最新版本：1$ git checkout -- &lt;file&gt; git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 七、远程仓库7.1 GitHub设置7.1.1 注册GitHub账号登录GitHub官网，注册GitHub账号。 7.1.2 创建SSH Key如果用户主目录没有.ssh目录，打开Shell（Windows下打开Git Bash），创建SSH Key：1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 按照默认设置完成后，在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对。注意，id_rsa是私钥，不能泄露出去，而id_rsa.pub是公钥，可以放心地告诉任何人。 7.1.3 Github设置SSH KeyGitHub-Account settings-SSH Keys-Add SSH Key，在Key文本框里粘贴id_rsa.pub文件的内容。 7.2 本地Git仓库添加远程库 GitHub-“Create a new repo 本地Git仓库下运行命令： 1$ git remote add origin git@github.com:username/repo_name.git 将本地Git仓库的所有内容推送到远程库上 1$ git push -u origin master 注意：由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。命令简化如下：1$ git push origin master 7.3 创建远程库并克隆到本地 登陆GitHub，创建一个新的仓库，名字叫repo_name，记得勾选勾选Initialize this repository with a README。 克隆一个本地库：$ git clone git@github.com:username/repo_name.git 八、分支管理8.1 创建与合并分支以dev分支为例 创建dev分支，并切换到dev分支：$ git checkout -b devgit checkout命令加上-b参数表示创建并切换，相当于以下两条命令：$ git branch dev$ git checkout dev 查看当前分支：$ git branch dev分支操作，和master分支的操作是一样的。 切换回master分支：$ git checkout master 把dev分支的工作成果合并到master分支上：$ git merge devgit merge命令用于合并指定分支到当前分支。 合并完成后，删除dev分支：$ git branch -d dev 查看branch，此时只剩下master分支：$ git branch 8.2 解决分支冲突当Git无法自动合并分支时，并且出现如下提示：Automatic merge failed; fix conflicts and then commit the result.就必须首先解决冲突。解决冲突后，再提交，合并完成。用git log –graph命令可以看到。1$ git log --graph --pretty=oneline --abbrev-commit 分支合并图缩略显示。 8.3 普通模式合并分支合并分支时，加上–no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。1$ git merge --no-ff -m &quot;版本说明&quot; 分支名 –no-ff参数，表示禁用Fast forward 8.4 “储藏”当前工作现场修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug，修复后，再git stash pop，回到工作现场。1$ git stash 查看工作现场保存位置，用git stash list命令看看：1$ git stash list 恢复工作现场： 是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除；12$ git stash apply stash@&#123;0&#125; 恢复指定的stash$ git stash drop 另一种方式是用git stash pop，恢复的同时把stash内容也删了1$ git stash pop 8.5 Feature分支开发一个新feature，最好新建一个分支；1$ git checkout -b feature-xxx 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。1$ git branch -D feature-xxx 8.6 多人协作查看远程库信息，用git remote：1$ git remote 使用git remote -v显示更详细的信息：1$ git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的；从本地推送分支，使用git push origin branch-name:1$ git push origin branch-name 如果推送失败，先用git pull抓取远程的新提交:1$ git pull 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致:1git checkout -b branch-name origin/branch-name 建立本地分支和远程分支的关联，使用git branch –set-upstream branch-name origin/branch-name:1git branch --set-upstream branch-name origin/branch-name 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 九、标签管理发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 9.1 创建标签命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id:1$ git tag &lt;name&gt; 命令git tag可以查看所有标签。 git show 查看标签信息：1$ git show &lt;tagname&gt; git tag -a -m “标签说明”可以指定标签信息:1git tag -a &lt;tagname&gt; -m &quot;标签说明&quot; -a指定标签名，-m指定说明文字 git tag -s -m “标签说明”可以用PGP签名标签，-s用私钥签名一个标签。 9.2 操作标签命令git push origin 可以推送一个本地标签：1$ git push origin &lt;tagname&gt; 命令git push origin –tags可以推送全部未推送过的本地标签：1$ git push origin --tags 命令git tag -d 可以删除一个本地标签：1git tag -d &lt;tagname&gt; 命令git push origin :refs/tags/可以删除一个远程标签。1git push origin :refs/tags/&lt;tagname&gt; 十、参与GitHub开源项目在GitHub上，可以任意Fork开源仓库。如果在GitHub上有个感兴趣的开源项目，可以在它的项目主页点“Fork”，在自己的账号下克隆了一个开源项目的仓库。然后从自己的账号下clone：git clone git@github.com:myusername/仓库名.git注意：一定要从自己的账号下clone仓库，这样你才能推送修改。如果你希望开源项目的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。可以推送pull request给官方仓库来贡献代码。 十一、更多国内的Git托管服务——码云。自定义Gitgit for windows 参考资料：Git教程-廖雪峰的官方网站更详细的Git使用教程，请详见廖雪峰老师的官方网站。这里只是整理了廖雪峰老师Git使用教程里的常用命令。]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python常见报错及解决办法]]></title>
    <url>%2F2017%2F08%2F24%2FPython%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[1. ‘python’ 不是内部或外部命令，也不是可运行的程序或批处理文件。 解决方案：添加python的安装路径到环境变量Path中, 告诉Windows如何找到你安装的Python版本。举例：假设python.exe安装路径是C:\Python27,在计算机系统属性里点击环境变量-系统变量中找到Path变量，编辑-新建-增加一行填上C:\Python27。提示：cmd中输入python，显示python版本信息及提示符&gt;&gt;&gt;，则设置成功。 2. ‘pip’ 不是内部或外部命令，也不是可运行的程序或批处理文件。解决方案：添加pip.exe的安装路径到环境变量Path中举例：假设pip.exe安装路径是C:\Python27\Scripts,在计算机系统属性里点击环境变量-系统变量中找到Path变量，编辑-新建-增加一行填上C:\Python27\Scripts。 3. pip安装python库超时ReadTimeoutError解决方案：安装国内镜像，使用豆瓣源或者清华源；cmd运行pip –default-timeout=100 install -U pip,手动设置超时时间。 4. pip list的DEPRECATION提示CMD中输入pip list后，显示：DEPRECATION: The default format will switch to columns in the future. You can use –format=(legacy|columns) (or define a format=(legacy|columns) in your pip.conf under the [list] section) to disable this warning. 解决方案：这是一个警告，告诉你以后pip list的默认格式会换成columns的格式，可以采用命令加上–format=(legacy|columns)或者在[list]下面的pip.conf里定义一个legacy|columns格式来取消这个警告。举例：window10系统下，在C:\Users\Administrator下新建一个文件夹，命名为pip;然后在pip上新建文件，pip.ini，里面输入内容如下：12[list]format=columns 再次输入pip list，警告就消失了。过程如下：123456789101112C:\Users\Administrator&gt;pip listDEPRECATION: The default format will switch to columns in the future. You can use --format=(legacy|columns) (or define a format=(legacy|columns) in your pip.conf under the [list] section) to disable this warning.beautifulsoup4 (4.6.0)colorama (0.3.9)decorator (4.1.2)C:\Users\Administrator&gt;pip listPackage Version--------------------- -------beautifulsoup4 4.6.0colorama 0.3.9decorator 4.1.2 格式对比如下：beautifulsoup4 (4.6.0) 旧格式beautifulsoup4 4.6.0 新格式 5. cmd输入pip, 报错: UnicodeDecodeError: ‘ascii’ codec can’t decode byte 0xc0 in position 0: ordinal not in range(128)解决方案： Python的安装目录C:/Python27/Lib/里找到mimetypes.py文件； 打开mimetypes.py文件，在import结束后添加如下代码：import sysreload(sys)sys.setdefaultencoding(‘utf-8’)保存文件,重新执行pip命令。 参考segmentfault]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Error</tag>
        <tag>Bug</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[The Zen Of Python]]></title>
    <url>%2F2017%2F08%2F23%2FThe%20Zen%20Of%20Python%2F</url>
    <content type="text"><![CDATA[在交互式解释器中输入import this就会显示Tim Peters的The Zen Of Python。 12345678910111213141516171819202122&gt;&gt;&gt; import thisThe Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren&apos;t special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you&apos;re Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it&apos;s a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let&apos;s do more of those!]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Zen</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML和CSS入门到应用(不定期更新)]]></title>
    <url>%2F2017%2F08%2F23%2FHTML%E5%92%8CCSS%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[一、解开HTML和CSS的神秘面纱HTML和CSS是用来创建网页的语言。Web服务器存储并提供由HTML和CSS创建的网页。浏览器接收网页并基于HTML和CSS显示其中的内容。HTML是关于结构的，它使内容结构化。CSS是关于样式的，主要用在设计和布局上。 1.1 HTMLHTML是超文本标记语言(HyperText Markup Lanuage)的缩写，用来结构化网页。 1.1.1 HTML结构超文本标记语言的结构通常应该有一个&lt;html&gt;元素，并伴随有一个&lt;head&gt;元素、一个&lt;title&gt;元素和一个&lt;body&gt;元素。网页的信息来源于&lt;head&gt;元素。&lt;head&gt;````&lt;/head&gt; 通过头部告诉浏览器有关网页的信息。&lt;title&gt;&lt;/title&gt;标题嵌入头部，通常会出现在浏览器窗口的顶部。写进&lt;body&gt;元素中的内容就是在浏览器中所能看见的东西。 1.1.2 标记标记是用尖括号括起来的字母或单词，例如&lt;head&gt;&lt;p&gt;&lt;h1&gt;等，它是由尖括号和标记名组成的。我们用包围文本的成对标记告诉浏览器网页的结构，它告诉浏览器文本的结构和意义。 标记分为开始标记、结束标记。开始标记可以拥有属性，如type和align。元素的属性用来为一个元素提供附加信息。结束标记的左尖括号之后，标记名之前有一个”/“, 用来区别于开始标记。 一对开始标记、结束标记为匹配标记，如&lt;h1&gt;Hello&lt;/h1&gt;。 注意：浏览器显示HTML文件时会忽略制表符、回车、还有大多数的空格。它们根据我们的标记来确定哪里分行或者分段。随着文件越来越复杂，空格、回车还有制表符对提高HTML文件的可读性是非常有帮助的。 1.1.3 元素我们使用HTML来标记内容，用标记提供结构。我们称匹配标记和他们之间的内容为元素。一个元素由以下三个部分组成：一个开始标记、内容和一个结束标记。有些元素如&lt;img&gt;是例外。元素 = 开始标记 + 内容 + 结束标记整个语句成为一个元素，一个元素由闭合标记及它们之间的内容组成。有一些只用一个标记作为速记符号的元素,如&lt;img src=&quot;drink.gif&quot;&gt;，这种元素我们称为空元素。许多HTML元素会在它们的标记之间嵌入另外一个元素。 1.2 CSSCSS是级联样式表(Cascading Style Sheet)的缩写，用来控制HTML的外观。当浏览器显示HTML时，它使用了自带的默认样式来表现结构。在HTML中用CSS指定每个元素的样式特性。CSS用来描述如何表现内容。通过在&lt;style&gt;元素中输入CSS规则，给HTML网页添加CSS。 &lt;style&gt;元素通常嵌在&lt;head&gt;元素中。&lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; CSS使用一种和HTML截然不同的语法。如下所示：CSS有很多种方法来指定颜色。 最普遍的做法叫做”十六进制编码”，#d2b48c就是这种格式。CSS规则前边都有个”body”, 意味着{和}之间的所有CSS将应用于HTML元素中的内容。 Tips:1.取消隐藏常见文件类型的文件扩展名：资源管理器-文件夹选项-查看-高级设置-取消“隐藏已知文件类型的扩展名”的勾选。2.注释：&lt;!--和--&gt;可以写成多行，任何写在&lt;!--和--&gt;之间的内容都会被浏览器忽略。3.创建html文件的时候，windows用户还需要选择“所有文件”作为文件类型，否则记事本会在文件名后添加“.txt” 二、深入理解超文本2.1 &lt;a&gt;元素当你需要从一个网页链接到另一个网页时，使用&lt;a&gt;元素。&lt;a&gt;元素中的href属性说明了链接的目的地。&lt;a&gt;元素中的内容是链接的标签。标签显示在网页上。默认情况下，它会加下划线来说明是可以单击的。链接的标签可以是文字或图像。当你点击链接时，浏览器装载href中指定的网页。 2.2 上溯下探网站顶层文件夹保存所有站点文件，通常称为网站“根”目录的是包含整个网站的顶层文件夹。有时我们希望某些图像能在几个网页中重复使用，所以把图像全部放到根目录（最顶层）下的一个文件夹里。如果网站需要在不同的部分使用大量的图像，就可以在每个枝叶目录下设置各自的图像文件夹。枝叶：描述文件夹的方式就像一颗倒栽的树，顶部为根，到下边文件或目录的每条路径就是枝叶。有时我们把文件位置改动后，发现图像不显示，统称称其为损坏的图像。点击链接，出现错误，说找不到该网页。注意，某些浏览器会用网页而不是对话框来报错。问题出在浏览器认为文件还在之前的文件夹里，要更改链接，使他们指向现在所在的新文件夹里。这时我们需要把路径从页面指向目的文件，可以上溯或者下探一个或两个文件夹，都必须把相对路径放到href中去。 2.2.1 下探yyy文件夹/xxx文件名这里/分隔路径的各个部分，点击链接，浏览器在yyy文件夹中寻找xxx文件。下探的深度由创建的文件夹的层数来决定。如果创建的目录有10层深，路径可以写10层目录。但是太多级目录文件夹时，可能代表你的网站组织过于复杂了。另外路径还有字数的限制，最后255个。 2.2.2 上溯：../xxx文件名这里上溯一个文件夹用“.. ”，点击链接，浏览器在上一级文件目录中寻找xxx文件。上溯文件夹不只一个： 每上溯一层使用一次..，每用一次..就上溯了一层文件父目录。 如果要上溯两层目录，格式：“../../xxx文件夹”。../..可以称为“祖父”目录， 但通常，称其为“父目录”的父亲上溯可以直至你网站的根目录 2.3 组织网站最好在构建的早起组织好你的网站，这样当网站升级使就不用更改一堆路径了。组织网站的方式有许多，怎么做取决于你。]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程设计资源]]></title>
    <url>%2F2017%2F08%2F23%2F%E7%BC%96%E7%A8%8B%E8%AE%BE%E8%AE%A1%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[搜索引擎编程过程中经常会遇到各种问题报错，用好搜索引擎就非常重要了。谷歌 –lantern，你懂的百度 前端W3C –前端基础NexT –NexT网站主题liveStyle –前端可视化工具liveReload –前端可视化工具browserSync –前端可视化工具从 psd 到 html –切图实战教程前端工程师必备的PS技能——切图篇DILLINGER –在线编辑Markdown网站 正则表达式正则表达式在网站url配置以及网络爬虫中非常重要。Regexper –可视化工具Regulex –可视化工具Debuggex –可视化工具相关教程：正则表达式30分钟入门教程 –虽然作者也承认30分钟是不够的，逃 PythonPython官网PyPI - the Python Package IndexUnofficial Windows Binaries for Python Extension Packages –window系统的python第三方包文件Pycharm –Python IDE，带有一整套可以帮助用户在使用Python语言开发时提高其效率的工具django –Python主流开源Web应用框架flask –Python轻量级Web应用框架Tornado –Python异步Web应用框架Python列表、元组、字典和字符串的常用函数 DjangoDjango1.11.6的中文文档Django官方文档 图床七牛云图床神器 –免注册，免费，上传图片，不过有限制，每个文件大小不能超过5MB, 每次最多只能上传10张图片 文本编辑器Sublime Text –主流前端开发编辑器ATOM –GitHub的开源免费代码编辑器Vim –类似于Vi的著名的功能强大、高度可定制的文本编辑器textmate –Mac下的著名的文本编辑器软件，与BBedit一起并称苹果机上的emacs和vim 美国服务器搬瓦工Bangwagon VPS –美国服务器搬瓦工Bangwagon VPS China –美国服务器搬瓦工中国站Bangwagon Host-Client Area –美国服务器 搬瓦工客户中心 更多stackoverflow –遇到报错可以经常来这里找找解决办法Git For Windows –Windows系统下的GitA Byte of Python –简明 Python 教程为知笔记 –好记性不如烂笔头，多做笔记，多思考Ming’s Blog –明的博客W3Tachs –网站技术分析廖雪峰官方网站 –Javascript/Python/Git等教程GitHub –代码托管网站Quora –国外问答网站SaltTiger –每天一本编程书，每天进步一点点慕课网Zhihu豆瓣开发者服务豆瓣API快速入门LinkedIn程序员在线工具爱折腾好折腾origamiLeanCloudGithub DesktopUEditorDjangoUeditorFreeCodeCamp/chinese聚学在线An overview of all Markdown elementsKENNETH REITZ –逆袭男神的程序大神Django 学习小组琪中有不凡ATOOL在线工具在线DXF和DWG看图国家企业信用信息公示系统学信网asciinema –asciinema [as-kee-nuh-muh] is a free and open source solution for recording terminal sessions and sharing them on the web.HTML 5 Outliner –用标题和分节元素生成一个可导航的页面大纲，HTML5大纲生成页面Normalize.cssCan I useAutoprefixer CSS online –浏览器前缀的后处理程序Letasoft Sound Booster –系统音量增大软件Visual Studio Code 我们的人生很长，遇到的问题很多，而且经常不带重样的。经验主义显然没办法全部应付。唯有升维思考，多问为什么，对症下药，才能在残酷的现实社会当中，从容面对各种问题，并将它们各个击破。-两种思维方式的不同 但是啊，人生不一样，人生有很多正确答案，继续读大学是正确答案，不去也是，热衷运动也是，喜欢音乐也好，和朋友一起玩耍也罢，为了某人而绕远路也是，这些都是正确答案。-《龙樱》 Letasoft Sound Booster]]></content>
      <categories>
        <category>资源</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>资源</tag>
      </tags>
  </entry>
</search>
